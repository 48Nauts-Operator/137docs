<!-- Auto-generated by Claude on 2025-06-02 06:15 -->

# Dynamic Analysis Agent

This module provides a dynamic analysis agent capable of inspecting Python modules and objects in memory at runtime. It's designed to extract documentation and structural information from Python objects that may not be available through static analysis.

## Purpose

The dynamic analysis agent is used when:
- Source code is not available (e.g., built-in modules like `itertools`)
- Objects have been created or modified dynamically at runtime
- Static analysis is insufficient to capture the complete structure

This module complements static analysis by using Python's introspection capabilities to examine live objects.

## Main Functions

### `inspect()`

```python
def inspect(
    module_name: str,
    *,
    filepath: Path | None = None,
    import_paths: Sequence[str | Path] | None = None,
    extensions: Extensions | None = None,
    parent: Module | None = None,
    docstring_parser: DocstringStyle | Parser | None = None,
    docstring_options: dict[str, Any] | None = None,
    lines_collection: LinesCollection | None = None,
    modules_collection: ModulesCollection | None = None,
) -> Module
```

**Purpose**: Main entry point for inspecting a module dynamically.

**Key Features**:
- Imports and inspects modules that can't be analyzed statically
- Works with built-in modules and dynamically modified objects
- Returns a `Module` object with populated members

**Parameters**:
- `module_name`: The module to inspect (as used in import statements)
- `filepath`: Optional file path for the module
- `import_paths`: Custom paths for importing the module
- `extensions`: Extensions to use during inspection
- `parent`: Optional parent module
- `docstring_parser`: Parser for processing docstrings
- Other collections for managing source lines and modules

## Main Classes

### `Inspector`

The core class that performs the dynamic inspection using a visitor-like pattern.

#### Key Attributes

- `module_name`: Name of the module being inspected
- `filepath`: Optional file path
- `current`: Current object being inspected (Module or Class)
- `extensions`: Extensions for customizing inspection behavior
- `docstring_parser`: Parser for processing docstrings

#### Important Methods

##### `get_module()`
```python
def get_module(self, import_paths: Sequence[str | Path] | None = None) -> Module
```
- Main method that triggers complete module inspection
- Handles dynamic imports with custom import paths
- Returns fully populated Module instance

##### `inspect()` and Specialized Inspection Methods
The Inspector uses a dispatch pattern with methods for different object types:

- `inspect_module()`: Handles module objects
- `inspect_class()`: Handles class objects  
- `inspect_function()`: Handles regular functions
- `inspect_method()`: Handles instance methods
- `inspect_staticmethod()`: Handles static methods
- `inspect_classmethod()`: Handles class methods
- `inspect_property()`: Handles property objects
- `inspect_attribute()`: Handles attributes and variables

##### `handle_function()`
```python
def handle_function(self, node: ObjectNode, labels: set | None = None) -> None
```
- Central method for processing function-like objects
- Extracts signatures, parameters, and return type annotations
- Applies appropriate labels (e.g., "staticmethod", "property", "async")

##### `handle_attribute()`
```python
def handle_attribute(self, node: ObjectNode, annotation: str | Expr | None = None) -> None
```
- Processes attributes and variables
- Extracts values and annotations
- Handles special attributes like `__all__`

#### Helper Methods

- `_get_docstring()`: Extracts and cleans docstrings from objects
- `_get_linenos()`: Attempts to get source line numbers
- `generic_inspect()`: Handles child object inspection and aliasing

## Utility Functions

### `_convert_parameter()`
Converts Python `inspect.Parameter` objects to Griffe `Parameter` objects with proper type annotations and defaults.

### `_convert_object_to_annotation()`
Converts runtime type objects to string representations or expression trees for type annotations.

## Usage Notes

### Important Considerations

- **Not typically used directly**: Most users should use `GriffeLoader` and `load()` functions instead
- **Runtime imports**: This module actually imports and executes the target modules
- **Exception handling**: Robust error handling for various inspection failures
- **Extension support**: Integrates with the extension system for customization

### When to Use

✅ **Good for**:
- Built-in modules without source code
- Dynamically generated classes/functions  
- C extension modules
- Modules with complex runtime modifications

❌ **Avoid when**:
- Static analysis is sufficient
- Security concerns about code execution
- Source code analysis is preferred

### Performance Considerations

- Dynamic inspection requires importing modules
- May trigger side effects during import
- Slower than static analysis
- Memory usage from loaded objects

## Example Integration

```python
# Typically used through the loader system
from griffe import load

# This may use dynamic inspection for built-in modules
module = load("itertools", try_relative_path=False)

# Direct usage (advanced)
from griffe.agents.inspector import inspect

module = inspect(
    "itertools", 
    docstring_parser="google",
    import_paths=["/custom/path"]
)
```

## Extension Points

The Inspector integrates with the extension system, calling hooks at various points:
- `on_node`: When visiting any node
- `on_module_node`/`on_class_node`/`on_function_node`: Type-specific node events  
- `on_instance`: When creating object instances
- `on_members`: When processing object members
- `on_alias`: When creating aliases

This allows extensions to customize the inspection behavior and add additional processing.