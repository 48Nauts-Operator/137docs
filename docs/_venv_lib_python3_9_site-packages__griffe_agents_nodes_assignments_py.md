<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Assignment Node Utilities

## Overview

This module provides utilities for extracting information from Python Abstract Syntax Tree (AST) assignment nodes. It's designed to parse and extract variable names, attribute names, and instance attribute names from different types of assignment statements in Python code.

## Purpose

The module serves as a helper for code analysis tools that need to:
- Extract variable names from assignment statements
- Handle both regular assignments (`=`) and annotated assignments (`:`)
- Distinguish between regular variables and instance attributes (those prefixed with `self.`)
- Parse complex attribute access patterns

## Core Functions

### `get_name(node: ast.AST) -> str`

Extracts a single name from an AST node.

**Parameters:**
- `node`: An AST node (typically `ast.Name` or `ast.Attribute`)

**Returns:**
- A string representing the extracted name

**Supported Node Types:**
- `ast.Name`: Returns the identifier name
- `ast.Attribute`: Returns the full attribute path (e.g., `obj.attr`)

```python
# Example usage:
# For code: x = 5
# get_name(target_node) -> "x"

# For code: self.value = 10  
# get_name(target_node) -> "self.value"
```

### `get_names(node: ast.AST) -> list[str]`

Extracts all names from an assignment node.

**Parameters:**
- `node`: An assignment AST node (`ast.Assign` or `ast.AnnAssign`)

**Returns:**
- A list of strings containing all extracted names

**Supported Assignment Types:**
- `ast.Assign`: Regular assignments (handles multiple targets)
- `ast.AnnAssign`: Annotated assignments with type hints

```python
# Example usage:
# For code: a, b = 1, 2
# get_names(assignment_node) -> ["a", "b"]

# For code: x: int = 5
# get_names(assignment_node) -> ["x"]
```

### `get_instance_names(node: ast.AST) -> list[str]`

Extracts only instance attribute names (those starting with `self.`).

**Parameters:**
- `node`: An assignment AST node

**Returns:**
- A list of attribute names without the `self.` prefix

```python
# Example usage:
# For code: self.name, self.age = "John", 25
# get_instance_names(assignment_node) -> ["name", "age"]

# For code: x, self.value = 1, 2
# get_instance_names(assignment_node) -> ["value"]
```

## Internal Implementation

### Helper Functions

- **`_get_attribute_name(node: ast.Attribute)`**: Recursively builds attribute access strings
- **`_get_name_name(node: ast.Name)`**: Extracts simple identifier names
- **`_get_assign_names(node: ast.Assign)`**: Handles regular assignment statements
- **`_get_annassign_names(node: ast.AnnAssign)`**: Handles annotated assignment statements

### Dispatch Maps

The module uses dictionary-based dispatch for efficient node type handling:

```python
_node_name_map: dict[type, Callable[[Any], str]]
_node_names_map: dict[type, Callable[[Any], list[str]]]
```

## Usage Notes

### ‚ö†Ô∏è Important Considerations

- **Error Handling**: The functions assume valid AST nodes. Invalid or unsupported node types will raise `KeyError` exceptions
- **Recursive Attributes**: Complex attribute chains (e.g., `obj.attr.subattr`) are supported through recursive name resolution
- **Type Safety**: Uses `from __future__ import annotations` for forward compatibility

### üí° Suggestions for Improvement

1. **Add Error Handling**: Consider adding try-catch blocks for unsupported node types
2. **Extend Node Support**: Could be extended to handle other assignment patterns like tuple unpacking
3. **Documentation**: Consider adding more detailed docstring examples
4. **Type Hints**: Could benefit from more specific type hints instead of `Any`

## Example Usage

```python
import ast

code = """
x = 5
self.name = "John"
a, b = 1, 2
value: int = 10
"""

tree = ast.parse(code)
for node in ast.walk(tree):
    if isinstance(node, (ast.Assign, ast.AnnAssign)):
        all_names = get_names(node)
        instance_names = get_instance_names(node)
        print(f"All names: {all_names}")
        print(f"Instance names: {instance_names}")
```

This module is particularly useful for static code analysis tools, linters, and documentation generators that need to understand variable assignments in Python code.