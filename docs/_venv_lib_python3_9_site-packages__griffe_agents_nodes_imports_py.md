<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Import Utilities Module

## Overview

This module provides utilities for working with Python imports, specifically for converting relative imports to absolute import paths. It's designed to work with Abstract Syntax Tree (AST) nodes and module objects from the Griffe library (a Python code analysis tool).

## Purpose

The primary purpose of this module is to resolve relative import statements (e.g., `from ..module import something`) into their absolute equivalents (e.g., `from package.subpackage.module import something`). This is particularly useful for:

- Static code analysis tools
- Documentation generators
- Code refactoring tools
- Import dependency tracking

## Dependencies

- **Standard Library**: `ast` (for AST node types)
- **Third-party**: `_griffe.models` (for Module class)
- **Type Checking**: Uses `TYPE_CHECKING` for conditional imports to avoid runtime dependencies

## Functions

### `relative_to_absolute()`

```python
def relative_to_absolute(node: ast.ImportFrom, name: ast.alias, current_module: Module) -> str
```

Converts a relative import path to its absolute equivalent.

#### Parameters

- **`node`** (`ast.ImportFrom`): The AST node representing a "from ... import ..." statement
- **`name`** (`ast.alias`): The specific name being imported from the module
- **`current_module`** (`Module`): The module object where the import statement occurs

#### Returns

- **`str`**: The absolute import path as a string

#### Algorithm

1. **Level Adjustment**: Adjusts the relative import level based on whether the current module is a package or subpackage
2. **Parent Traversal**: Walks up the module hierarchy based on the number of dots in the relative import
3. **Path Construction**: Builds the absolute path by combining:
   - Base module path (if it's a relative import)
   - Source module name (from the import statement)
   - Imported name

#### Example Usage

```python
# For a relative import like: from ..utils import helper
# In module: package.subpackage.module
# Would resolve to: package.utils.helper
```

## Implementation Notes

### Type Safety
- Uses `TYPE_CHECKING` to conditionally import types, preventing runtime import overhead
- Includes `# type: ignore[assignment]` comment to handle type checker limitations with parent module assignment

### Edge Cases Handled
- **Package vs Subpackage**: Different level adjustment logic for packages and subpackages
- **Missing Parent Modules**: Safely handles cases where parent modules might be `None`
- **Empty Module Names**: Handles cases where `node.module` might be `None`

## Suggestions for Improvement

1. **Error Handling**: Consider adding validation for:
   - Invalid relative import levels (going beyond root package)
   - Malformed AST nodes
   - Invalid module structures

2. **Documentation**: Add more detailed examples showing different relative import scenarios

3. **Testing**: Ensure comprehensive test coverage for edge cases like:
   - Imports at package root level
   - Deep nested relative imports
   - Mixed relative/absolute imports

4. **Performance**: For high-volume usage, consider caching resolved paths to avoid repeated parent traversal

## Dependencies Requirements

This module requires the Griffe library for the `Module` class. Ensure it's included in your project dependencies:

```bash
pip install griffe
```