<!-- Auto-generated by Claude on 2025-06-02 06:15 -->

# Runtime Object Utilities Module

This module provides utilities for extracting information from Python runtime objects. It's designed to help analyze and introspect Python objects, particularly for documentation generation or code analysis tools.

## Purpose

The module serves as a foundational component for tools that need to:
- Traverse and analyze Python object hierarchies
- Determine object types and relationships
- Handle alias resolution and import detection
- Extract metadata from runtime objects

## Key Components

### Global Variables

- **`_builtin_module_names`**: Set of built-in module names with leading underscores stripped
- **`_cyclic_relationships`**: Known problematic module relationships that cause import cycles

### Helper Functions

#### `_same_components(a: str, b: str) -> bool`
Compares two module paths by checking if their dot-separated components are identical when leading underscores are stripped.

```python
# Example usage
_same_components("_internal.module", "internal.module")  # Returns True
```

## Main Class: ObjectNode

The `ObjectNode` class is the core component that represents objects in a tree-like structure.

### Constructor

```python
def __init__(self, obj: Any, name: str, parent: ObjectNode | None = None)
```

**Parameters:**
- `obj`: The Python object to wrap
- `name`: The object's name
- `parent`: Optional parent node reference

### Key Properties

#### Basic Information
- **`path`**: Full dotted path to the object
- **`module`**: Reference to the module node containing this object
- **`module_path`**: Module path where the object was declared
- **`kind`**: Object type classification (see ObjectKind enum)
- **`children`**: Child objects as ObjectNode instances

#### Object Type Detection
The class provides boolean properties to identify object types:

- `is_module`: Module objects
- `is_class`: Class definitions
- `is_function`: Function objects (including partials)
- `is_method`: Instance/class methods
- `is_property`: Property descriptors
- `is_staticmethod`: Static methods
- `is_classmethod`: Class methods
- `is_builtin_function`: Built-in functions
- `is_coroutine`: Coroutine functions
- `is_attribute`: General attributes

#### Advanced Features

##### Alias Detection
```python
@cached_property
def alias_target_path(self) -> str | None:
```
Determines if an object should be treated as an alias and returns the target path. This handles:
- Import detection
- Module relationship cycles
- Built-in module path normalization

### Important Methods

#### `_pick_member(name: str, member: Any) -> bool`
Internal method that filters which object members should be included as children. Excludes:
- Special attributes (`__builtins__`, `__loader__`, `__spec__`)
- Built-in types (`type`, `object`)
- Circular references
- Members not directly defined in the object

## Usage Example

```python
import sys
from your_module import ObjectNode

# Create a node for a module
module_node = ObjectNode(sys, "sys")

# Access properties
print(f"Path: {module_node.path}")
print(f"Kind: {module_node.kind}")
print(f"Is module: {module_node.is_module}")

# Traverse children
for child in module_node.children:
    print(f"Child: {child.name} ({child.kind})")
```

## Important Notes

### Performance Considerations
- Uses `@cached_property` extensively to avoid repeated expensive operations
- Object unwrapping is performed safely with exception handling

### Error Handling
- Gracefully handles `inspect.unwrap()` failures that can occur with objects having custom `__getattr__` methods
- Provides fallback mechanisms for missing attributes

### Special Cases
- **Cached Properties**: Automatically unwraps `functools.cached_property` objects
- **Cyclic Relationships**: Prevents infinite loops in module relationships
- **Built-in Modules**: Normalizes module paths by removing leading underscores

## Suggestions for Use

1. **Memory Management**: Be cautious with large object hierarchies as the tree structure can consume significant memory
2. **Error Logging**: The module uses a logger for debugging - ensure proper logging configuration
3. **Extension**: The `exclude_specials` class variable can be modified to filter additional problematic attributes
4. **Type Safety**: The module includes comprehensive type hints for better IDE support and type checking

## Dependencies

- `inspect`: Core Python introspection
- `functools.cached_property`: Performance optimization
- `types.GetSetDescriptorType`: Type detection
- Custom `_griffe.enumerations.ObjectKind`: Object classification
- Custom `_griffe.logger`: Logging functionality