<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Runtime Object Utilities Documentation

This module provides utilities for extracting information from runtime Python objects, primarily used for code analysis and documentation generation.

## Purpose

The module helps analyze Python objects at runtime to determine their types, relationships, and metadata. It's particularly useful for:

- Static analysis tools
- Documentation generators
- Code introspection utilities
- Alias detection and resolution

## Key Components

### Global Variables

- **`_builtin_module_names`**: Set of built-in module names with leading underscores stripped
- **`_cyclic_relationships`**: Known cyclic relationships between modules that should be avoided
- **`exclude_specials`**: Class variable containing special attributes that cause issues during alias resolution

### Helper Functions

#### `_same_components(a: str, b: str) -> bool`
Compares two module paths by checking if they have the same components when leading underscores are stripped.

```python
_same_components("_os.path", "os.path")  # Returns True
```

## Main Class: ObjectNode

The `ObjectNode` class represents nodes in an object tree structure, where each node contains a Python object and maintains a reference to its parent.

### Constructor

```python
def __init__(self, obj: Any, name: str, parent: ObjectNode | None = None)
```

**Parameters:**
- `obj`: The Python object to wrap
- `name`: The object's name
- `parent`: Optional parent node reference

### Key Properties

#### Path and Module Information
- **`path`**: Full Python path to the object (e.g., `"module.Class.method"`)
- **`module`**: Reference to the module node containing this object
- **`module_path`**: String path to the object's declaring module

#### Object Classification
- **`kind`**: Returns an `ObjectKind` enum value indicating the object type
- **`children`**: Sequence of child `ObjectNode` objects

#### Type Checking Properties
The class provides numerous `is_*` properties to identify object types:

```python
node.is_module          # True if object is a module
node.is_class           # True if object is a class
node.is_function        # True if object is a function
node.is_method          # True if object is a method
node.is_property        # True if object is a property
node.is_staticmethod    # True if object is a staticmethod
node.is_classmethod     # True if object is a classmethod
# ... and more
```

#### Alias Detection
- **`alias_target_path`**: Returns the target path if this object should be treated as an alias, or `None` otherwise

### Important Methods

#### `_pick_member(name: str, member: Any) -> bool`
Determines whether a member should be included when building the object tree. Filters out:
- Special attributes that cause issues
- Built-in types (`type`, `object`)
- Circular references
- Members not directly defined in the object

## Usage Example

```python
import sys
from your_module import ObjectNode

# Create a node for a module
module_node = ObjectNode(sys, "sys")

# Access properties
print(module_node.path)        # "sys"
print(module_node.is_module)   # True
print(len(module_node.children))  # Number of sys module members

# Navigate the tree
for child in module_node.children:
    print(f"{child.name}: {child.kind}")
```

## Important Notes and Suggestions

### Error Handling
- The module includes robust error handling for object unwrapping, as some objects may raise exceptions during introspection
- Cyclic relationship detection prevents infinite loops during traversal

### Performance Considerations
- Most properties use `@cached_property` for performance optimization
- The `children` property performs introspection and should be used judiciously for large objects

### Limitations
- Attribute objects cannot be reliably detected as aliases
- Some built-in objects may report inconsistent module paths
- The tree structure is backward-linked only (parent references, no child references from parents)

### Best Practices
- Use the `kind` property instead of multiple `is_*` checks when possible
- Be aware that `alias_target_path` may return `None` for valid reasons (same module, attributes, etc.)
- Handle the `ValueError` that `module` property may raise for orphaned nodes

## Dependencies

- `inspect`: For object introspection
- `sys`: For built-in module information  
- `functools.cached_property`: For performance optimization
- `types.GetSetDescriptorType`: For descriptor type checking
- Custom `_griffe` modules for enumerations and logging