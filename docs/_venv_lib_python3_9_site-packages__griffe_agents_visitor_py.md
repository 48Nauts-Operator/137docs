<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Static Analysis Agent Module

This module contains the static analysis agent for the Griffe library, capable of parsing and visiting Python source code to extract API documentation information.

## Overview

The module provides functionality to statically analyze Python code by:
- Parsing Python source code into an Abstract Syntax Tree (AST)
- Visiting AST nodes to extract classes, functions, attributes, and other code elements
- Building a structured representation of the code's API surface
- Supporting extensions for custom analysis behavior

## Main Functions

### `visit()`

```python
def visit(
    module_name: str,
    filepath: Path,
    code: str,
    *,
    extensions: Extensions | None = None,
    parent: Module | None = None,
    docstring_parser: DocstringStyle | Parser | None = None,
    docstring_options: dict[str, Any] | None = None,
    lines_collection: LinesCollection | None = None,
    modules_collection: ModulesCollection | None = None,
) -> Module
```

**Purpose**: Main entry point for static analysis of a Python module.

**Parameters**:
- `module_name`: The module name (as used in imports)
- `filepath`: Path to the module file
- `code`: Source code content
- `extensions`: Optional extensions for custom analysis behavior
- `parent`: Optional parent module
- `docstring_parser`: Parser for extracting and processing docstrings
- `docstring_options`: Additional docstring parsing configuration
- `lines_collection`: Collection for tracking source code lines
- `modules_collection`: Collection for managing multiple modules

**Returns**: A `Module` object with populated members representing the analyzed code structure.

## Main Classes

### `Visitor`

The core class responsible for traversing the AST and extracting information.

#### Key Attributes

- `module_name`: Name of the module being analyzed
- `filepath`: Path to the source file
- `code`: Source code content
- `current`: Currently visited object (Module or Class)
- `type_guarded`: Whether current code branch is inside a `TYPE_CHECKING` block

#### Important Methods

##### `get_module()`
Builds and returns the complete module representation by triggering a full AST traversal.

##### `visit_*()` Methods
Specialized methods for handling different AST node types:

- **`visit_module()`**: Processes module-level nodes
- **`visit_classdef()`**: Handles class definitions, extracting:
  - Class name and location
  - Decorators and base classes
  - Docstrings
  - Labels based on decorators

- **`visit_functiondef()` / `visit_asyncfunctiondef()`**: Processes function definitions:
  - Function parameters and return annotations
  - Decorators (including property, staticmethod, classmethod)
  - Overload detection
  - Property setter/deleter handling

- **`visit_import()` / `visit_importfrom()`**: Tracks imports and creates aliases

- **`visit_assign()` / `visit_annassign()`**: Handles attribute assignments:
  - Module-level attributes
  - Class attributes vs instance attributes
  - `__all__` exports detection

- **`visit_if()`**: Special handling for `TYPE_CHECKING` blocks

##### `handle_attribute()`
Processes assignment nodes to create `Attribute` objects with appropriate labels:
- `module-attribute`: Module-level variables
- `class-attribute`: Class-level variables
- `instance-attribute`: Instance variables (typically in `__init__`)

##### `decorators_to_labels()`
Converts decorator information into semantic labels for better categorization.

## Constants and Mappings

### `builtin_decorators`
```python
builtin_decorators = {
    "property": "property",
    "staticmethod": "staticmethod", 
    "classmethod": "classmethod",
}
```
Maps built-in Python decorators to their corresponding labels.

### `stdlib_decorators`
```python
stdlib_decorators = {
    "abc.abstractmethod": {"abstractmethod"},
    "functools.cache": {"cached"},
    "functools.cached_property": {"cached", "property"},
    # ...
}
```
Maps standard library decorators to sets of semantic labels.

### `typing_overload`
```python
typing_overload = {"typing.overload", "typing_extensions.overload"}
```
Set of decorator paths that indicate function overloads.

## Key Features

### Type Guard Handling
The visitor tracks when code is inside `TYPE_CHECKING` blocks and marks those elements as not available at runtime.

### Property Handling
Special logic for detecting property setters and deleters, properly linking them to their base property.

### Overload Support
Detects and groups function overloads using `@overload` decorators.

### Extension System
Supports a plugin system through the `Extensions` class for custom analysis behavior.

## Usage Notes

- **Not typically used directly**: Most users should use `GriffeLoader` and the `load()` function instead
- **Optimization**: Uses `compile()` with `optimize=1` to remove assert statements for better performance  
- **Error handling**: Uses context managers and safe getter functions to handle parsing errors gracefully
- **Label system**: Extensively uses labels to categorize code elements (async, property, cached, etc.)

## Suggestions

- Consider the extension system for custom analysis needs
- Be aware of the type guarding feature when analyzing code with conditional imports
- The visitor maintains context about the current object being visited, enabling proper parent-child relationships in the extracted API structure