<!-- Auto-generated by Claude on 2025-06-02 06:15 -->

# Static Analysis Agent Documentation

## Overview

This module provides a static analysis agent for Python code that can parse and visit source files to extract structural information. It uses Python's Abstract Syntax Tree (AST) to analyze code without executing it, building a representation of modules, classes, functions, and other code elements.

## Purpose

The static analysis agent is designed to:
- Parse Python source code into an AST
- Extract module structure including classes, functions, attributes, and imports
- Handle decorators and their semantic meanings
- Process docstrings and annotations
- Support extensions for custom analysis behavior
- Build a complete object model of Python modules for documentation generation or code analysis

## Key Components

### Main Functions

#### `visit()`

```python
def visit(
    module_name: str,
    filepath: Path,
    code: str,
    *,
    extensions: Extensions | None = None,
    parent: Module | None = None,
    docstring_parser: DocstringStyle | Parser | None = None,
    docstring_options: dict[str, Any] | None = None,
    lines_collection: LinesCollection | None = None,
    modules_collection: ModulesCollection | None = None,
) -> Module
```

**Purpose**: Main entry point for static analysis of a Python module.

**Parameters**:
- `module_name`: The module name as used in imports
- `filepath`: Path to the module file
- `code`: Source code content
- `extensions`: Optional extensions for custom analysis
- `parent`: Optional parent module
- `docstring_parser`: Parser for extracting documentation
- `docstring_options`: Additional parsing options
- `lines_collection`: Collection of source code lines
- `modules_collection`: Collection of related modules

**Returns**: A `Module` object with all members populated

### Core Class

#### `Visitor`

The main visitor class that traverses the AST and builds the object model.

**Key Attributes**:
- `module_name`: Name of the module being analyzed
- `filepath`: Path to the source file
- `code`: Source code content
- `current`: Currently visited object (Module or Class)
- `type_guarded`: Whether current code branch is type-guarded (e.g., within `if TYPE_CHECKING:`)

**Key Methods**:

##### `get_module()`
Builds and returns the complete module representation by triggering a full AST visit.

##### `visit(node: ast.AST)`
Main visitor method that dispatches to specific node handlers based on AST node type.

##### Node-Specific Visit Methods

- **`visit_module()`**: Handles module-level nodes
- **`visit_classdef()`**: Processes class definitions
- **`visit_functiondef()`** / **`visit_asyncfunctiondef()`**: Handles function definitions
- **`visit_import()`** / **`visit_importfrom()`**: Processes import statements
- **`visit_assign()`** / **`visit_annassign()`**: Handles variable assignments
- **`visit_if()`**: Processes conditional statements (important for type checking blocks)

## Important Constants

### Decorator Mappings

```python
builtin_decorators = {
    "property": "property",
    "staticmethod": "staticmethod", 
    "classmethod": "classmethod",
}
```

Maps built-in Python decorators to semantic labels.

```python
stdlib_decorators = {
    "abc.abstractmethod": {"abstractmethod"},
    "functools.cache": {"cached"},
    "functools.cached_property": {"cached", "property"},
    # ... more mappings
}
```

Maps standard library decorators to sets of semantic labels.

```python
typing_overload = {"typing.overload", "typing_extensions.overload"}
```

Identifies function overload decorators for proper handling of overloaded methods.

## Key Features

### Decorator Processing
- Automatically recognizes and labels common decorators
- Handles property setters and deleters
- Processes function overloads
- Converts decorated functions to appropriate object types (e.g., properties become Attributes)

### Type Checking Support
- Detects `TYPE_CHECKING` blocks and marks contents as type-guarded
- Handles conditional imports and definitions

### Attribute Handling
- Distinguishes between class attributes, instance attributes, and module attributes
- Processes `ClassVar` annotations appropriately  
- Handles `__all__` definitions and augmented assignments

### Extension System
- Supports extensions that can hook into the analysis process
- Provides callbacks at various stages of node processing

## Usage Notes

### Important Considerations

1. **Not typically used directly**: Most users should use `GriffeLoader` and the `load()` function instead of calling `visit()` directly.

2. **AST Optimization**: The code uses `optimize=1` when compiling to remove assert statements for performance.

3. **Error Handling**: Uses `contextlib.suppress()` extensively to handle edge cases gracefully without stopping analysis.

4. **Cyclic Alias Detection**: Special handling for cases like `from . import module` in `__init__.py` files to avoid self-referential aliases.

### Extension Points

The visitor calls extension hooks at various stages:
- `on_node`: Called for every AST node
- `on_instance`: Called when creating object instances  
- `on_members`: Called after processing all members
- Specific hooks for modules, classes, functions, attributes, and aliases

### Type Guarding

Code within `if TYPE_CHECKING:` blocks is marked as type-guarded and objects created there have `runtime=False`, indicating they're only available during static analysis, not at runtime.

## Example Usage

```python
from pathlib import Path

# Read source code
code = Path("mymodule.py").read_text()

# Analyze the module
module = visit(
    module_name="mymodule",
    filepath=Path("mymodule.py"), 
    code=code,
    docstring_parser="google"  # or "numpy", "sphinx"
)

# Access extracted information
for name, member in module.members.items():
    print(f"{name}: {type(member).__name__}")
```

This static analysis agent forms the foundation for tools that need to understand Python code structure without executing it, such as documentation generators, code analyzers, and IDE features.