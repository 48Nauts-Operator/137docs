<!-- Auto-generated by Claude on 2025-06-02 06:15 -->

# Dataclasses Extension Documentation

## Overview

This file implements a built-in extension for the Griffe static analysis tool that adds support for Python dataclasses. The extension automatically generates `__init__` methods for dataclasses during static analysis, allowing documentation tools to properly understand and document dataclass constructors.

## Purpose

Python dataclasses use the `@dataclass` decorator to automatically generate special methods like `__init__` at runtime. However, static analysis tools cannot see these generated methods since they don't exist in the source code. This extension solves that problem by:

- Detecting classes decorated with `@dataclass`
- Analyzing dataclass fields and their configurations
- Generating appropriate `__init__` method signatures
- Handling inheritance from parent dataclasses
- Managing special dataclass features like `InitVar` and `field()` configurations

## Main Components

### Core Extension Class

```python
class DataclassesExtension(Extension)
```

The main extension class that integrates with the Griffe framework.

**Key Methods:**
- `on_package_loaded()`: Hook called when a package is loaded, triggers dataclass processing

### Utility Functions

#### Decorator Detection
- **`_dataclass_decorator(decorators)`**: Identifies if a class has the `@dataclass` decorator
- **`_dataclass_arguments(decorators)`**: Extracts arguments passed to the `@dataclass` decorator

#### Field Analysis
- **`_field_arguments(attribute)`**: Extracts arguments from `dataclasses.field()` calls
- **`_expr_args(expr)`**: Generic expression argument parser

#### Parameter Generation
- **`_dataclass_parameters(class_)`**: Generates parameter list from dataclass fields
- **`_reorder_parameters(parameters)`**: Orders parameters correctly (positional, positional-or-keyword, keyword-only)

#### Class Processing
- **`_set_dataclass_init(class_)`**: Creates the `__init__` method for a dataclass
- **`_del_members_annotated_as_initvar(class_)`**: Removes `InitVar` fields from class members
- **`_apply_recursively(mod_cls, processed)`**: Recursively processes modules and classes

## Key Features

### Dataclass Detection
The extension identifies dataclasses by looking for the `@dataclass` decorator:
```python
@dataclass
class Person:
    name: str
    age: int
```

### Field Configuration Support
Handles various `dataclasses.field()` configurations:
- `init=False`: Excludes field from `__init__`
- `default_factory`: Uses factory function as default
- `kw_only=True`: Makes field keyword-only

### Inheritance Handling
Properly handles dataclass inheritance by:
- Walking the Method Resolution Order (MRO)
- Collecting parameters from parent dataclasses
- Maintaining proper parameter ordering

### Special Annotations
- **`ClassVar`**: Excluded from `__init__` parameters
- **`InitVar`**: Included in `__init__` but removed from class members
- **`KW_ONLY`**: Marks subsequent fields as keyword-only

## Usage Notes

### Automatic Processing
The extension automatically processes all dataclasses when a package is loaded. No manual intervention is required.

### Caching
The `_dataclass_parameters()` function is cached using `@cache` to improve performance when processing the same class multiple times.

### Error Handling
- Uses `contextlib.suppress()` for graceful error handling
- Handles cases where MRO cannot be computed
- Manages missing or malformed annotations

## Implementation Details

### Parameter Kind Determination
```python
kind = (
    ParameterKind.keyword_only
    if kw_only or field_args.get("kw_only") == "True"
    else ParameterKind.positional_or_keyword
)
```

### Default Value Handling
The extension properly handles different types of defaults:
- Direct values from field definitions
- `default_factory` functions
- No default (required parameters)

## Integration

This extension integrates with the Griffe framework through the `Extension` base class and is automatically loaded when processing Python packages that contain dataclasses.

## Limitations

- Only processes classes that don't already have an `__init__` method
- Relies on proper type annotations for field detection
- May not handle extremely complex decorator configurations