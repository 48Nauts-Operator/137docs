<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# babel.lists Module Documentation

## Overview

The `babel.lists` module provides locale-dependent formatting of lists in different styles. It allows you to format sequences of strings into properly localized lists with appropriate separators and conjunctions based on the target locale.

## Purpose

This module addresses the need for internationalized list formatting, as different languages and locales have varying conventions for:
- List separators (commas, special characters)
- Conjunctions ("and", "or", locale-specific equivalents)
- Formatting styles for different contexts (standard, short, units, etc.)

The module uses the Unicode CLDR (Common Locale Data Repository) data to provide accurate locale-specific formatting.

## Environment Variables

The default locale is determined by these environment variables (in order of precedence):
- `LC_ALL`
- `LANG`

## Main Functions

### `format_list()`

The primary function for formatting lists with locale-specific conventions.

```python
def format_list(
    lst: Sequence[str],
    style: Literal['standard', 'standard-short', 'or', 'or-short', 'unit', 'unit-short', 'unit-narrow'] = 'standard',
    locale: Locale | str | None = None,
) -> str
```

#### Parameters

- **`lst`**: A sequence of string items to format into a list
- **`style`**: The formatting style to use (default: 'standard')
- **`locale`**: Target locale (defaults to system locale)

#### Supported Styles

| Style | Description | Example |
|-------|-------------|---------|
| `standard` | Typical 'and' list for arbitrary placeholders | "January, February, and March" |
| `standard-short` | Short version of 'and' list | "Jan., Feb., and Mar." |
| `or` | Typical 'or' list for arbitrary placeholders | "January, February, or March" |
| `or-short` | Short version of 'or' list | "Jan., Feb., or Mar." |
| `unit` | List suitable for wide units | "3 feet, 7 inches" |
| `unit-short` | List suitable for short units | "3 ft, 7 in" |
| `unit-narrow` | List for narrow units (limited space) | "3′ 7″" |

#### Usage Examples

```python
from babel.lists import format_list

# English formatting
format_list(['apples', 'oranges', 'pears'], locale='en')
# Output: 'apples, oranges, and pears'

# Chinese formatting
format_list(['apples', 'oranges', 'pears'], locale='zh')
# Output: 'apples、oranges和pears'

# Finnish 'or' style
format_list(['omena', 'peruna', 'aplari'], style='or', locale='fi')
# Output: 'omena, peruna tai aplari'
```

## Internal Functions

### `_resolve_list_style()`

```python
def _resolve_list_style(locale: Locale, style: str)
```

Internal function that resolves the appropriate list formatting patterns for a given locale and style, with fallback support.

## Fallback Mechanism

The module includes a sophisticated fallback system defined in `_style_fallbacks` that ensures compatibility when specific styles aren't available in a locale:

```python
_style_fallbacks = {
    "or-narrow": ["or-short", "or"],
    "or-short": ["or"],
    "standard-narrow": ["standard-short", "standard"],
    "standard-short": ["standard"],
    "unit": ["unit-short", "standard"],
    "unit-narrow": ["unit-short", "unit", "standard"],
    "unit-short": ["standard"],
}
```

## Important Notes

### Deprecation Warning
- The `DEFAULT_LOCALE` constant is deprecated and will be removed in version 3.0
- Use `babel.core.default_locale()` instead

### Error Handling
- Returns empty string for empty lists
- Returns single item unchanged for single-item lists
- Raises `ValueError` if no suitable formatting style can be found for the locale

### Compatibility
- Based on CLDR 45's root.xml file specifications
- Follows Unicode TR35-49 specification for list patterns
- All locales support at least `standard` and `or` styles as fallbacks

## Dependencies

- `babel.core.Locale`: For locale parsing and data access
- `babel.core.default_locale`: For default locale determination
- Standard library modules: `warnings`, `collections.abc`, `typing`

## Best Practices

1. **Always specify locale explicitly** when possible for predictable results
2. **Test fallback behavior** for less common locales and styles
3. **Handle empty lists** appropriately in your application logic
4. **Consider context** when choosing between different styles (standard vs. unit formatting)