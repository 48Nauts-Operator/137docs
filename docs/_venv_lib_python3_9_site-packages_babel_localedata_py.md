<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# babel.localedata

## Overview

The `babel.localedata` module provides low-level access to locale data used by the Babel internationalization library. It handles loading, caching, and processing of locale data files stored as pickled dictionaries, which contain data from the Common Locale Data Repository (CLDR).

> **Note**: While this module provides direct access to locale data, the `Locale` class offers a more convenient interface for most use cases.

## Key Components

### Global Variables

- `_cache`: Dictionary storing loaded locale data for performance
- `_cache_lock`: Thread-safe lock for cache operations
- `_dirname`: Path to the locale data files directory
- `_windows_reserved_name_re`: Regex pattern for Windows reserved filenames

## Functions

### `normalize_locale(name: str) -> str | None`

Normalizes a locale identifier by standardizing casing and whitespace.

**Parameters:**
- `name`: The locale identifier string to normalize

**Returns:**
- Normalized locale ID string or `None` if not recognized

**Example:**
```python
normalize_locale("en_us")  # Returns "en_US"
normalize_locale("invalid")  # Returns None
```

### `resolve_locale_filename(name: os.PathLike[str] | str) -> str`

Converts a locale identifier to the corresponding `.dat` file path on disk.

**Parameters:**
- `name`: Locale identifier or path

**Returns:**
- Full path to the locale data file

**Raises:**
- `ValueError`: If the name is a Windows reserved name

### `exists(name: str) -> bool`

Checks if locale data is available for a given locale identifier.

**Parameters:**
- `name`: The locale identifier string

**Returns:**
- `True` if locale data exists, `False` otherwise

### `locale_identifiers() -> list[str]`

Returns a cached list of all available locale identifiers.

**Features:**
- Results are cached using `@lru_cache`
- Cache can be cleared with `locale_identifiers.cache_clear()`
- Excludes the 'root' locale from results

**Returns:**
- List of available locale identifier strings

### `load(name: os.PathLike[str] | str, merge_inherited: bool = True) -> dict[str, Any]`

Loads locale data for a specified locale with inheritance support.

**Parameters:**
- `name`: Locale identifier string or "root"
- `merge_inherited`: Whether to merge inherited data (default: `True`)

**Returns:**
- Dictionary containing locale data

**Features:**
- Automatic inheritance from parent locales
- Thread-safe caching mechanism
- Handles special cases like non-likely scripts
- Results are cached for performance

**Example:**
```python
data = load('en_US')
print(data['languages']['sv'])  # Output: 'Swedish'
```

### `merge(dict1: MutableMapping[Any, Any], dict2: Mapping[Any, Any]) -> None`

Merges data from one dictionary into another, handling nested structures.

**Parameters:**
- `dict1`: Target dictionary to merge into
- `dict2`: Source dictionary containing data to merge

**Features:**
- Deep copying of nested dictionaries
- Special handling for `Alias` objects
- In-place modification of `dict1`

## Classes

### `class Alias`

Represents an alias reference within locale data.

**Methods:**

#### `__init__(keys: tuple[str, ...]) -> None`
Creates an alias with the specified key path.

#### `resolve(data: Mapping[str | int | None, Any]) -> Mapping[str | int | None, Any]`
Resolves the alias recursively using the provided data.

**Features:**
- Handles nested alias resolution
- Supports tuple-based alias combinations

### `class LocaleDataDict(abc.MutableMapping)`

A dictionary wrapper that automatically resolves aliases when accessing values.

**Methods:**

#### `__init__(data: MutableMapping, base: Mapping | None = None)`
Initializes the wrapper with data and optional base reference.

#### Key Dictionary Methods
Implements standard dictionary interface (`__getitem__`, `__setitem__`, `__delitem__`, etc.)

**Features:**
- Automatic alias resolution on access
- Nested `LocaleDataDict` creation for subdictionaries
- Lazy evaluation and caching of resolved values
- Thread-safe operations

## Usage Notes

### Performance Considerations
- Locale data is cached after first load for better performance
- Use thread-safe operations when accessing cached data
- Consider memory usage when loading many locales

### Best Practices
- Use `exists()` to check availability before loading
- Prefer the higher-level `Locale` class for most applications
- Clear caches when needed using `locale_identifiers.cache_clear()`

### Error Handling
- Handle `IOError` when locale files are missing
- Validate locale identifiers before use
- Be aware of platform-specific filename restrictions on Windows

## Dependencies

The module relies on several standard library modules:
- `os`, `pickle` for file operations
- `threading` for thread safety
- `functools.lru_cache` for performance optimization
- `collections.abc` for abstract base classes