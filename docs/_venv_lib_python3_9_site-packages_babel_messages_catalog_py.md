<!-- Auto-generated by Claude on 2025-06-02 06:15 -->

# babel.messages.catalog

This module provides data structures for representing message catalogs used in internationalization (i18n) and localization. It's part of the Babel library for Python internationalization.

## Purpose

The module defines classes and utilities for:
- Managing translation message catalogs (`.po` and `.pot` files)
- Handling pluralization rules for different locales
- Validating translation messages
- Updating catalogs from templates
- Managing catalog metadata and headers

## Key Classes

### Message

Represents a single translatable message in a catalog.

```python
class Message:
    def __init__(
        self,
        id: _MessageID,
        string: _MessageID | None = '',
        locations: Iterable[tuple[str, int]] = (),
        flags: Iterable[str] = (),
        auto_comments: Iterable[str] = (),
        user_comments: Iterable[str] = (),
        previous_id: _MessageID = (),
        lineno: int | None = None,
        context: str | None = None,
    ) -> None:
```

#### Key Properties
- **`id`**: The message identifier (string or tuple for plurals)
- **`string`**: The translated text
- **`locations`**: Source code locations where the message appears
- **`flags`**: Message flags (e.g., 'fuzzy', 'python-format')
- **`context`**: Message context for disambiguation
- **`pluralizable`**: Whether the message supports plural forms
- **`python_format`**: Whether the message contains Python-style format strings
- **`python_brace_format`**: Whether the message contains Python f-string format

#### Important Methods
- **`check(catalog=None)`**: Validates the message and returns errors
- **`clone()`**: Creates a deep copy of the message
- **`is_identical(other)`**: Compares messages for exact equality

### Catalog

Represents a complete message catalog with metadata and all messages.

```python
class Catalog:
    def __init__(
        self,
        locale: Locale | str | None = None,
        domain: str | None = None,
        header_comment: str | None = DEFAULT_HEADER,
        project: str | None = None,
        version: str | None = None,
        copyright_holder: str | None = None,
        msgid_bugs_address: str | None = None,
        creation_date: datetime.datetime | str | None = None,
        revision_date: datetime.datetime | datetime.time | float | str | None = None,
        last_translator: str | None = None,
        language_team: str | None = None,
        charset: str | None = None,
        fuzzy: bool = True,
    ) -> None:
```

#### Key Properties
- **`locale`**: Target locale for translations
- **`domain`**: Message domain (namespace)
- **`project`**: Project name
- **`version`**: Project version
- **`num_plurals`**: Number of plural forms for the locale
- **`plural_expr`**: Plural expression for the locale
- **`mime_headers`**: MIME headers for the catalog

#### Important Methods

**Adding/Managing Messages:**
```python
# Add a message
catalog.add(id, string=None, locations=(), flags=(), ...)

# Get a message
message = catalog.get(id, context=None)

# Delete a message
catalog.delete(id, context=None)

# Dictionary-style access
catalog[id] = message
message = catalog[id]
```

**Validation:**
```python
# Check all messages in catalog
for message, errors in catalog.check():
    print(f"Message {message.id} has errors: {errors}")
```

**Catalog Updates:**
```python
# Update catalog from template
catalog.update(
    template,
    no_fuzzy_matching=False,
    update_header_comment=False,
    keep_user_comments=True,
    update_creation_date=True
)
```

### TranslationError

Exception raised when translation validation fails.

```python
class TranslationError(Exception):
    """Exception thrown by translation checkers when invalid message
    translations are encountered."""
```

## Important Functions

### get_close_matches
```python
def get_close_matches(word, possibilities, n=3, cutoff=0.6):
```
Modified version of `difflib.get_close_matches` for fuzzy matching of message IDs during catalog updates.

### Format Detection Functions
- **`_has_python_brace_format(string)`**: Detects Python f-string format patterns
- **`_parse_datetime_header(value)`**: Parses datetime strings from catalog headers

## Constants

- **`DEFAULT_HEADER`**: Default header comment template for new catalogs
- **`PYTHON_FORMAT`**: Regex pattern for detecting Python-style format strings

## Usage Examples

### Creating a Catalog
```python
from babel.messages.catalog import Catalog
from babel import Locale

# Create a new catalog
catalog = Catalog(
    locale='de_DE',
    project='MyProject',
    version='1.0',
    copyright_holder='My Company'
)
```

### Adding Messages
```python
# Simple message
catalog.add('Hello', 'Hallo', locations=[('main.py', 10)])

# Pluralizable message
catalog.add(
    ('One item', '{count} items'),
    ('Ein Element', '{count} Elemente'),
    locations=[('items.py', 15)]
)

# Message with context
catalog.add('Date', 'Datum', context='calendar')
```

### Checking Messages
```python
# Validate all messages
for message, errors in catalog.check():
    for error in errors:
        print(f"Error in {message.id}: {error}")
```

## Notes and Suggestions

### Best Practices
1. **Always specify locations** when adding messages to track where they're used
2. **Use contexts** for messages that might have different meanings
3. **Validate catalogs** regularly using the `check()` method
4. **Handle pluralization** properly for international audiences

### Performance Considerations
- Message lookup is O(1) using internal dictionary storage
- Fuzzy matching during updates can be expensive for large