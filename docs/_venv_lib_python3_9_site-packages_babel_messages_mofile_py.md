<!-- Auto-generated by Claude on 2025-06-02 06:15 -->

# babel.messages.mofile

## Overview

This module provides functionality for reading and writing GNU gettext MO (Machine Object) files. MO files are the compiled binary format used by the gettext internationalization system to store translated messages for efficient runtime lookup.

## Purpose

- **Read MO files**: Parse binary MO files and convert them to Babel `Catalog` objects
- **Write MO files**: Generate binary MO files from Babel `Catalog` objects
- **Format compatibility**: Ensures compatibility with GNU gettext conventions and standards

## Constants

```python
LE_MAGIC: int = 0x950412de  # Little-endian magic number
BE_MAGIC: int = 0xde120495  # Big-endian magic number
```

These magic numbers are used to identify valid MO files and determine their byte order.

## Functions

### `read_mo(fileobj: SupportsRead[bytes]) -> Catalog`

Reads a binary MO file and returns a corresponding `Catalog` object.

**Parameters:**
- `fileobj`: File-like object containing the MO file data

**Returns:**
- `Catalog`: Babel catalog object with parsed messages and metadata

**Features:**
- Handles both little-endian and big-endian MO files
- Parses message contexts (using `\x04` separator)
- Supports plural forms (using `\x00` separator)
- Extracts catalog metadata headers
- Validates file integrity

**Error Handling:**
- Raises `OSError` for invalid magic numbers
- Raises `OSError` for corrupted files

### `write_mo(fileobj: SupportsWrite[bytes], catalog: Catalog, use_fuzzy: bool = False) -> None`

Writes a catalog to a file using the GNU MO file format.

**Parameters:**
- `fileobj`: File-like object to write the MO data to
- `catalog`: Babel catalog object containing messages to write
- `use_fuzzy`: Whether to include messages marked as "fuzzy" (default: False)

**Features:**
- Generates GNU-compatible MO files
- Handles plural forms and message contexts
- Sorts messages for consistent output
- Filters out empty translations and fuzzy messages (unless specified)
- Uses little-endian format for maximum compatibility

## File Structure

The MO file format consists of:

1. **Header** (28 bytes):
   - Magic number (4 bytes)
   - Version (4 bytes)
   - Number of messages (4 bytes)
   - Offset to key index (4 bytes)
   - Offset to value index (4 bytes)
   - Hash table size and offset (8 bytes)

2. **Index tables**: Arrays of length/offset pairs for keys and values
3. **String data**: Concatenated message strings

## Usage Examples

### Reading a MO file

```python
from babel.messages.mofile import read_mo

with open('messages.mo', 'rb') as f:
    catalog = read_mo(f)
    print(f"Loaded {len(catalog)} messages")
```

### Writing a MO file

```python
from babel.messages.mofile import write_mo
from babel.messages import Catalog

catalog = Catalog(locale='en_US')
catalog.add('Hello', 'Hola')
catalog.add('Goodbye', 'Adi√≥s')

with open('output.mo', 'wb') as f:
    write_mo(f, catalog)
```

## Notes and Suggestions

### Important Notes

- The `read_mo` implementation is based on the `GNUTranslations._parse` method from Python's standard library
- MO files use null bytes (`\x00`) to separate plural forms
- Message contexts are separated using the `\x04` character
- Empty message IDs (length 0) contain catalog metadata headers

### Performance Considerations

- Messages are sorted during writing for consistent output
- The format doesn't use hash tables, relying on sequential lookup
- File integrity is validated during reading to prevent corruption issues

### Best Practices

- Always handle `OSError` exceptions when reading MO files
- Use `use_fuzzy=False` (default) for production MO files
- Ensure proper character encoding in the source catalog
- Test MO file compatibility with standard gettext tools

### Limitations

- No hash table support (uses sequential search)
- Limited to GNU gettext MO format conventions
- Requires proper byte order handling for cross-platform compatibility