<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Unicode Properties Module Documentation

## Overview

This Python module contains Unicode property data for decomposition types based on **Unicode version 13.0.0**. The module is auto-generated and provides character range data for various Unicode decomposition types and their ASCII equivalents.

## Purpose

The module serves as a data source for Unicode text processing applications that need to:
- Identify character decomposition types
- Handle Unicode normalization
- Process different forms of character representation (canonical, compatibility, positional forms, etc.)
- Filter characters based on their Unicode properties

## Data Structures

### `unicode_decomposition_type`

A dictionary mapping decomposition type names to Unicode character ranges represented as strings.

**Type:** `dict[str, str]`

**Structure:**
- **Keys:** Decomposition type names (strings)
- **Values:** Unicode character ranges as compact string representations

#### Key Categories

| Category | Description |
|----------|-------------|
| `^canonical` | Characters that are NOT canonically decomposed |
| `^compat` | Characters that are NOT compatibility decomposed |
| `^font` | Characters that are NOT font variants |
| `^circle` | Characters that are NOT circled variants |
| `^square` | Characters that are NOT squared variants |
| `^fraction` | Characters that are NOT fraction variants |
| `^super` | Characters that are NOT superscript variants |
| `^sub` | Characters that are NOT subscript variants |
| `^vertical` | Characters that are NOT vertical variants |
| `^wide` | Characters that are NOT wide variants |
| `^narrow` | Characters that are NOT narrow variants |
| `^small` | Characters that are NOT small variants |
| `^initial` | Characters that are NOT initial positional forms |
| `^medial` | Characters that are NOT medial positional forms |
| `^final` | Characters that are NOT final positional forms |
| `^isolated` | Characters that are NOT isolated positional forms |
| `^nobreak` | Characters that are NOT non-breaking variants |
| `^none` | Characters that have decomposition (not "none") |

**Positive Categories** (without `^` prefix):
- `canonical`, `compat`, `font`, `circle`, `square`, `fraction`
- `super`, `sub`, `vertical`, `wide`, `narrow`, `small`
- `initial`, `medial`, `final`, `isolated`, `nobreak`, `none`

### `ascii_decomposition_type`

A simplified dictionary for ASCII-only character processing.

**Type:** `dict[str, str]`

**Key Features:**
- Most negative categories (`^*`) map to the full Unicode range `"\x00-\U0010ffff"`
- Most positive categories map to empty strings `""`
- Special cases:
  - `^none` maps to `""` (empty)
  - `none` maps to `"\x00-\U0010ffff"` (full range)

## Usage Examples

```python
# Check if a character has canonical decomposition
canonical_chars = unicode_decomposition_type["canonical"]

# Get characters that are NOT font variants
non_font_chars = unicode_decomposition_type["^font"]

# ASCII-only processing
ascii_canonical = ascii_decomposition_type["canonical"]
```

## Character Range Format

Character ranges are represented as compact strings containing:
- Individual characters: `"abc"`
- Unicode escapes: `"\u0041\u0042"`
- Range notation: `"a-z"` (represents characters from 'a' to 'z')
- Extended Unicode: `"\U00010000-\U0010ffff"`

## Important Notes

### ‚ö†Ô∏è Performance Considerations
- Character range strings can be very long (thousands of characters)
- Consider parsing ranges into more efficient data structures for frequent lookups
- The compact string format is optimized for storage, not query performance

### üîß Usage Recommendations
- **Parse ranges into sets or binary search trees** for O(1) or O(log n) lookups
- **Cache parsed results** if performing many character property checks
- **Use appropriate libraries** like `unicodedata` for standard Unicode operations

### üìù Data Currency
- Based on **Unicode 13.0.0** (may not include newer Unicode additions)
- Auto-generated content - verify against current Unicode standards if needed
- Consider updating to newer Unicode versions for production applications

## Integration Suggestions

```python
# Example: Convert range string to character set
def parse_unicode_range(range_string):
    """Convert compact range string to set of characters"""
    # Implementation would parse ranges like "a-z\u0100-\u0200"
    # This is a placeholder - actual implementation needed
    pass

# Example: Check if character has property
def has_property(char, property_name):
    """Check if character has specified decomposition property"""
    range_str = unicode_decomposition_type.get(property_name, "")
    char_set = parse_unicode_range(range_str)
    return char in char_set
```

## Related Unicode Standards

- [Unicode Standard Annex #15 - Normalization Forms](https://unicode.org/reports/tr15/)
- [Unicode Character Database](https://unicode.org/ucd/)
- [Unicode Decomposition Types](https://unicode.org/reports/tr44/#Decomposition_Type)