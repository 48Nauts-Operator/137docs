<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Unicode Grapheme Cluster Break Properties

This Python file contains auto-generated Unicode character properties for grapheme cluster breaking based on Unicode version 13.0.0. It provides character class definitions used for text segmentation algorithms to properly handle complex text layout, especially for languages with combining characters, emoji, and other special Unicode sequences.

## Purpose

The file serves as a data source for implementing Unicode's Grapheme Cluster Boundary Algorithm (UAX #29), which determines where text can be broken into user-perceived characters (grapheme clusters). This is essential for:

- Text cursor movement
- Character counting
- Text selection
- Text rendering and layout

## Data Structures

### `unicode_grapheme_cluster_break`

A comprehensive dictionary mapping grapheme cluster break property names to Unicode character ranges.

**Type**: `dict[str, str]`

**Key Categories**:

#### Break Properties
- `control` - Control characters that affect text layout
- `cr` - Carriage return character (`\r`)
- `lf` - Line feed character (`\n`) 
- `extend` - Extending characters (combining marks, etc.)
- `zwj` - Zero Width Joiner character
- `prepend` - Characters that prepend to grapheme clusters
- `spacingmark` - Spacing combining marks
- `regionalindicator` - Regional indicator symbols (flag sequences)

#### Hangul Properties (Korean text)
- `l` - Hangul Leading Jamo
- `v` - Hangul Vowel Jamo  
- `t` - Hangul Trailing Jamo
- `lv` - Hangul LV syllables
- `lvt` - Hangul LVT syllables

#### Emoji Properties
- `ebase` - Emoji base characters
- `ebasegaz` - Emoji base characters with GAZ property
- `emodifier` - Emoji modifier characters
- `glueafterzwj` - Characters that glue after ZWJ

#### Negated Properties
Properties prefixed with `^` represent the complement (inverse) of the character set.

### `ascii_grapheme_cluster_break`

A simplified version containing only ASCII-relevant character properties.

**Type**: `dict[str, str]`

Most properties are empty strings since ASCII characters don't exhibit the complex grapheme clustering behavior found in Unicode.

## Key Properties

### Control Characters
```python
"control": "\x00-\x09\x0b-\x0c\x0e-\x1f\x7f-\x9f..."
```
Characters that control text layout and shouldn't be broken.

### Line Breaking
```python
"cr": "\x0d"  # Carriage return
"lf": "\x0a"  # Line feed
```
Special handling for line break sequences.

### Extending Characters
```python
"extend": "\u0300-\u036f\u0483-\u0489..."
```
Combining marks and other characters that extend the base character.

## Usage Notes

⚠️ **Important Considerations**:

1. **Auto-generated Content**: This file is auto-generated and should not be manually edited
2. **Unicode Version**: Based on Unicode 13.0.0 - may need updates for newer Unicode versions
3. **Performance**: The character ranges are stored as strings and may need parsing for efficient lookup
4. **Memory Usage**: Contains extensive Unicode ranges that may impact memory usage

## Implementation Suggestions

### Character Range Parsing
```python
def parse_unicode_range(range_str):
    """Parse Unicode range string into usable character sets"""
    # Implementation needed to convert range strings to character sets
    pass
```

### Efficient Lookups
Consider converting string ranges to more efficient data structures like:
- Interval trees
- Bitmap arrays for ASCII ranges  
- Hash sets for sparse ranges

### Caching
For performance-critical applications, consider caching parsed character sets rather than parsing ranges repeatedly.

## Related Standards

- **UAX #29**: Unicode Text Segmentation
- **UAX #11**: East Asian Width  
- **UAX #15**: Unicode Normalization Forms

## Dependencies

- **Python 3.7+**: Uses `dict[str, str]` type annotations requiring Python 3.7 or later
- **from __future__ import annotations**: Enables forward reference type annotations