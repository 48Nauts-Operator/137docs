<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Unicode Indic Positional Category Module

## Overview

This module contains Unicode character classification data for **Indic Positional Categories** based on Unicode version 13.0.0. It provides mappings of Unicode characters organized by their positional properties, which are primarily used for text processing in Indic scripts (such as Hindi, Bengali, Tamil, etc.).

## Purpose

The Indic Positional Category property is crucial for:
- **Text rendering** in Indic scripts
- **Font selection** and glyph positioning
- **Text layout engines** that need to understand character positioning
- **Linguistic analysis** of South Asian languages
- **Input method editors** (IMEs) for Indic languages

## Data Structures

### `unicode_indic_positional_category`

A dictionary mapping positional category names to Unicode character ranges.

```python
unicode_indic_positional_category: dict[str, str]
```

**Categories include:**
- `bottom` - Characters positioned below the base
- `top` - Characters positioned above the base  
- `left` - Characters positioned to the left of the base
- `right` - Characters positioned to the right of the base
- `na` - Not applicable (most characters)
- `overstruck` - Characters that overlay the base
- Combined positions like `topandbottom`, `leftandright`, etc.
- Negated categories (prefixed with `^`) representing the complement set

### `ascii_indic_positional_category`

A simplified version for ASCII-only processing.

```python
ascii_indic_positional_category: dict[str, str]
```

**Key characteristics:**
- Most categories map to the full Unicode range (`"\x00-\U0010ffff"`)
- Only `na` category contains actual ASCII characters
- Other positional categories are empty strings for ASCII

## Character Range Format

Character ranges are encoded as compact strings using Unicode escape sequences:
- `\x00-\u093b` - Range from U+0000 to U+093B
- `\u0941-\u0944` - Range from U+0941 to U+0944  
- Individual characters and ranges are concatenated together

## Usage Examples

```python
# Check if a character has bottom positioning
def has_bottom_position(char):
    code_point = ord(char)
    # Would need range parsing logic to check if code_point is in the range
    return char in parse_unicode_ranges(unicode_indic_positional_category['bottom'])

# Get all characters that are NOT in bottom position
complement_bottom = unicode_indic_positional_category['^bottom']
```

## Important Notes

‚ö†Ô∏è **Auto-generated Content**: This file is automatically generated and should not be manually edited.

üìù **Range Parsing Required**: The string format requires parsing logic to convert range strings into usable character sets.

üî§ **Unicode Version**: Based on Unicode 13.0.0 - newer Unicode versions may have additional characters.

## Categories Explained

| Category | Description | Example Use Case |
|----------|-------------|------------------|
| `top` | Diacritics above base character | Vowel marks in Devanagari |
| `bottom` | Diacritics below base character | Subscript marks |
| `left` | Pre-base characters | Some vowel signs |
| `right` | Post-base characters | Certain consonant forms |
| `na` | No special positioning | Most base characters |
| `overstruck` | Overlaid on base | Special combining marks |

## Integration Suggestions

1. **Add Range Parser**: Implement a function to convert string ranges to character sets
2. **Caching**: Consider caching parsed ranges for performance
3. **Validation**: Add functions to validate character categories
4. **Documentation**: Generate human-readable category lists for debugging

## Dependencies

- `from __future__ import annotations` - Enables forward reference type hints for Python < 3.9