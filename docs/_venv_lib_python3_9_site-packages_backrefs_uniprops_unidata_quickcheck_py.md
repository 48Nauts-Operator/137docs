<!-- Auto-generated by Claude on 2025-06-02 06:15 -->

# Unicode Properties from Unicode 13.0.0

This Python file contains auto-generated Unicode normalization properties from Unicode version 13.0.0. It provides quick check tables for determining Unicode normalization forms without performing full normalization.

## Purpose

The file defines character sets for **Unicode Normalization Quick Check** operations, which allow applications to:
- Quickly determine if text is already in a specific normalization form
- Identify characters that require normalization processing
- Optimize Unicode text processing by avoiding unnecessary normalization

## Important Data Structures

### Unicode Quick Check Tables

The file contains four main normalization form tables:

#### 1. `unicode_nfc_quick_check`
Quick check for **Normalization Form Composed (NFC)**

#### 2. `unicode_nfd_quick_check` 
Quick check for **Normalization Form Decomposed (NFD)**

#### 3. `unicode_nfkc_quick_check`
Quick check for **Normalization Form Compatibility Composed (NFKC)**

#### 4. `unicode_nfkd_quick_check`
Quick check for **Normalization Form Compatibility Decomposed (NFKD)**

### ASCII Quick Check Tables

Simplified tables for ASCII-only text processing:
- `ascii_nfc_quick_check`
- `ascii_nfd_quick_check` 
- `ascii_nfkc_quick_check`
- `ascii_nfkd_quick_check`

## Key Structure

Each normalization table contains the following keys:

- **`"y"`** - Characters that are **YES** (already in normalized form)
- **`"n"`** - Characters that are **NO** (not in normalized form) 
- **`"m"`** - Characters that are **MAYBE** (require further checking)
- **`"^y"`** - Complement of YES characters
- **`"^n"`** - Complement of NO characters  
- **`"^m"`** - Complement of MAYBE characters

## Data Format

Character ranges are represented as Unicode range strings, for example:
```python
"\x00-\u02ff\u0305\u030d-\u030e\u0310\u0312"
```

This represents:
- Characters from `\x00` to `\u02ff`
- Character `\u0305`
- Characters from `\u030d` to `\u030e`
- Characters `\u0310` and `\u0312`

## Usage Notes

### Performance Optimization
- Use ASCII tables when processing ASCII-only text for better performance
- Check the "y" (YES) category first - if all characters match, no normalization needed
- Check the "n" (NO) category to identify text that definitely needs normalization

### Integration Suggestions
```python
# Example usage pattern
def needs_nfc_normalization(text):
    # Check if any character is in the "n" (NO) category
    for char in text:
        if char in unicode_nfc_quick_check["n"]:
            return True
    return False
```

### Important Considerations

- **Auto-generated**: This file is automatically generated - do not edit manually
- **Unicode Version**: Based on Unicode 13.0.0 - may need updates for newer Unicode versions
- **Memory Usage**: These tables can be large; consider lazy loading for memory-constrained applications
- **Character Ranges**: Range strings require proper parsing to be useful in practice

### Related Standards
- [Unicode Standard Annex #15](https://unicode.org/reports/tr15/) - Unicode Normalization Forms
- [RFC 3454](https://tools.ietf.org/html/rfc3454) - Preparation of Internationalized Strings

## Next Steps

To use this data effectively, you'll need to implement:
1. Unicode range string parser
2. Character-in-range lookup functions  
3. Quick check algorithms following Unicode TR15 specification