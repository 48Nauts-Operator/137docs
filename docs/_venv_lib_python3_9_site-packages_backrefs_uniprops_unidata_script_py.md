<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Unicode Scripts Module Documentation

## Overview

This module contains Unicode script properties data generated from Unicode version 13.0.0. It provides comprehensive mappings of Unicode scripts used for text processing, regular expressions, and character classification tasks.

## Purpose

The module enables:
- **Unicode script detection**: Identify which writing system a character belongs to
- **Text processing**: Filter or process text based on script types
- **Regular expression support**: Use script-based character classes in pattern matching
- **Internationalization**: Handle multilingual text correctly

## Data Structures

### `unicode_scripts: dict[str, str]`

A comprehensive dictionary mapping script names to their Unicode character ranges.

**Key Format:**
- `scriptname`: Characters belonging to that script
- `^scriptname`: Characters NOT belonging to that script (negated)

**Examples:**
```python
# Latin script characters
unicode_scripts["latin"]  # Contains A-Z, a-z, and extended Latin

# Non-Arabic characters  
unicode_scripts["^arabic"]  # All characters except Arabic script
```

### `ascii_scripts: dict[str, str]`

A simplified version containing only ASCII-range character mappings for performance optimization.

**Key differences from `unicode_scripts`:**
- Only covers ASCII characters (0x00-0x7F)
- Faster lookups for ASCII-only text
- Empty strings for scripts with no ASCII representation

## Important Scripts

### Major Writing Systems

- **`latin`**: Western alphabets (A-Z, a-z, accented characters)
- **`arabic`**: Arabic, Persian, Urdu scripts
- **`han`**: Chinese characters (Traditional and Simplified)
- **`hiragana`** / **`katakana`**: Japanese syllabaries
- **`hangul`**: Korean script
- **`cyrillic`**: Russian, Bulgarian, Serbian scripts
- **`devanagari`**: Hindi, Sanskrit, Marathi
- **`greek`**: Greek alphabet

### Special Categories

- **`common`**: Punctuation, numbers, symbols shared across scripts
- **`inherited`**: Combining marks, diacritics that inherit script properties
- **`unknown`**: Unassigned or private-use characters

## Usage Examples

### Script Detection
```python
def detect_script(char):
    """Detect the script of a character"""
    codepoint = ord(char)
    for script, ranges in unicode_scripts.items():
        if script.startswith('^'):
            continue
        # Check if character falls in script ranges
        # (Implementation would parse range strings)
    return "unknown"
```

### Text Filtering
```python
def filter_by_script(text, script_name):
    """Filter text to only include characters from specified script"""
    if script_name in unicode_scripts:
        ranges = unicode_scripts[script_name]
        # Filter logic here
    return filtered_text
```

### ASCII-Only Processing
```python
def is_ascii_latin(char):
    """Check if ASCII character is Latin script"""
    if ord(char) > 127:
        return False
    return char in parse_ranges(ascii_scripts["latin"])
```

## Range Format

Character ranges are encoded as Unicode escape sequences:
- `\x00-\x7F`: ASCII range (0-127)
- `\u0080-\u00FF`: Extended ASCII (128-255)  
- `\U00010000-\U0010FFFF`: Supplementary planes

## Important Notes

### Performance Considerations
- Use `ascii_scripts` for ASCII-only text processing
- `unicode_scripts` contains full Unicode coverage but requires more memory
- Consider caching parsed ranges for repeated operations

### Version Compatibility
- Data is from Unicode 13.0.0
- Newer Unicode versions may have additional scripts or modified ranges
- Always specify Unicode version when processing historical data

### Limitations
- Range strings need parsing before use in character matching
- Some scripts may overlap (e.g., punctuation in multiple scripts)
- Complex scripts may require additional shaping/rendering logic

## Suggestions

### For Library Developers
1. **Parse ranges once**: Convert string ranges to efficient lookup structures
2. **Cache results**: Script detection can be expensive for large texts
3. **Handle edge cases**: Consider how to handle characters in multiple scripts

### For Application Developers
1. **Choose appropriate dataset**: Use `ascii_scripts` when possible for performance
2. **Validate input**: Check Unicode version compatibility
3. **Test thoroughly**: Include mixed-script text in test cases

### Example Integration
```python
import re

def create_script_regex(script_name):
    """Create regex pattern for script matching"""
    if script_name in unicode_scripts:
        ranges = unicode_scripts[script_name]
        return f"[{ranges}]"
    return None

# Usage
latin_pattern = create_script_regex("latin")
text_has_latin = bool(re.search(latin_pattern, text))
```

This module provides the foundation for robust Unicode-aware text processing across multiple writing systems and languages.