<!-- Auto-generated by Claude on 2025-06-02 06:15 -->

# Python Date/Time String Parser Documentation

## Overview

This module provides a generic and forgiving date/time string parser that can handle most known date and time formats. It attempts to parse ambiguous dates by applying sensible defaults and fallback rules.

## Purpose

The module's main purpose is to:
- Parse various date/time string formats into Python `datetime` objects
- Handle ambiguous or incomplete date/time information gracefully
- Support timezone parsing and conversion
- Provide fuzzy parsing capabilities for natural language date strings

## Key Components

### Main Functions

#### `parse(timestr, parserinfo=None, **kwargs)`

The primary entry point for parsing date/time strings.

**Parameters:**
- `timestr`: String containing date/time information
- `parserinfo`: Optional `parserinfo` object for customization
- `**kwargs`: Additional parsing options

**Key Options:**
- `default`: Default datetime object for missing elements
- `dayfirst`: Whether to interpret first value as day in ambiguous dates
- `yearfirst`: Whether to interpret first value as year in ambiguous dates
- `fuzzy`: Enable fuzzy parsing for natural language strings
- `ignoretz`: Ignore timezone information
- `tzinfos`: Custom timezone mappings

**Example:**
```python
from dateutil.parser import parse

# Basic parsing
dt = parse("2023-12-25 14:30:00")

# Fuzzy parsing
dt = parse("Today is January 1, 2047 at 8:21:00AM", fuzzy=True)

# With timezone info
tzinfos = {"BRST": -7200}
dt = parse("2012-01-19 17:21:00 BRST", tzinfos=tzinfos)
```

### Core Classes

#### `parserinfo`

Configuration class that defines acceptable inputs and parsing behavior.

**Key attributes:**
- `WEEKDAYS`: List of weekday names and abbreviations
- `MONTHS`: List of month names and abbreviations  
- `HMS`: Hour/minute/second indicators
- `AMPM`: AM/PM indicators
- `UTCZONE`: UTC timezone identifiers

**Methods:**
- `weekday(name)`: Get weekday number from name
- `month(name)`: Get month number from name
- `convertyear(year)`: Convert 2-digit years to 4-digit

#### `parser`

The main parsing engine that processes tokenized date/time strings.

**Key methods:**
- `parse(timestr, **kwargs)`: Main parsing method
- `_parse(timestr, **kwargs)`: Internal parsing logic
- `_build_naive(res, default)`: Construct naive datetime
- `_build_tzaware(naive, res, tzinfos)`: Add timezone information

#### `_timelex`

Lexical analyzer that breaks date/time strings into tokens.

**Methods:**
- `get_token()`: Extract next token from input stream
- `split(s)`: Split string into list of tokens

### Helper Classes

#### `_ymd`

Specialized list for handling year/month/day values with ambiguity resolution.

**Key features:**
- Tracks which positions contain year, month, or day values
- Resolves ambiguous 3-integer dates based on `yearfirst`/`dayfirst` settings
- Handles century specification detection

#### `ParserError`

Custom exception for parsing failures.

```python
class ParserError(ValueError):
    """Raised for invalid or unknown string formats"""
```

## Parsing Rules and Behavior

### Default Value Handling

When date/time elements are missing:
- Missing elements taken from `default` parameter
- If no `default` provided, uses current date with time set to 00:00:00
- Day values that exceed month limits fall back to end of month

### Ambiguous Date Resolution

For 3-integer dates (e.g., "01/05/09"):
- `yearfirst=True`: First number is year (YMD or YDM)
- `dayfirst=True`: First number is day (DMY), unless `yearfirst=True`
- Default: First number is month (MDY)

### Time Parsing

- Supports 12-hour (with AM/PM) and 24-hour formats
- Handles various separators: colons, spaces, letters (h/m/s)
- Fractional seconds supported with decimal or comma separators

### Timezone Handling

- Named timezones (UTC, GMT, EST, etc.)
- Numeric offsets (+0500, -03:00)
- Custom timezone mappings via `tzinfos` parameter

## Usage Examples

```python
from dateutil.parser import parse, parserinfo

# Basic usage
dt = parse("2023-12-25")
dt = parse("Dec 25, 2023 2:30 PM")

# Custom parser info
class CustomParserInfo(parserinfo):
    MONTHS = [("jan", "january"), ("fev", "fevereiro")]  # Portuguese months

parser_pt = parser(CustomParserInfo())
dt = parser_pt.parse("25 fev 2023")

# Fuzzy parsing with tokens
dt, tokens = parse("Meeting on Jan 15, 2024 at 3pm", fuzzy_with_tokens=True)
print(tokens)  # ('Meeting on ', ', at ')
```

## Notes and Recommendations

### Performance Considerations
- Create custom `parserinfo` objects for repeated parsing with same locale
- Use specific format parsing libraries for high-volume, uniform data

### Error Handling
- Always wrap `parse()` calls in try/except blocks
- `ParserError` is raised for unparseable strings
- `TypeError` raised for invalid input types

### Timezone Warnings
- Unknown timezone names trigger `UnknownTimezoneWarning`
- Provide `tzinfos` mapping for custom timezone handling
- Consider using `ignoretz=True` for timezone-naive applications

### Fuzzy Parsing Caveats
- May produce false positives with natural language text
- Use judiciously and validate results
- Consider `fuzzy_with_tokens=True` to inspect ignored text

## Dependencies

- `datetime`: Core datetime functionality
- `dateutil.tz`: Timezone handling
- `dateutil.relativedelta`: Date arithmetic
- `six`: Python 2/3 compatibility
- `decimal`: Precise numeric parsing