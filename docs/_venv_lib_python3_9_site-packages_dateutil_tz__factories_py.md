<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Timezone Factory Metaclasses Documentation

## Overview

This Python module provides metaclass implementations for creating and managing timezone objects with different caching strategies. It's designed to optimize memory usage and performance when working with timezone instances by implementing singleton patterns and intelligent caching mechanisms.

## Purpose

The module serves as a foundation for timezone class creation with the following objectives:
- **Memory optimization**: Prevent duplicate timezone instances through caching
- **Performance enhancement**: Reuse existing instances instead of creating new ones
- **Thread safety**: Ensure safe concurrent access to cached instances
- **Flexible instantiation**: Support both cached and fresh instance creation

## Classes

### `_TzSingleton`

A metaclass that implements the singleton pattern for timezone classes.

```python
class _TzSingleton(type):
    def __init__(cls, *args, **kwargs):
        cls.__instance = None
        super(_TzSingleton, cls).__init__(*args, **kwargs)

    def __call__(cls):
        if cls.__instance is None:
            cls.__instance = super(_TzSingleton, cls).__call__()
        return cls.__instance
```

**Features:**
- Ensures only one instance of a timezone class exists
- Lazy initialization - instance created only when first accessed
- Suitable for timezone classes that don't require parameters

### `_TzFactory`

A base metaclass that provides an alternative constructor for creating fresh instances.

```python
class _TzFactory(type):
    def instance(cls, *args, **kwargs):
        """Alternate constructor that returns a fresh instance"""
        return type.__call__(cls, *args, **kwargs)
```

**Features:**
- Base class for more complex factory patterns
- `instance()` method bypasses caching mechanisms
- Allows creation of fresh instances when needed

### `_TzOffsetFactory`

A sophisticated factory metaclass for timezone classes that use offset-based identification.

**Key Features:**
- **Dual-cache system**: Combines weak references with a strong cache
- **Thread-safe operations**: Uses locks to prevent race conditions
- **LRU-style caching**: Maintains most recently used instances
- **Flexible key handling**: Supports both `timedelta` and numeric offsets

**Cache Configuration:**
- Strong cache size: 8 instances (configurable via `__strong_cache_size`)
- Weak cache: Unlimited, automatically cleaned up by garbage collector

**Parameters:**
- `name`: Timezone identifier
- `offset`: Either a `timedelta` object or numeric offset value

### `_TzStrFactory`

A factory metaclass for timezone classes that use string-based identification.

**Key Features:**
- Similar caching strategy to `_TzOffsetFactory`
- Optimized for string-based timezone definitions
- Support for POSIX offset interpretation

**Parameters:**
- `s`: String representation of the timezone
- `posix_offset`: Boolean flag for POSIX offset interpretation (default: `False`)

## Caching Strategy

Both `_TzOffsetFactory` and `_TzStrFactory` implement a two-tier caching system:

### Weak Cache (`weakref.WeakValueDictionary`)
- Stores all created instances
- Automatically removes instances when no strong references exist
- Prevents memory leaks from long-lived caches

### Strong Cache (`OrderedDict`)
- Maintains strong references to recently used instances
- Limited size (default: 8 instances)
- Implements LRU (Least Recently Used) eviction policy

## Thread Safety

Both factory classes include thread synchronization:

```python
cls._cache_lock = _thread.allocate_lock()

# Usage in critical sections
with cls._cache_lock:
    # Cache operations
```

> **Note**: The comment indicates this locking may not be necessary in Python 3 (see GH issue #901), but it's maintained for compatibility and safety.

## Usage Examples

```python
# Using _TzSingleton
class UTCTimezone(metaclass=_TzSingleton):
    pass

utc1 = UTCTimezone()
utc2 = UTCTimezone()
# utc1 and utc2 are the same instance

# Using _TzOffsetFactory
class OffsetTimezone(metaclass=_TzOffsetFactory):
    def __init__(self, name, offset):
        self.name = name
        self.offset = offset

tz1 = OffsetTimezone("EST", timedelta(hours=-5))
tz2 = OffsetTimezone("EST", timedelta(hours=-5))
# tz1 and tz2 are the same cached instance
```

## Dependencies

- `datetime.timedelta`: For time offset handling
- `weakref`: For weak reference caching
- `collections.OrderedDict`: For ordered strong cache implementation
- `six.moves._thread`: For cross-Python version thread support

## Recommendations

1. **Choose the right metaclass**: 
   - Use `_TzSingleton` for parameterless timezone classes
   - Use `_TzOffsetFactory` for offset-based timezones
   - Use `_TzStrFactory` for string-defined timezones

2. **Memory considerations**: The caching system is designed to balance memory usage with performance. Adjust `__strong_cache_size` if needed.

3. **Thread safety**: While locks are implemented, consider the threading requirements of your specific use case.

4. **Fresh instances**: Use the `instance()` method when you specifically need a new object that bypasses caching.