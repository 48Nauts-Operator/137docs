<!-- Auto-generated by Claude on 2025-06-02 06:15 -->

# Timezone Factory Metaclasses Documentation

## Overview

This file implements a collection of metaclasses designed to manage timezone object creation and caching. The primary purpose is to provide efficient instance management for timezone objects through singleton patterns and caching mechanisms, reducing memory usage and improving performance when working with timezone data.

## Purpose

The file provides three main metaclass patterns:
- **Singleton Pattern**: Ensures only one instance of a timezone class exists
- **Factory Pattern**: Creates fresh instances with caching capabilities
- **Specialized Factories**: Handle specific timezone types (offset-based and string-based)

## Classes

### `_TzSingleton`

A metaclass that implements the singleton pattern for timezone classes.

```python
class _TzSingleton(type):
    def __init__(cls, *args, **kwargs):
        cls.__instance = None
        super(_TzSingleton, cls).__init__(*args, **kwargs)

    def __call__(cls):
        if cls.__instance is None:
            cls.__instance = super(_TzSingleton, cls).__call__()
        return cls.__instance
```

**Key Features:**
- Ensures only one instance of the timezone class exists
- Lazy initialization - instance created only when first requested
- Thread-safe singleton implementation

### `_TzFactory`

Base factory metaclass that provides an alternate constructor for creating fresh instances.

```python
class _TzFactory(type):
    def instance(cls, *args, **kwargs):
        """Alternate constructor that returns a fresh instance"""
        return type.__call__(cls, *args, **kwargs)
```

**Key Features:**
- Provides `instance()` method to bypass caching when needed
- Base class for specialized factory implementations

### `_TzOffsetFactory`

Specialized factory for timezone objects based on name and offset parameters.

**Key Features:**
- **Weak Reference Caching**: Uses `WeakValueDictionary` for automatic garbage collection
- **Strong Cache**: Maintains `OrderedDict` with LRU-style eviction
- **Thread Safety**: Uses thread locks for cache operations
- **Flexible Key Generation**: Handles both `timedelta` objects and numeric offsets

**Cache Configuration:**
- Strong cache size limit: 8 items
- LRU eviction policy for strong cache
- Automatic cleanup via weak references

**Parameters:**
- `name`: Timezone name identifier
- `offset`: Time offset (accepts `timedelta` or numeric values)

### `_TzStrFactory`

Specialized factory for timezone objects created from string representations.

**Key Features:**
- Similar caching mechanism to `_TzOffsetFactory`
- String-based timezone parsing support
- POSIX offset format support

**Parameters:**
- `s`: String representation of timezone
- `posix_offset`: Boolean flag for POSIX offset interpretation (default: False)

## Caching Strategy

Both specialized factories implement a two-tier caching system:

1. **Weak Cache** (`WeakValueDictionary`):
   - Automatically releases instances when no strong references exist
   - Prevents memory leaks
   - Primary storage for all created instances

2. **Strong Cache** (`OrderedDict`):
   - Keeps recently used instances alive
   - Limited size (8 items) with LRU eviction
   - Ensures frequently accessed timezones remain in memory

## Thread Safety

- All cache operations are protected by thread locks
- Note in code suggests lock may be unnecessary in Python 3 (see GH issue #901)
- Ensures safe concurrent access to cached instances

## Usage Notes

### Best Practices
- Use the factory metaclasses for timezone classes that will be frequently instantiated
- The caching mechanism is most beneficial for applications that create many timezone objects with repeated parameters
- Consider using `instance()` method when you specifically need a fresh object

### Performance Considerations
- Strong cache size is limited to 8 items - adjust `__strong_cache_size` if needed
- Weak references provide automatic memory management but may cause re-creation of infrequently used objects
- Thread locking may introduce slight overhead in highly concurrent scenarios

### Compatibility
- Uses `six.moves._thread` for Python 2/3 compatibility
- Thread locking behavior may differ between Python versions

## Dependencies

```python
from datetime import timedelta
import weakref
from collections import OrderedDict
from six.moves import _thread
```

- **datetime.timedelta**: For time offset calculations
- **weakref**: For automatic garbage collection of cached instances
- **collections.OrderedDict**: For LRU cache implementation
- **six.moves._thread**: For cross-version thread compatibility