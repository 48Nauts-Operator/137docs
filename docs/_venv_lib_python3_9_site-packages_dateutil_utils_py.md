<!-- Auto-generated by Claude on 2025-06-02 06:15 -->

# dateutil.utils Module Documentation

## Overview

The `dateutil.utils` module provides general convenience and utility functions for working with datetime objects in Python. This module simplifies common datetime operations and offers helpful utilities for timezone handling and datetime comparisons.

**Version:** Added in dateutil 2.7.0

## Functions

### `today(tzinfo=None)`

Returns a datetime object representing the current day at midnight (00:00:00).

**Parameters:**
- `tzinfo` (optional): The timezone to attach to the datetime object. This timezone is also used to determine what constitutes the "current day"

**Returns:**
- `datetime.datetime`: A datetime object representing today at midnight

**Example:**
```python
from dateutil.utils import today
from dateutil.tz import tzlocal

# Get today at midnight in local timezone
today_local = today(tzlocal())

# Get today at midnight in UTC
today_utc = today()
```

---

### `default_tzinfo(dt, tzinfo)`

Assigns timezone information to naive datetime objects only. If the datetime object already has timezone information, it returns the datetime unchanged.

**Parameters:**
- `dt` (`datetime.datetime`): The datetime object to potentially modify
- `tzinfo` (`datetime.tzinfo`): The timezone to assign if the datetime is naive

**Returns:**
- `datetime.datetime`: An aware datetime object

**Use Cases:**
- Parsing datetime strings that may or may not include timezone information
- Ensuring datetime objects have timezone information for consistent operations

**Example:**
```python
from dateutil.tz import tzoffset
from dateutil.parser import parse
from dateutil.utils import default_tzinfo

dflt_tz = tzoffset("EST", -18000)

# Datetime with timezone - returned unchanged
aware_dt = default_tzinfo(parse('2014-01-01 12:30 UTC'), dflt_tz)
# Result: 2014-01-01 12:30:00+00:00

# Naive datetime - gets default timezone applied
naive_dt = default_tzinfo(parse('2014-01-01 12:30'), dflt_tz)
# Result: 2014-01-01 12:30:00-05:00
```

---

### `within_delta(dt1, dt2, delta)`

Compares two datetime objects to determine if they are within a specified time difference of each other. This is useful for comparing datetimes that may have negligible differences but should be considered equal.

**Parameters:**
- `dt1` (`datetime.datetime`): First datetime object
- `dt2` (`datetime.datetime`): Second datetime object  
- `delta` (`timedelta`): Maximum allowed difference between the datetimes

**Returns:**
- `bool`: `True` if the absolute difference between dt1 and dt2 is within the specified delta

**Example:**
```python
from datetime import datetime, timedelta
from dateutil.utils import within_delta

dt1 = datetime(2023, 1, 1, 12, 0, 0)
dt2 = datetime(2023, 1, 1, 12, 0, 5)  # 5 seconds later

# Check if within 10 seconds
is_close = within_delta(dt1, dt2, timedelta(seconds=10))  # True

# Check if within 3 seconds  
is_very_close = within_delta(dt1, dt2, timedelta(seconds=3))  # False
```

## Notes and Suggestions

### Best Practices

- **Use `today()` for date boundaries**: When you need to work with date boundaries (start/end of day), `today()` provides a clean way to get midnight timestamps
- **Handle timezone-aware operations**: Use `default_tzinfo()` when parsing user input or external data that may inconsistently include timezone information
- **Fuzzy datetime comparisons**: Use `within_delta()` for comparing datetimes from different sources that might have slight timing differences due to processing delays

### Important Considerations

- The `within_delta()` function uses absolute values for the delta, so negative timedelta values will be converted to positive
- When using `today()` with a timezone, the "current day" is determined in that timezone, which may differ from UTC
- The `default_tzinfo()` function only modifies naive datetime objects - aware datetimes are returned unchanged

### Dependencies

This module depends on:
- Python's built-in `datetime` module
- The broader `dateutil` package ecosystem