<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# dateutil.utils Module Documentation

This module provides general convenience and utility functions for working with datetime objects in Python. It offers helpful functions for handling timezone-aware datetimes, comparing dates within a tolerance, and creating standardized datetime representations.

**Version Added:** 2.7.0

## Module Overview

The `dateutil.utils` module contains utility functions that simplify common datetime operations, particularly when dealing with:
- Timezone-aware and timezone-naive datetime objects
- Creating standardized datetime representations
- Comparing datetimes with tolerance for small differences

## Functions

### `today(tzinfo=None)`

Returns a datetime object representing the current day at midnight (00:00:00).

**Parameters:**
- `tzinfo` (optional): The timezone to attach to the datetime. Also used to determine what constitutes the "current day"

**Returns:**
- `datetime.datetime`: A datetime object representing today at midnight

**Usage Example:**
```python
from dateutil.utils import today
from dateutil.tz import tzlocal

# Get today at midnight in local timezone
today_local = today(tzlocal())

# Get today at midnight in UTC
today_utc = today()
```

**Notes:**
- If no timezone is provided, the result will be timezone-naive
- The timezone parameter affects both the determination of "today" and the timezone of the returned datetime

---

### `default_tzinfo(dt, tzinfo)`

Assigns a timezone to a datetime object **only if** the datetime is naive (has no timezone information). If the datetime already has timezone information, it is returned unchanged.

**Parameters:**
- `dt` (`datetime.datetime`): The datetime object to potentially modify
- `tzinfo` (`datetime.tzinfo`): The timezone to assign if the datetime is naive

**Returns:**
- `datetime.datetime`: An aware datetime object

**Usage Example:**
```python
from dateutil.tz import tzoffset
from dateutil.parser import parse
from dateutil.utils import default_tzinfo

dflt_tz = tzoffset("EST", -18000)

# Already has timezone - returned unchanged
aware_dt = parse('2014-01-01 12:30 UTC')
result1 = default_tzinfo(aware_dt, dflt_tz)
# Result: 2014-01-01 12:30:00+00:00

# Naive datetime - gets the default timezone
naive_dt = parse('2014-01-01 12:30')
result2 = default_tzinfo(naive_dt, dflt_tz)
# Result: 2014-01-01 12:30:00-05:00
```

**Use Cases:**
- Parsing datetime strings that may or may not include timezone information
- Ensuring all datetimes in your application are timezone-aware
- Providing fallback timezone information

---

### `within_delta(dt1, dt2, delta)`

Determines whether two datetime objects are within a specified time difference of each other. Useful for comparing datetimes that may have negligible differences but should be considered equal.

**Parameters:**
- `dt1` (`datetime.datetime`): First datetime object
- `dt2` (`datetime.datetime`): Second datetime object  
- `delta` (`timedelta`): Maximum allowed difference between the datetimes

**Returns:**
- `bool`: True if the absolute difference between dt1 and dt2 is less than or equal to delta

**Usage Example:**
```python
from datetime import datetime, timedelta
from dateutil.utils import within_delta

dt1 = datetime(2023, 1, 1, 12, 0, 0)
dt2 = datetime(2023, 1, 1, 12, 0, 5)  # 5 seconds later
tolerance = timedelta(seconds=10)

if within_delta(dt1, dt2, tolerance):
    print("Datetimes are close enough")
```

**Notes:**
- The function uses the absolute value of delta, so negative deltas are treated as positive
- Useful for dealing with system clock differences, network latency, or processing delays
- The comparison is inclusive (â‰¤) of the delta boundary

## Import Information

```python
from dateutil.utils import today, default_tzinfo, within_delta
```

## Dependencies

This module requires:
- Python's built-in `datetime` module
- Compatible with Python 2.7+ (uses `unicode_literals` for Python 2/3 compatibility)

## Best Practices

- Use `default_tzinfo()` when parsing user input that may or may not include timezone information
- Use `today()` for consistent "start of day" datetime representations
- Use `within_delta()` for robust datetime comparisons in distributed systems or when precision requirements are relaxed