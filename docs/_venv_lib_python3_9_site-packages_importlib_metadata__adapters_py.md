<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Message Module Documentation

## Overview

This module provides specialized classes for handling Python package metadata messages that extend the standard `email.message` functionality. It's designed to work with metadata formats commonly found in Python packaging (following PEP 566 specifications).

## Purpose

The module addresses specific challenges when working with package metadata:
- Handling multi-line values with proper indentation
- Converting metadata to JSON format
- Managing keys that can appear multiple times
- Proper formatting and rendering of metadata fields

## Classes

### RawPolicy

```python
class RawPolicy(email.policy.EmailPolicy)
```

A custom email policy class that handles the formatting of header fields with proper indentation.

**Key Method:**
- `fold(name, value)`: Formats header fields with 8-space indentation for continuation lines

### Message

```python
class Message(email.message.Message)
```

A specialized subclass of `email.message.Message` designed to handle package metadata naturally.

#### Key Features

- **Multi-line Value Support**: Properly handles metadata values that span multiple lines
- **Payload-to-Description Conversion**: Automatically converts message payload to a 'Description' field
- **JSON Serialization**: Provides JSON-compatible output per PEP 566
- **Multiple-Use Keys**: Supports metadata keys that can appear multiple times

#### Important Attributes

- **`multiple_use_keys`**: A set of metadata keys that may appear multiple times according to PEP 566:
  - `Classifier`
  - `Obsoletes-Dist`
  - `Platform`
  - `Project-URL`
  - `Provides-Dist`
  - `Provides-Extra`
  - `Requires-Dist`
  - `Requires-External`
  - `Supported-Platform`
  - `Dynamic`

#### Key Methods

##### `__new__(cls, orig: email.message.Message)`
Creates a new Message instance from an existing email.message.Message object.

##### `__getitem__(item)`
```python
def __getitem__(self, item):
```
Overrides parent behavior to raise `KeyError` for missing keys instead of returning `None`.

##### `_repair_headers()`
```python
def _repair_headers(self):
```
- Corrects RFC822 indentation in header values
- Moves payload content to a 'Description' header
- Returns properly formatted headers list

##### `as_string()`
```python
def as_string(self):
```
Returns string representation using the custom `RawPolicy` for proper formatting.

##### `json` (property)
```python
@property
def json(self):
```
Converts the metadata to a JSON-compatible dictionary format following PEP 566 specifications.

**Transformations applied:**
- Keys with multiple values become lists
- 'Keywords' field is split on whitespace
- Keys are converted to lowercase with hyphens replaced by underscores

## Usage Example

```python
import email
from importlib_metadata import Message

# Parse metadata from string
msg_text = """
Name: MyPackage
Version: 1.0.0
License: MIT License
        Extended license text

Description content here
"""

original_msg = email.message_from_string(msg_text)
msg = Message(original_msg)

# Access metadata
print(msg['Name'])  # "MyPackage"
print(msg['Description'])  # Description from payload

# Convert to JSON
json_data = msg.json
```

## Notes and Suggestions

### Best Practices
- Use this class when working with Python package metadata that may contain multi-line values
- Leverage the `json` property for converting metadata to structured data formats
- Be aware that missing keys will raise `KeyError` (different from standard email.message behavior)

### Considerations
- The 8-space indentation is hardcoded and follows RFC822 conventions
- The class assumes specific metadata field names as defined in PEP 566
- Multi-line values are automatically dedented for proper formatting

### Integration
This module is typically used as part of the `importlib_metadata` package for reading Python package metadata from distribution files.