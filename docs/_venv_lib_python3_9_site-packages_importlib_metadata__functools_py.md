<!-- Auto-generated by Claude on 2025-06-02 06:15 -->

# Utility Functions Documentation

This Python module provides two utility decorators that enhance function behavior: `method_cache` for instance-based method caching and `pass_none` for conditional function execution.

## Overview

The module contains utility functions adapted from `jaraco.functools 3.3` that provide:
- Instance-level method caching that avoids cache pollution between different object instances
- Conditional function execution based on null parameter checking

## Functions

### `method_cache(method, cache_wrapper=None)`

A decorator that implements instance-level caching for class methods, storing cache data within individual object instances rather than globally.

#### Purpose
- Provides method-level caching similar to `functools.lru_cache()` but scoped to individual instances
- Prevents cache pollution between different instances of the same class
- Automatically cleans up cached values when instances are deleted

#### Parameters
- `method`: The method to be cached
- `cache_wrapper` (optional): Custom cache implementation (defaults to `functools.lru_cache()`)

#### Key Features
- **Instance isolation**: Each object instance maintains its own cache
- **Memory management**: Cache is automatically cleaned up with instance deletion
- **Cache control**: Provides `.cache_clear()` method for manual cache clearing
- **Drop-in replacement**: Behaves like `lru_cache` but with instance-scoped storage

#### Usage Example
```python
class MyClass:
    calls = 0
    
    @method_cache
    def expensive_method(self, value):
        self.calls += 1
        return value * 2

# Each instance has its own cache
obj1 = MyClass()
obj2 = MyClass()

obj1.expensive_method(5)  # Cached in obj1
obj2.expensive_method(5)  # Cached separately in obj2

# Clear cache for specific instance
obj1.expensive_method.cache_clear()
```

#### Important Notes
- ⚠️ **Warning**: Do not apply additional decorators (like `@property`) after `@method_cache` as this changes function semantics
- The cache is created lazily on first method call
- Cache clearing is supported even before the cache is created

### `pass_none(func)`

A decorator that prevents function execution when the first parameter is `None`.

#### Purpose
- Provides null-safe function execution
- Useful for optional processing where `None` values should be ignored
- Reduces boilerplate null-checking code

#### Parameters
- `func`: The function to wrap with null-checking behavior

#### Usage Example
```python
# Create a null-safe version of print
safe_print = pass_none(print)

safe_print("Hello World")  # Output: Hello World
safe_print(None)           # No output, function not called

# Useful for optional processing
@pass_none
def process_data(data):
    return data.upper()

result1 = process_data("hello")  # Returns "HELLO"
result2 = process_data(None)     # Returns None, no processing
```

## Dependencies

- `functools`: For wrapping functionality and LRU cache implementation
- `types`: For creating bound method instances

## Best Practices

### For `method_cache`:
- Use when you need instance-specific caching that won't interfere between objects
- Consider memory usage if instances are long-lived with large caches
- Prefer over global `lru_cache` when working with multiple instances

### For `pass_none`:
- Ideal for functions that should gracefully handle `None` inputs
- Useful in data processing pipelines where `None` represents "no data"
- Consider the expected return value when the first parameter is `None` (returns `None`)

## Notes

Both functions are adapted from `jaraco.functools 3.3`, providing stable and well-tested functionality for common Python programming patterns.