<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Utility Functions Documentation

This Python module provides utility decorators and function wrappers to enhance method caching and conditional function execution. The code is derived from `jaraco.functools` version 3.3.

## Overview

The module contains two main utility functions:
- `method_cache`: A decorator for instance-level method caching
- `pass_none`: A decorator that prevents function execution when the first parameter is `None`

## Functions

### `method_cache(method, cache_wrapper=None)`

A decorator that implements instance-level caching for methods, storing cache data within object instances rather than globally.

#### Purpose
- Provides method-level caching similar to `functools.lru_cache()` but with instance-specific cache storage
- Prevents cache collisions between different object instances
- Automatically cleans up cached values when instances are deleted

#### Parameters
- `method`: The method to be cached
- `cache_wrapper` (optional): Custom cache wrapper function (defaults to `functools.lru_cache()`)

#### Key Features
- **Instance-specific caching**: Each object instance maintains its own cache
- **Automatic cleanup**: Cached values are removed when the instance is deleted
- **Cache clearing**: Supports `.cache_clear()` method for manual cache management
- **No cross-instance interference**: Values cached in one instance don't affect others

#### Usage Example
```python
class MyClass:
    calls = 0
    
    @method_cache
    def expensive_method(self, value):
        self.calls += 1
        return value * 2

# Each instance has its own cache
obj1 = MyClass()
obj2 = MyClass()

# Cache is maintained per instance
result1 = obj1.expensive_method(5)  # Computed and cached
result2 = obj1.expensive_method(5)  # Retrieved from cache

# Clear cache when needed
obj1.expensive_method.cache_clear()
```

#### Important Notes
- ⚠️ **Do not wrap with other decorators** like `@property` after applying `@method_cache`
- The decorator replaces the method with a cached, bound method on first call
- Cache clearing is supported even before the cache is created

### `pass_none(func)`

A decorator that prevents function execution when the first parameter is `None`.

#### Purpose
- Provides a clean way to handle `None` values without explicit null checks
- Useful for optional processing scenarios
- Reduces boilerplate code for null parameter validation

#### Parameters
- `func`: The function to wrap

#### Usage Example
```python
@pass_none
def process_text(text):
    return text.upper()

process_text("hello")  # Returns "HELLO"
process_text(None)     # Returns None (function not executed)
```

## Implementation Details

### Technical Notes
- Uses `functools.wraps()` to preserve function metadata
- `method_cache` utilizes `types.MethodType` for proper method binding
- Both functions leverage Python's decorator pattern for clean integration

### Dependencies
```python
import functools
import types
```

## Best Practices

1. **For `method_cache`**:
   - Use for expensive computations that benefit from caching
   - Be mindful of memory usage with large cached datasets
   - Consider custom cache wrappers for specific size limitations

2. **For `pass_none`**:
   - Ideal for optional data processing pipelines
   - Use when `None` should be treated as a no-op rather than an error

## References
- Original implementation from `jaraco.functools` 3.3
- Additional context: [ActiveState Recipe 577452](http://code.activestate.com/recipes/577452-a-memoize-decorator-for-instance-methods/)