<!-- Auto-generated by Claude on 2025-06-02 06:15 -->

# Iterable Utilities Module

This Python module provides utility functions and classes for working with iterables. It contains helper functions for deduplication, type normalization, and advanced grouping operations.

## Purpose

The module serves as a collection of iterator utilities that extend Python's built-in iteration capabilities:
- Remove duplicates while preserving order
- Normalize objects to always be iterable
- Group iterable items into buckets based on key functions

## Dependencies

```python
from collections import defaultdict, deque
from itertools import filterfalse
```

## Functions

### `unique_everseen(iterable, key=None)`

Returns unique elements from an iterable while preserving their original order.

**Parameters:**
- `iterable`: The input iterable to process
- `key` (optional): A function to compute a comparison key for each element

**Returns:** Generator yielding unique elements

**Examples:**
```python
# Basic usage
list(unique_everseen('AAAABBBCCDAABBB'))  # ['A', 'B', 'C', 'D']

# With key function
list(unique_everseen('ABBCcAD', str.lower))  # ['A', 'B', 'C', 'D']
```

**Performance Notes:**
- Uses a set for O(1) lookup performance
- Optimizes the common case where no key function is provided
- Memory usage grows with the number of unique elements seen

### `always_iterable(obj, base_type=(str, bytes))`

Ensures that an object is always iterable, with special handling for common edge cases.

**Parameters:**
- `obj`: The object to make iterable
- `base_type` (optional): Types that should be treated as single units rather than iterables

**Returns:** Iterator over the object's items

**Behavior:**
- If `obj` is `None` → returns empty iterator
- If `obj` is a `base_type` → returns single-item iterator containing `obj`
- If `obj` is iterable → returns iterator over its items
- If `obj` is not iterable → returns single-item iterator containing `obj`

**Examples:**
```python
list(always_iterable([1, 2, 3]))     # [1, 2, 3]
list(always_iterable(1))             # [1]
list(always_iterable(None))          # []
list(always_iterable('foo'))         # ['foo'] (string treated as unit)
list(always_iterable('foo', base_type=None))  # ['f', 'o', 'o']
```

## Classes

### `bucket`

A sophisticated class that groups items from an iterable into separate "buckets" based on a key function.

#### Constructor

```python
bucket(iterable, key, validator=None)
```

**Parameters:**
- `iterable`: The source iterable to bucket
- `key`: Function that determines which bucket each item belongs to
- `validator` (optional): Function to validate bucket keys

#### Key Methods

- `__contains__(value)`: Check if a bucket exists and has items
- `__getitem__(value)`: Get an iterator for a specific bucket
- `__iter__()`: Iterate over all available bucket keys

#### Usage Example

```python
iterable = ['a1', 'b1', 'c1', 'a2', 'b2', 'c2', 'b3']
s = bucket(iterable, key=lambda x: x[0])  # Bucket by first character

# Get available buckets
sorted(list(s))  # ['a', 'b', 'c']

# Access specific buckets
list(s['a'])  # ['a1', 'a2']
list(s['b'])  # ['b1', 'b2', 'b3']
```

#### Advanced Usage with Validator

```python
from itertools import count
it = count(1, 2)  # Infinite odd numbers
key = lambda x: x % 10  # Bucket by last digit
validator = lambda x: x in {1, 3, 5, 7, 9}  # Only odd digits

s = bucket(it, key=key, validator=validator)
2 in s        # False (even digit not valid)
list(s[2])    # [] (empty, not exhausting infinite iterator)
```

## Important Notes

### Memory Considerations
- **`unique_everseen`**: Memory usage is O(n) where n is the number of unique elements
- **`bucket`**: Can cache significant amounts of data, especially with uneven key distributions

### Performance Tips
- Use `validator` parameter in `bucket` when working with infinite iterables
- The `bucket` class advances the source iterator lazily but caches all encountered items

### Attribution
- `always_iterable` is copied from more_itertools 8.8
- `bucket` is copied from more_itertools 10.3

## Suggestions for Use

1. **Use `unique_everseen`** when you need to deduplicate data while maintaining insertion order
2. **Use `always_iterable`** in functions that need to handle both single items and collections uniformly
3. **Use `bucket`** for complex grouping operations where you need random access to groups and lazy evaluation
4. **Be cautious with `bucket`** when using infinite iterables without a proper validator function