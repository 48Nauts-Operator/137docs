<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Iterator Utilities Documentation

## Overview

This Python module provides utility functions and classes for advanced iteration operations. It contains three main components that help with processing iterables in specialized ways:

- **Unique element extraction** with order preservation
- **Flexible iterable conversion** for handling various input types
- **Dynamic grouping/bucketing** of iterable elements

## Functions and Classes

### `unique_everseen(iterable, key=None)`

**Purpose**: Extract unique elements from an iterable while preserving their original order.

**Parameters**:
- `iterable`: The input sequence to process
- `key` (optional): Function to compute a comparison key for each element

**Returns**: Generator yielding unique elements

**Examples**:
```python
# Basic usage
list(unique_everseen('AAAABBBCCDAABBB'))
# Output: ['A', 'B', 'C', 'D']

# With key function
list(unique_everseen('ABBCcAD', str.lower))
# Output: ['A', 'B', 'C', 'D']
```

**Key Features**:
- Preserves original element order
- Memory efficient using generators
- Supports custom key functions for complex comparisons
- Uses `filterfalse` optimization when no key function is provided

---

### `always_iterable(obj, base_type=(str, bytes))`

**Purpose**: Normalize any object into an iterable, handling edge cases consistently.

**Parameters**:
- `obj`: The object to convert to an iterable
- `base_type`: Types that should be treated as single units rather than iterables

**Returns**: Iterator over the object's items

**Behavior**:
| Input Type | Output |
|------------|--------|
| `None` | Empty iterator |
| Iterable (except base_type) | Iterator over items |
| Non-iterable | Single-item iterator |
| base_type instances | Single-item iterator |

**Examples**:
```python
# Regular iterable
list(always_iterable([1, 2, 3]))  # [1, 2, 3]

# Non-iterable
list(always_iterable(42))  # [42]

# None handling
list(always_iterable(None))  # []

# String handling (treated as unit by default)
list(always_iterable('hello'))  # ['hello']

# Custom base_type
list(always_iterable({'a': 1}, base_type=dict))  # [{'a': 1}]
```

---

### `bucket` Class

**Purpose**: Dynamically group elements from an iterable into separate "buckets" based on a key function.

#### Constructor
```python
bucket(iterable, key, validator=None)
```

**Parameters**:
- `iterable`: Source iterable to bucket
- `key`: Function that determines which bucket each item belongs to
- `validator` (optional): Function to validate bucket keys

#### Methods and Operations

- **`__contains__(value)`**: Check if a bucket exists and has items
- **`__getitem__(value)`**: Get iterator for a specific bucket
- **`__iter__()`**: Iterate over all available bucket keys

**Examples**:
```python
# Basic bucketing
data = ['a1', 'b1', 'c1', 'a2', 'b2', 'c2', 'b3']
buckets = bucket(data, key=lambda x: x[0])

# Get available bucket keys
sorted(list(buckets))  # ['a', 'b', 'c']

# Access specific buckets
list(buckets['a'])  # ['a1', 'a2']
list(buckets['b'])  # ['b1', 'b2', 'b3']

# With validator for infinite sequences
from itertools import count
odd_numbers = count(1, 2)
buckets = bucket(
    odd_numbers, 
    key=lambda x: x % 10,
    validator=lambda x: x in {1, 3, 5, 7, 9}
)
```

#### Important Notes

- **Memory Usage**: Items are cached until consumed by bucket iterators
- **Lazy Evaluation**: Original iterable is consumed on-demand
- **Validator Benefits**: Prevents exhausting infinite iterables when accessing non-existent buckets
- **Order Preservation**: Items within each bucket maintain their original order

## Dependencies

The module imports from Python's standard library:
- `collections.defaultdict, deque`: For efficient caching and default value handling
- `itertools.filterfalse`: For optimized filtering operations

## Usage Recommendations

1. **Use `unique_everseen`** when you need to deduplicate while preserving order (unlike `set()`)
2. **Use `always_iterable`** in functions that should accept both single items and iterables
3. **Use `bucket`** for dynamic grouping when you don't know all group keys in advance
4. **Consider memory implications** when using `bucket` with large datasets
5. **Always use validators** with `bucket` when working with infinite iterables

## Attribution

- `always_iterable`: Copied from more-itertools 8.8
- `bucket`: Copied from more-itertools 10.3