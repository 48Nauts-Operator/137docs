<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Jinja2 Bytecode Cache System Documentation

## Overview

This module implements an optional bytecode cache system for Jinja2 templates. The primary purpose is to improve performance in applications with complex template situations where template compilation becomes a bottleneck.

**Key Benefits:**
- Reduces template compilation overhead
- Particularly useful for forking web applications initialized on first request
- Provides multiple storage backends (filesystem, memcached)

## Core Components

### Magic Bytes and Versioning

```python
bc_version = 5
bc_magic = b"j2" + pickle.dumps(bc_version, 2) + pickle.dumps((sys.version_info[0] << 24) | sys.version_info[1], 2)
```

- **Purpose**: Identifies Jinja bytecode cache files and ensures compatibility
- **Features**: 
  - Contains Python major/minor version info
  - Prevents loading incompatible bytecode after Python upgrades

## Classes

### `Bucket`

**Purpose**: Container for storing bytecode of a single template with automatic cache invalidation.

**Key Attributes:**
- `environment`: Reference to Jinja2 environment
- `key`: Unique identifier for the template
- `checksum`: Hash for cache invalidation
- `code`: Compiled bytecode (CodeType object)

**Important Methods:**

#### `load_bytecode(f: BinaryIO) -> None`
```python
def load_bytecode(self, f: t.BinaryIO) -> None:
    magic = f.read(len(bc_magic))
    if magic != bc_magic:
        self.reset()
        return
    # ... validation and loading logic
```
- Loads bytecode from file-like object
- Validates magic header and checksum
- Automatically resets on invalid/outdated cache

#### `write_bytecode(f: IO[bytes]) -> None`
- Serializes bytecode to file-like object
- Includes magic header and checksum

#### `bytecode_from_string(string: bytes) -> None`
- Convenience method to load from bytes

#### `bytecode_to_string() -> bytes`
- Convenience method to export as bytes

---

### `BytecodeCache` (Abstract Base Class)

**Purpose**: Base class for implementing custom bytecode caches.

**Abstract Methods to Override:**
- `load_bytecode(bucket: Bucket) -> None`
- `dump_bytecode(bucket: Bucket) -> None`

**Utility Methods:**

#### `get_cache_key(name: str, filename: Optional[str] = None) -> str`
```python
def get_cache_key(self, name: str, filename: t.Optional[t.Union[str]] = None) -> str:
    hash = sha1(name.encode("utf-8"))
    if filename is not None:
        hash.update(f"|{filename}".encode())
    return hash.hexdigest()
```
- Generates unique SHA1 hash for template identification

#### `get_source_checksum(source: str) -> str`
- Creates SHA1 checksum of template source for invalidation

**Example Implementation:**
```python
class MyCache(BytecodeCache):
    def __init__(self, directory):
        self.directory = directory

    def load_bytecode(self, bucket):
        filename = path.join(self.directory, bucket.key)
        if path.exists(filename):
            with open(filename, 'rb') as f:
                bucket.load_bytecode(f)

    def dump_bytecode(self, bucket):
        filename = path.join(self.directory, bucket.key)
        with open(filename, 'wb') as f:
            bucket.write_bytecode(f)
```

---

### `FileSystemBytecodeCache`

**Purpose**: Production-ready filesystem-based bytecode cache implementation.

**Constructor Parameters:**
- `directory`: Cache directory (auto-detected if None)
- `pattern`: Filename pattern (default: `"__jinja2_%s.cache"`)

**Key Features:**

#### Automatic Directory Selection
- **Windows**: Uses user's temp directory
- **Unix**: Creates secure user-specific directory in system temp
- **Security**: Ensures proper permissions (700) and ownership

#### Atomic File Operations
```python
def dump_bytecode(self, bucket: Bucket) -> None:
    # Write to temporary file, then rename
    f = tempfile.NamedTemporaryFile(...)
    # ... write operations
    os.replace(f.name, name)  # Atomic rename
```
- Uses temporary files with atomic rename
- Prevents corruption from concurrent access

#### Cache Management
```python
def clear(self) -> None:
    files = fnmatch.filter(os.listdir(self.directory), self.pattern % ("*",))
    for filename in files:
        try:
            remove(os.path.join(self.directory, filename))
        except OSError:
            pass  # Ignore errors during cleanup
```

**Usage Example:**
```python
cache = FileSystemBytecodeCache('/tmp/jinja_cache', '%s.cache')
```

---

### `MemcachedBytecodeCache`

**Purpose**: Memcached-based bytecode cache for distributed applications.

**Constructor Parameters:**
- `client`: Memcached client implementing minimal interface
- `prefix`: Key prefix (default: `"jinja2/bytecode/"`)
- `timeout`: Cache timeout in seconds
- `ignore_memcache_errors`: Whether to silently ignore cache errors

**Compatible Libraries:**
- [cachelib](https://github.com/pallets/cachelib)
- [python-memcached](https://pypi.org/project/python-memcached/)

**Required Client Interface:**
```python
class MinimalClientInterface:
    def get(self, key: str) -> bytes: ...
    def set(self, key: str, value: bytes, timeout: Optional[int] = None) -> None: ...
```

**Error Handling:**
- Gracefully handles memcache failures when `ignore_memcache_errors=True`
- Continues operation even if cache backend is unavailable

**Usage Example:**
```python
import memcache
client = memcache.Client(['127.0.0.1:11211'])
cache