<!-- Auto-generated by Claude on 2025-06-02 06:15 -->

# Jinja2 Bytecode Cache System

## Overview

This module implements an optional bytecode cache system for Jinja2 templates. The caching system is designed to improve performance in applications with complex template structures where template compilation becomes a bottleneck.

## Purpose

The bytecode cache system addresses performance issues in:
- Applications with many complex templates
- Forking web applications initialized on first request
- Situations where template compilation significantly slows down the application

## Key Components

### Constants and Magic Numbers

```python
bc_version = 5
bc_magic = b"j2" + pickle.dumps(bc_version, 2) + pickle.dumps((sys.version_info[0] << 24) | sys.version_info[1], 2)
```

- **`bc_version`**: Current bytecode cache version
- **`bc_magic`**: Magic bytes used to identify Jinja bytecode cache files and ensure Python version compatibility

## Classes

### `Bucket`

A container class that stores bytecode for a single template.

**Key Features:**
- Stores compiled bytecode with automatic checksum validation
- Handles cache invalidation automatically
- Provides serialization/deserialization methods

**Important Methods:**
- `reset()`: Clears the stored bytecode
- `load_bytecode(f)`: Loads bytecode from a file-like object
- `write_bytecode(f)`: Writes bytecode to a file-like object
- `bytecode_from_string(string)`: Loads bytecode from bytes
- `bytecode_to_string()`: Returns bytecode as bytes

**Usage Example:**
```python
bucket = Bucket(environment, "template_key", "checksum")
with open("cache_file.bin", "rb") as f:
    bucket.load_bytecode(f)
```

### `BytecodeCache` (Abstract Base Class)

The base class for implementing custom bytecode cache backends.

**Abstract Methods to Implement:**
- `load_bytecode(bucket)`: Load cached bytecode into a bucket
- `dump_bytecode(bucket)`: Store bucket bytecode to cache

**Utility Methods:**
- `get_cache_key(name, filename)`: Generates unique hash key for templates
- `get_source_checksum(source)`: Creates checksum for source code validation
- `get_bucket()`: Creates and returns a cache bucket
- `clear()`: Clears the entire cache (optional implementation)

**Basic Implementation Example:**
```python
class MyCache(BytecodeCache):
    def __init__(self, directory):
        self.directory = directory

    def load_bytecode(self, bucket):
        filename = os.path.join(self.directory, bucket.key)
        if os.path.exists(filename):
            with open(filename, 'rb') as f:
                bucket.load_bytecode(f)

    def dump_bytecode(self, bucket):
        filename = os.path.join(self.directory, bucket.key)
        with open(filename, 'wb') as f:
            bucket.write_bytecode(f)
```

### `FileSystemBytecodeCache`

A filesystem-based implementation of the bytecode cache.

**Features:**
- Stores cache files on the filesystem
- Automatic directory creation with secure permissions
- Atomic file operations to prevent corruption
- Pattern-based filename generation

**Constructor Parameters:**
- `directory`: Cache directory (auto-generated if None)
- `pattern`: Filename pattern (default: `"__jinja2_%s.cache"`)

**Usage Example:**
```python
# Use default directory
cache = FileSystemBytecodeCache()

# Use custom directory and pattern
cache = FileSystemBytecodeCache('/tmp/jinja_cache', '%s.cache')
```

**Security Features:**
- Creates user-specific cache directories with restricted permissions (`0o700`)
- Validates directory ownership and permissions
- Uses atomic file operations to prevent race conditions

### `MemcachedBytecodeCache`

A memcached-based implementation for distributed caching scenarios.

**Compatible Libraries:**
- `cachelib`
- `python-memcached`

**Constructor Parameters:**
- `client`: Memcache client instance
- `prefix`: Key prefix (default: `"jinja2/bytecode/"`)
- `timeout`: Cache timeout in seconds
- `ignore_memcache_errors`: Whether to silently ignore memcache errors (default: `True`)

**Usage Example:**
```python
import memcache
client = memcache.Client(['127.0.0.1:11211'])
cache = MemcachedBytecodeCache(client, prefix='myapp/templates/', timeout=3600)
```

## Important Notes

### Security Considerations
- The `FileSystemBytecodeCache` implements secure directory creation with proper permission checks
- Cache files include magic headers and checksums to prevent loading corrupted or incompatible bytecode

### Error Handling
- The `MemcachedBytecodeCache` can optionally ignore memcache errors to prevent cache failures from breaking the application
- File operations in `FileSystemBytecodeCache` use atomic writes to prevent corruption

### Performance Tips
- Use filesystem cache for single-server deployments
- Use memcached cache for distributed applications
- Set appropriate timeouts to balance performance and cache freshness
- Consider clearing caches when deploying template changes

### Compatibility
- Magic bytes include Python version information to prevent loading incompatible bytecode
- Cache invalidation is automatic based on source code checksums

## Integration

To use bytecode caching with Jinja2:

```python
from jinja2 import Environment, FileSystemLoader
from jinja2.bccache import FileSystemBytecodeCache

# Create cache instance
cache = FileSystemBytecodeCache()

# Create environment with caching enabled
env = Environment(
    loader=FileSystemLoader('templates'),
    bytecode_cache=cache
)
```