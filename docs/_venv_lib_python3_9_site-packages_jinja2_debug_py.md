<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Debug Module Documentation

## Overview

This module provides debugging functionality for Jinja2 templates by rewriting Python tracebacks to display template source information instead of compiled template code. This makes it easier to debug template errors by showing the actual template file locations and line numbers where errors occur.

## Purpose

When Jinja2 templates are compiled to Python code, any exceptions that occur show Python code locations rather than the original template source. This module addresses that issue by:

- Replacing compiled code tracebacks with template source tracebacks
- Providing meaningful template context information in error messages
- Creating fake traceback objects that point to template files and line numbers

## Key Functions

### `rewrite_traceback_stack(source=None)`

**Purpose**: Main function that rewrites the current exception's traceback to show template source locations instead of compiled code locations.

**Parameters**:
- `source` (optional): Original template source string for `TemplateSyntaxError` exceptions

**Returns**: The original exception with a rewritten traceback

**Usage**: Must be called within an `except` block

```python
try:
    # Template execution code
    pass
except Exception:
    exc = rewrite_traceback_stack(template_source)
    raise exc
```

**Key Features**:
- Handles `TemplateSyntaxError` specially by removing compiler frames
- Skips internal Jinja2 code frames (marked with `@internalcode`)
- Replaces template code frames with source file information
- Builds a clean traceback stack pointing to template locations

### `fake_traceback(exc_value, tb, filename, lineno)`

**Purpose**: Creates a new traceback object that appears to originate from template source rather than compiled code.

**Parameters**:
- `exc_value`: The original exception being re-raised
- `tb`: Original traceback to extract context from (can be `None`)
- `filename`: Template filename to display
- `lineno`: Line number in the template source

**Returns**: A new `TracebackType` object pointing to template source

**Implementation Details**:
- Extracts template context variables using `get_template_locals()`
- Creates a new code object with template filename and line number
- Handles different Python versions (3.8+ vs earlier) for code object creation
- Generates meaningful location names ("top-level template code", "block 'name'")

### `get_template_locals(real_locals)`

**Purpose**: Extracts template context variables from runtime locals to provide meaningful debugging information.

**Parameters**:
- `real_locals`: Dictionary of runtime local variables

**Returns**: Dictionary of template variables available at the current execution point

**Key Features**:
- Extracts base template context from `context` variable
- Handles derived contexts with local variable overrides
- Processes variables with naming scheme `l_depth_name`
- Finds highest-depth values for each variable name
- Filters out internal variables and missing values

## Important Classes and Concepts

### Template Variable Naming Scheme

The module handles Jinja2's internal variable naming convention:
- Template variables are prefixed with `l_`
- Format: `l_{depth}_{variable_name}`
- Depth indicates context nesting level
- Higher depth values override lower ones

### Internal Code Filtering

- Skips frames marked with `@internalcode` decorator
- Focuses traceback on user-relevant template code
- Removes Jinja2 internal implementation details

## Usage Notes

### Requirements
- Must be called within an exception handler (`except` block)
- Requires access to template objects with `get_corresponding_lineno()` method
- Depends on `__jinja_template__` being available in frame globals

### Python Version Compatibility
- Handles differences between Python 3.8+ and earlier versions
- Uses `code.replace()` for Python 3.8+
- Falls back to `CodeType` constructor for older versions

### Template Context Detection
```python
# Template objects are detected via frame globals
template = tb.tb_frame.f_globals.get("__jinja_template__")
if template is not None:
    # Extract template source line number
    lineno = template.get_corresponding_lineno(tb.tb_lineno)
```

## Integration Points

This module integrates with:
- `exceptions.TemplateSyntaxError` for syntax error handling
- `utils.internal_code` for filtering internal frames
- `utils.missing` for handling undefined template variables
- `runtime.Context` for template variable context

## Best Practices

1. **Always call within exception handlers**: The function relies on `sys.exc_info()` to access current exception
2. **Provide source when available**: Pass template source to `rewrite_traceback_stack()` for better error messages
3. **Handle missing context gracefully**: The code safely handles cases where template context is not available