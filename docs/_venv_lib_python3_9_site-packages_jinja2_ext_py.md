<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Jinja2 Extension API Documentation

This file provides the extension API for the Jinja2 template engine, allowing developers to add custom tags, behaviors, and functionality to templates at the parser level.

## Overview

The extension system enables:
- Custom template tags and syntax
- Template preprocessing and token filtering
- Internationalization (i18n) support
- Debug utilities
- Loop control statements
- Expression statements

## Core Classes

### `Extension`

The base class for all Jinja2 extensions. Custom extensions inherit from this class to add functionality to the template system.

```python
class MyExtension(Extension):
    tags = {'mytag'}
    
    def parse(self, parser):
        # Implementation here
        pass
```

**Key Attributes:**
- `tags`: Set of tag names this extension handles
- `priority`: Extension priority (lower = higher priority, default: 100)
- `identifier`: Automatically generated unique identifier

**Important Methods:**

#### `bind(environment)`
Creates a copy of the extension bound to another environment.

#### `preprocess(source, name, filename=None)`
Called before lexing to preprocess template source code.
- **Parameters:** 
  - `source`: Template source string
  - `name`: Template name (optional)
  - `filename`: Template filename (optional)
- **Returns:** Preprocessed source string

#### `filter_stream(stream)`
Filters tokens from the lexer stream.
- **Parameters:** `stream`: TokenStream object
- **Returns:** Iterable of Token objects

#### `parse(parser)`
Main parsing method called when a matching tag is found.
- **Parameters:** `parser`: Parser instance
- **Returns:** Node or list of nodes

#### `attr(name, lineno=None)`
Returns an attribute node for the extension.

#### `call_method(name, args=None, kwargs=None, ...)`
Shortcut for calling extension methods in generated code.

## Built-in Extensions

### `InternationalizationExtension` (i18n)

Provides comprehensive internationalization support with gettext-style translation functions.

**Features:**
- `{% trans %}` blocks for translatable content
- Pluralization support with `{% pluralize %}`
- Context-aware translations
- Variable interpolation
- Automatic escaping support

**Usage Example:**
```jinja
{% trans %}Hello World!{% endtrans %}
{% trans count=items|length %}
  There is {{ count }} item.
{% pluralize %}
  There are {{ count }} items.
{% endtrans %}
```

**Methods:**
- `install_gettext_translations(translations)`: Install translation object
- `install_null_translations()`: Install null translations for testing
- `extract_translations(source)`: Extract translatable strings

### `ExprStmtExtension` (do)

Adds a `{% do %}` tag for executing expressions without output.

**Usage Example:**
```jinja
{% do navigation.append('a string') %}
```

### `LoopControlExtension`

Provides `{% break %}` and `{% continue %}` statements for loop control.

**Usage Example:**
```jinja
{% for user in users %}
    {% if user.is_hidden %}
        {% continue %}
    {% endif %}
    {% if loop.index > 10 %}
        {% break %}
    {% endif %}
    {{ user.name }}
{% endfor %}
```

### `DebugExtension`

Adds a `{% debug %}` tag that outputs available variables, filters, and tests.

**Usage Example:**
```jinja
<pre>{% debug %}</pre>
```

## Utility Functions

### `extract_from_ast(ast, gettext_functions=GETTEXT_FUNCTIONS, babel_style=True)`

Extracts translatable strings from template AST nodes.

**Parameters:**
- `ast`: Template AST node
- `gettext_functions`: Sequence of function names to extract
- `babel_style`: Whether to use Babel-compatible output format

**Returns:** Iterator of `(lineno, function, message)` tuples

### `babel_extract(fileobj, keywords, comment_tags, options)`

Babel integration for extracting translatable strings from Jinja templates.

## Constants

### `GETTEXT_FUNCTIONS`
Tuple of recognized i18n function names:
```python
("_", "gettext", "ngettext", "pgettext", "npgettext")
```

## Import Aliases

Convenient aliases for common extensions:
```python
i18n = InternationalizationExtension
do = ExprStmtExtension
loopcontrols = LoopControlExtension
debug = DebugExtension
```

## Usage Notes

### Creating Custom Extensions

1. **Inherit from Extension**: Always extend the base `Extension` class
2. **Define tags**: Set the `tags` attribute with tag names to handle
3. **Implement parse()**: Required method for processing your custom tags
4. **Handle configuration**: Store configuration on the environment, not the extension instance
5. **Use descriptive names**: Avoid generic names like "prefix" - use "myext_prefix" instead

### Configuration Best Practices

- Extensions cannot accept constructor arguments
- Store configuration values on the environment
- Use prefixed configuration names to avoid conflicts
- Access configuration in methods via `self.environment`

### Error Handling

- Use `TemplateAssertionError` for logical errors
- Use `TemplateSyntaxError` for syntax-related errors
- Call `parser.fail()` with descriptive error messages

### Performance Considerations

- Extensions with lower priority values are processed first
- Minimize work in `preprocess()` and `filter_stream()`
- Cache expensive computations when possible