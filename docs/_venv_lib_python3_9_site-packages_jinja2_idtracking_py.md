<!-- Auto-generated by Claude on 2025-06-02 06:15 -->

# Symbol Analysis Module

This module provides symbol table analysis for template Abstract Syntax Trees (AST). It tracks variable declarations, references, and scoping rules within template compilation contexts.

## Purpose

The module analyzes template AST nodes to:
- Track variable declarations and references
- Manage variable scoping and resolution
- Handle parameter passing and variable aliasing
- Support template compilation by providing symbol information

## Constants

```python
VAR_LOAD_PARAMETER = "param"      # Variable loaded as parameter
VAR_LOAD_RESOLVE = "resolve"      # Variable needs runtime resolution
VAR_LOAD_ALIAS = "alias"          # Variable is an alias to another
VAR_LOAD_UNDEFINED = "undefined"  # Variable is undefined
```

These constants define how variables are loaded and resolved during template execution.

## Main Functions

### `find_symbols(nodes, parent_symbols=None)`

Analyzes a collection of AST nodes and returns a `Symbols` object containing symbol information.

- **Parameters:**
  - `nodes`: Iterable of AST nodes to analyze
  - `parent_symbols`: Optional parent symbol table for nested scopes
- **Returns:** `Symbols` object with discovered symbols

### `symbols_for_node(node, parent_symbols=None)`

Analyzes a single AST node and returns its symbol information.

- **Parameters:**
  - `node`: Single AST node to analyze
  - `parent_symbols`: Optional parent symbol table
- **Returns:** `Symbols` object for the node

## Core Classes

### `Symbols`

Manages symbol tables for template scopes, tracking variable references, loads, and stores.

#### Key Attributes

- `level`: Nesting level of the scope
- `parent`: Parent symbol table (for nested scopes)
- `refs`: Dictionary mapping variable names to internal references
- `loads`: Dictionary mapping references to load instructions
- `stores`: Set of variables that are assigned in this scope

#### Important Methods

- **`store(name)`**: Records a variable assignment
- **`load(name)`**: Records a variable access
- **`declare_parameter(name)`**: Declares a parameter variable
- **`find_ref(name)`**: Finds reference for a variable name
- **`branch_update(branch_symbols)`**: Merges symbols from conditional branches

### `RootVisitor`

Visits specific AST node types that define new scopes or have special scoping rules.

#### Key Features

- Handles template-level constructs (Template, Block, Macro)
- Manages control flow nodes (If, For, With)
- Delegates detailed symbol analysis to `FrameSymbolVisitor`

#### Specialized Visit Methods

- `visit_For()`: Handles for-loop scoping with body/else/test branches
- `visit_With()`: Manages with-statement variable binding
- `visit_CallBlock()`: Processes call blocks with special scoping

### `FrameSymbolVisitor`

Performs detailed symbol analysis on individual AST nodes.

#### Key Responsibilities

- **Variable Context Handling**: Distinguishes between load, store, and parameter contexts
- **Scope Management**: Stops traversal at scope boundaries
- **Branch Analysis**: Handles conditional execution paths in if-statements

#### Important Visit Methods

- **`visit_Name()`**: Processes variable names based on context (load/store/param)
- **`visit_If()`**: Analyzes conditional branches and merges symbol tables
- **`visit_Assign()`**: Handles assignments in correct order (value then target)

## Usage Example

```python
# Analyze symbols in a list of AST nodes
symbols = find_symbols(ast_nodes)

# Check if a variable was stored
if 'my_var' in symbols.stores:
    print("Variable 'my_var' is assigned")

# Get reference for a variable
try:
    ref = symbols.ref('my_var')
    print(f"Variable reference: {ref}")
except AssertionError:
    print("Variable not found")
```

## Notes and Considerations

### Scoping Rules

- Variables are resolved using lexical scoping
- Parameters are automatically stored in the current scope
- Undefined variables get special `VAR_LOAD_UNDEFINED` treatment
- Aliases are created for variables accessed from outer scopes

### Performance

- Symbol tables use copy-on-write semantics for branch analysis
- Efficient lookup through parent chain traversal
- Minimal overhead for nested scope management

### Template Compilation Integration

This module is designed to work with template compilation systems that need:
- Variable lifetime analysis
- Scope boundary detection  
- Parameter passing optimization
- Undefined variable detection

## Suggestions

1. **Error Handling**: Consider adding more descriptive error messages for undefined variable access
2. **Debugging**: The `dump_stores()` and `dump_param_targets()` methods are useful for debugging symbol resolution
3. **Extension**: The visitor pattern makes it easy to add support for new AST node types
4. **Testing**: Symbol analysis can be complex - comprehensive test coverage is recommended for all scoping scenarios