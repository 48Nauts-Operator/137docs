<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Symbol Analysis Module

This module provides symbol table analysis for template AST nodes. It tracks variable references, stores, and loads across different scopes in a template hierarchy.

## Purpose

The symbol analysis system is designed to:
- Track variable definitions and references across template scopes
- Manage variable resolution between parent and child scopes
- Handle different types of variable loads (parameters, aliases, undefined, resolve)
- Support control flow analysis for conditional branches

## Constants

```python
VAR_LOAD_PARAMETER = "param"      # Variable loaded as a parameter
VAR_LOAD_RESOLVE = "resolve"      # Variable needs runtime resolution
VAR_LOAD_ALIAS = "alias"          # Variable is an alias to another scope
VAR_LOAD_UNDEFINED = "undefined"  # Variable is undefined
```

## Key Functions

### `find_symbols(nodes, parent_symbols=None)`
Analyzes a collection of nodes and returns a `Symbols` object containing symbol information.

**Parameters:**
- `nodes`: Iterable of AST nodes to analyze
- `parent_symbols`: Optional parent symbol table

**Returns:** `Symbols` object with analysis results

### `symbols_for_node(node, parent_symbols=None)`
Analyzes a single node and returns its symbol information.

**Parameters:**
- `node`: Single AST node to analyze
- `parent_symbols`: Optional parent symbol table

**Returns:** `Symbols` object with analysis results

## Classes

### `Symbols`

The main symbol table class that tracks variable references, loads, and stores within a scope.

#### Key Attributes
- `level`: Scope nesting level (0 for root)
- `parent`: Reference to parent symbol table
- `refs`: Dictionary mapping variable names to internal identifiers
- `loads`: Dictionary mapping identifiers to load instructions
- `stores`: Set of variable names that are stored/assigned

#### Important Methods

##### `analyze_node(node, **kwargs)`
Analyzes a node using the `RootVisitor`.

##### `store(name)`
Records a variable assignment. Handles scope resolution by:
- Checking if variable exists in parent scope (creates alias if found)
- Setting to undefined if not found in any parent scope

##### `load(name)`
Records a variable reference. Creates a resolve reference if not already defined.

##### `declare_parameter(name)`
Declares a variable as a parameter and returns its identifier.

##### `branch_update(branch_symbols)`
Merges symbol information from multiple branches (e.g., if/else statements).

##### `find_ref(name)` / `find_load(target)`
Searches current and parent scopes for variable references or load instructions.

### `RootVisitor`

Handles high-level template constructs and delegates symbol analysis to `FrameSymbolVisitor`.

#### Key Methods
- Visits template-level nodes (Template, Block, Macro, etc.)
- Handles control flow constructs (If, For, With)
- Manages scope boundaries

### `FrameSymbolVisitor`

Performs detailed symbol analysis on individual nodes.

#### Key Methods

##### `visit_Name(node, store_as_param=False, **kwargs)`
Handles variable name nodes based on context:
- `param`: Declares as parameter
- `store`: Records assignment
- `load`: Records reference

##### `visit_If(node, **kwargs)`
Handles conditional branches by:
1. Creating separate symbol tables for each branch
2. Merging results with `branch_update()`

##### `visit_For(node, **kwargs)`
Handles loop constructs, stopping at block boundaries.

## Usage Example

```python
# Analyze symbols in a list of template nodes
symbols = find_symbols(template_nodes)

# Check what variables are stored
stores = symbols.dump_stores()

# Find a variable reference
ref = symbols.find_ref("my_variable")
```

## Notes and Suggestions

### Design Patterns
- Uses the **Visitor Pattern** for AST traversal
- Implements **hierarchical symbol tables** for scope management
- Employs **copy-and-merge** strategy for branch analysis

### Important Considerations
- Symbol analysis stops at certain boundaries (Scope, Block, OverlayScope)
- Branch analysis creates copies of symbol tables to avoid side effects
- Variable resolution follows lexical scoping rules

### Potential Improvements
- Consider adding debug/logging capabilities for complex symbol resolution
- The `branch_update` method is complex and could benefit from additional documentation
- Error handling could be more specific (currently uses generic `AssertionError`)

### Type Safety
- Uses proper type hints with forward references
- Handles TYPE_CHECKING imports correctly
- Some methods return `t.Any` which could be more specific

This module is essential for template compilation and variable resolution in template engines.