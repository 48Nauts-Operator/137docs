<!-- Auto-generated by Claude on 2025-06-02 06:15 -->

# Native Python Type Rendering Module

## Overview

This module provides functionality for rendering Jinja2 templates to native Python types instead of strings. It allows templates to output structured data like lists, dictionaries, integers, and other Python objects rather than just string representations.

## Purpose

The primary purpose is to extend Jinja2's template rendering capabilities to produce native Python data structures. This is particularly useful when:
- Templates need to generate configuration data
- Output should be in a structured format (JSON-like objects)
- Type preservation is important for downstream processing

## Key Components

### Functions

#### `native_concat(values: t.Iterable[t.Any]) -> t.Optional[t.Any]`

The core function that converts template output to native Python types.

**Behavior:**
- Returns `None` for empty input
- Returns single values as-is if they're not strings
- Concatenates multiple values as strings
- Attempts to parse the result using `ast.literal_eval()` to convert to native types
- Falls back to string if parsing fails

```python
# Examples of what this function handles:
# [42] -> 42
# ["hello", "world"] -> "helloworld"
# ["[1, 2, 3]"] -> [1, 2, 3] (parsed as list)
# ["invalid python"] -> "invalid python" (fallback to string)
```

### Classes

#### `NativeCodeGenerator(CodeGenerator)`

A specialized code generator that modifies template compilation to preserve Python types.

**Key Features:**
- Overrides default finalization to avoid converting everything to strings
- Uses `_default_finalize()` that returns values unchanged
- Handles constant representation differently for native types

#### `NativeEnvironment(Environment)`

An environment configured for native type rendering.

**Configuration:**
- Uses `NativeCodeGenerator` as the code generator
- Uses `native_concat` as the concatenation function
- Inherits all other Environment functionality

#### `NativeTemplate(Template)`

Template class that renders to native Python types.

**Key Methods:**

##### `render(*args, **kwargs) -> t.Any`
Renders the template synchronously and returns native Python types.

##### `render_async(*args, **kwargs) -> t.Any`
Renders the template asynchronously (requires async-enabled environment).

**Error Handling:**
- Both render methods include exception handling
- Falls back to environment's exception handling mechanism

## Usage Example

```python
from jinja2.nativetypes import NativeEnvironment

# Create a native environment
env = NativeEnvironment()

# Template that outputs a list
template = env.from_string('[{% for item in items %}{{ item }}{% if not loop.last %}, {% endif %}{% endfor %}]')

# Renders to actual Python list, not string
result = template.render(items=[1, 2, 3])
# result is [1, 2, 3], not "[1, 2, 3]"
```

## Important Notes

### Compatibility Considerations
- The `native_concat` function includes special handling for Python 3.10+ compatibility
- Uses `ast.parse()` instead of relying on `literal_eval()`'s built-in parsing to maintain consistent behavior across Python versions

### Security
- Uses `ast.literal_eval()` for safe evaluation of string representations
- Only evaluates literals, not arbitrary code execution

### Performance
- Generator types are handled efficiently to avoid unnecessary memory usage
- Falls back gracefully when parsing fails

### Limitations
- Only works with data that can be represented as Python literals
- Complex objects that can't be safely evaluated will remain as strings
- Async rendering requires an async-enabled environment

## Dependencies

This module depends on:
- `ast` module for safe evaluation
- `itertools` for efficient iteration
- Internal Jinja2 modules (`nodes`, `compiler`, `environment`)