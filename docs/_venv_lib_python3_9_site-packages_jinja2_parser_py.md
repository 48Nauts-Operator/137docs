<!-- Auto-generated by Claude on 2025-06-02 06:15 -->

# Jinja Parser Documentation

This module contains the core parsing functionality for the Jinja templating engine. It transforms tokens from the lexer into an Abstract Syntax Tree (AST) composed of nodes that can be compiled and executed.

## Overview

The parser takes tokenized Jinja template code and converts it into a structured tree of nodes representing template statements, expressions, and data. This is a critical component in the Jinja template compilation pipeline.

## Key Components

### Constants and Mappings

- **`_statement_keywords`**: Frozen set of recognized statement keywords like `for`, `if`, `block`, etc.
- **`_compare_operators`**: Frozen set of comparison operators (`eq`, `ne`, `lt`, etc.)
- **`_math_nodes`**: Dictionary mapping mathematical operation tokens to their corresponding AST node classes

## Main Parser Class

### `Parser`

The central parsing class that handles the conversion of tokens to AST nodes.

#### Constructor

```python
def __init__(self, environment, source, name=None, filename=None, state=None)
```

**Parameters:**
- `environment`: Jinja environment instance
- `source`: Template source code string
- `name`: Optional template name
- `filename`: Optional filename for error reporting
- `state`: Optional parser state

#### Key Attributes

- `stream`: Token stream from the lexer
- `extensions`: Dictionary of registered template extensions
- `_tag_stack`: Stack tracking nested template tags
- `_end_token_stack`: Stack for expected end tokens

## Core Parsing Methods

### Statement Parsing

#### `parse_statement()`
Parses a single template statement and routes to appropriate handler methods.

```python
def parse_statement() -> Union[nodes.Node, List[nodes.Node]]
```

#### Statement-Specific Parsers

- **`parse_for()`**: Parses `for` loops with optional `else` clauses
- **`parse_if()`**: Parses `if`/`elif`/`else` conditional statements  
- **`parse_block()`**: Parses template blocks with scoping options
- **`parse_set()`**: Parses variable assignments
- **`parse_with()`**: Parses `with` context managers
- **`parse_macro()`**: Parses macro definitions
- **`parse_extends()`**: Parses template inheritance
- **`parse_include()`**: Parses template inclusion
- **`parse_import()`** and **`parse_from()`**: Parse import statements

### Expression Parsing

The parser implements operator precedence through a recursive descent approach:

#### `parse_expression(with_condexpr=True)`
Main entry point for expression parsing.

#### Precedence Hierarchy (highest to lowest)

1. **`parse_condexpr()`**: Conditional expressions (`expr if test else other`)
2. **`parse_or()`**: Logical OR operations
3. **`parse_and()`**: Logical AND operations  
4. **`parse_not()`**: Logical NOT operations
5. **`parse_compare()`**: Comparison operations
6. **`parse_math1()`**: Addition and subtraction
7. **`parse_concat()`**: String concatenation with `~`
8. **`parse_math2()`**: Multiplication, division, modulo
9. **`parse_pow()`**: Exponentiation
10. **`parse_unary()`**: Unary plus/minus
11. **`parse_primary()`**: Literals, names, parenthesized expressions

### Data Structure Parsing

#### `parse_tuple()`
Parses tuple expressions with comprehensive options:

```python
def parse_tuple(
    simplified=False,
    with_condexpr=True, 
    extra_end_rules=None,
    explicit_parentheses=False,
    with_namespace=False
) -> Union[nodes.Tuple, nodes.Expr]
```

#### `parse_list()` and `parse_dict()`
Parse list and dictionary literals respectively.

### Advanced Features

#### `parse_filter()`
Parses filter applications using the pipe (`|`) operator.

#### `parse_test()`  
Parses test expressions using the `is` keyword.

#### `parse_call()`
Parses function/method calls with support for:
- Positional arguments
- Keyword arguments  
- Dynamic argument unpacking (`*args`, `**kwargs`)

## Error Handling

### `fail(msg, lineno=None, exc=TemplateSyntaxError)`
Primary error reporting method with context information.

### `fail_unknown_tag(name, lineno=None)`
Specialized error for unrecognized template tags with helpful suggestions.

### `fail_eof(end_tokens=None, lineno=None)`
Handles unexpected end-of-file errors with context about expected tokens.

## Utility Methods

### `free_identifier(lineno=None)`
Generates unique internal identifiers for compiler use.

### `is_tuple_end(extra_end_rules=None)`
Determines if current position marks the end of a tuple expression.

### `subparse(end_tokens=None)`
Core parsing loop that processes template content until specified end tokens.

## Usage Notes

### Extension Support
The parser automatically integrates registered Jinja extensions, allowing custom template tags and functionality.

### Error Context
All parsing methods maintain line number information for precise error reporting and debugging.

### Type Safety
The module uses extensive type hints and supports both runtime and static type checking.

## Important Considerations

- **Performance**: The recursive descent approach provides good performance for typical template complexity
- **Memory**: The parser maintains several stacks for context tracking
- **Thread Safety**: Parser instances are not thread-safe and should not be shared
- **Extension Compatibility**: Custom extensions must follow the established parsing protocols

## Integration

This parser integrates with:
- **Lexer**: Consumes token streams
- **Nodes**: Produces AST node structures  
- **Compiler**: Provides AST for code generation
- **Environment**: Uses configuration and extensions