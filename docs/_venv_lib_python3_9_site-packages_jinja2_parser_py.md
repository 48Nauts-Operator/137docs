<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Jinja2 Parser Documentation

This module implements the core parser for the Jinja2 templating engine. It transforms tokens from the lexer into Abstract Syntax Tree (AST) nodes that can be compiled and executed.

## Overview

The parser takes a stream of tokens produced by the Jinja2 lexer and converts them into structured node objects representing template constructs like statements, expressions, and literal data. This is a critical component in the template compilation pipeline.

## Key Components

### Constants and Mappings

```python
_statement_keywords = frozenset([
    "for", "if", "block", "extends", "print", "macro", 
    "include", "from", "import", "set", "with", "autoescape"
])

_compare_operators = frozenset(["eq", "ne", "lt", "lteq", "gt", "gteq"])

_math_nodes = {
    "add": nodes.Add, "sub": nodes.Sub, "mul": nodes.Mul,
    "div": nodes.Div, "floordiv": nodes.FloorDiv, "mod": nodes.Mod
}
```

These define the recognized keywords and operator mappings for parsing different template constructs.

## Main Parser Class

### `Parser`

The central parsing class that handles the conversion of tokens to AST nodes.

#### Constructor

```python
def __init__(self, environment, source, name=None, filename=None, state=None)
```

**Parameters:**
- `environment`: The Jinja2 environment instance
- `source`: Template source code string
- `name`: Optional template name
- `filename`: Optional filename for error reporting
- `state`: Optional parsing state

**Key Attributes:**
- `stream`: Token stream from the lexer
- `extensions`: Dictionary mapping extension tags to their parsers
- `_tag_stack`: Stack tracking nested template tags
- `_end_token_stack`: Stack tracking expected end tokens

## Core Parsing Methods

### Statement Parsing

#### `parse_statement()`
Parses a single template statement (like `{% if %}`, `{% for %}`, etc.)

```python
def parse_statement() -> Union[nodes.Node, List[nodes.Node]]
```

#### `parse_statements(end_tokens, drop_needle=False)`
Parses multiple statements until reaching specified end tokens.

**Parameters:**
- `end_tokens`: Tuple of token names that signal the end
- `drop_needle`: Whether to consume the end token

### Template Statement Parsers

The parser includes specialized methods for each template statement type:

- **`parse_for()`**: Handles `{% for %}` loops
- **`parse_if()`**: Handles `{% if %}` conditionals  
- **`parse_block()`**: Handles `{% block %}` definitions
- **`parse_extends()`**: Handles `{% extends %}` inheritance
- **`parse_include()`**: Handles `{% include %}` statements
- **`parse_set()`**: Handles `{% set %}` variable assignments
- **`parse_macro()`**: Handles `{% macro %}` definitions

### Expression Parsing

The parser uses operator precedence parsing for expressions:

```python
parse_expression()     # Entry point
  ↓
parse_condexpr()      # Conditional expressions (a if b else c)
  ↓  
parse_or()            # Logical OR
  ↓
parse_and()           # Logical AND
  ↓
parse_not()           # Logical NOT
  ↓
parse_compare()       # Comparisons (==, !=, <, etc.)
  ↓
parse_math1()         # Addition/subtraction
  ↓
parse_concat()        # String concatenation (~)
  ↓
parse_math2()         # Multiplication/division
  ↓
parse_pow()           # Exponentiation
  ↓
parse_unary()         # Unary +/-
  ↓
parse_primary()       # Literals, names, parentheses
```

### Data Structure Parsing

#### `parse_tuple()`
Parses tuple expressions with various options:

```python
def parse_tuple(
    simplified=False,        # Only parse names/literals
    with_condexpr=True,     # Allow conditional expressions
    extra_end_rules=None,   # Additional end conditions
    explicit_parentheses=False,  # Explicitly parenthesized
    with_namespace=False    # Allow namespace references
)
```

#### `parse_list()` and `parse_dict()`
Parse list literals `[1, 2, 3]` and dictionary literals `{'key': 'value'}`.

## Error Handling

### `fail(msg, lineno=None, exc=TemplateSyntaxError)`
Primary error reporting method that raises exceptions with context information.

### `fail_unknown_tag(name, lineno=None)`
Specialized error for unrecognized template tags with helpful suggestions.

### `fail_eof(end_tokens=None, lineno=None)`
Handles unexpected end-of-file errors with context about expected tokens.

## Utility Methods

### `free_identifier(lineno=None)`
Generates unique internal variable names for compiler use.

### `is_tuple_end(extra_end_rules=None)`
Determines if the current position marks the end of a tuple expression.

### `parse_assign_target()`
Parses assignment targets (variables that can be assigned to).

## Usage Example

```python
from jinja2 import Environment
from jinja2.parser import Parser

env = Environment()
source = "{% for item in items %}{{ item }}{% endfor %}"
parser = Parser(env, source, name="example")
ast = parser.parse()
```

## Important Notes

### Extension Support
The parser automatically registers extensions and their custom tags:

```python
for extension in environment.iter_extensions():
    for tag in extension.tags:
        self.extensions[tag] = extension.parse
```

### Context Tracking
The parser maintains context stacks to provide meaningful error messages:
- `_tag_stack`: Currently open template tags
- `_end_token_stack`: Expected closing tokens

### Type Safety
The module uses extensive type hints and generic type variables for better IDE support and runtime type checking.

## Best Practices

1. **Error Handling**: