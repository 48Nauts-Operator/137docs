<!-- Auto-generated by Claude on 2025-06-02 06:15 -->

# BlockParser Module Documentation

## Overview

This module is part of the Python Markdown library, which provides a Python implementation of John Gruber's Markdown specification. The `blockparser` module specifically handles the parsing of Markdown block-level elements such as paragraphs, headers, lists, and blockquotes.

## Purpose

The block parser is responsible for:
- Converting Markdown text blocks into an XML ElementTree structure
- Managing the parsing state during nested block processing
- Coordinating multiple block processors to handle different types of Markdown blocks
- Providing a foundation for extensions to add custom block-level functionality

> **Note:** This parser focuses only on block-level elements and does not handle inline elements like `**bold**` or `*italic*` text.

## Classes

### State Class

```python
class State(list):
```

A utility class that tracks the current and nested parsing state.

**Purpose:** 
- Manages nested parsing levels using a stack-based approach
- Prevents state corruption when parsing nested blocks
- Provides a simple API wrapped around a Python list

**Key Methods:**
- `set(state)` - Push a new state onto the stack
- `reset()` - Pop the current state from the stack  
- `isstate(state)` - Check if the current state matches the given state

**Usage Example:**
```python
state = State()
state.set('list')
if state.isstate('list'):
    # Process list items
    pass
state.reset()  # Must reset when exiting nested level
```

### BlockParser Class

```python
class BlockParser:
```

The main parser class that orchestrates the conversion of Markdown blocks into an ElementTree.

**Attributes:**
- `md` (Markdown) - Reference to the parent Markdown instance
- `state` (State) - Tracks nesting levels during parsing
- `blockprocessors` (util.Registry) - Collection of block processors
- `root` (etree.Element) - Root element of the parsed document

**Key Methods:**

#### `__init__(md: Markdown)`
Initializes the block parser with a Markdown instance.

#### `parseDocument(lines: Iterable[str]) -> etree.ElementTree`
Parses a complete Markdown document.

- **Input:** List of text lines
- **Output:** Complete ElementTree object
- **Usage:** Call this for parsing entire documents

```python
lines = ['# Header', '', 'Paragraph text']
tree = parser.parseDocument(lines)
```

#### `parseChunk(parent: etree.Element, text: str) -> None`
Parses a chunk of Markdown text and attaches it to a parent element.

- **Input:** Parent element and text string
- **Output:** None (modifies parent in-place)
- **Usage:** Called by extensions for parsing text blocks

#### `parseBlocks(parent: etree.Element, blocks: list[str]) -> None`
Processes individual blocks of Markdown text.

- **Input:** Parent element and list of text blocks
- **Output:** None (modifies parent in-place)
- **Usage:** Internal method that coordinates block processors

## Architecture

The parsing process follows this flow:

1. **Document Input** ‚Üí `parseDocument()`
2. **Text Splitting** ‚Üí `parseChunk()` (splits on double newlines)
3. **Block Processing** ‚Üí `parseBlocks()` (iterates through block processors)
4. **ElementTree Output**

## Extension Points

### Adding Custom Block Processors

Extensions can modify parsing behavior by:

- Adding new block processors to `blockprocessors` registry
- Replacing existing processors
- Removing unwanted processors

```python
# Example of how an extension might add a processor
parser.blockprocessors.register(CustomProcessor(), 'custom', 75)
```

## Important Notes

- ‚ö†Ô∏è **State Management:** Always call `state.reset()` after `state.set()` to prevent state corruption
- üîß **Extension Friendly:** The registry-based processor system allows easy customization
- üìù **In-Place Modification:** Parser methods modify the ElementTree in-place rather than returning new objects
- üéØ **Block-Level Only:** This parser handles only block elements; inline parsing happens elsewhere

## Dependencies

- `xml.etree.ElementTree` - For XML/HTML tree manipulation
- `util` module - Provides the Registry class for managing processors
- `blockprocessors` module - Contains the actual block processing implementations

## Related Components

- **Block Processors** - Individual processors for specific block types (headers, lists, etc.)
- **Inline Processors** - Handle inline elements within blocks
- **Extensions** - Can add custom block processors or modify existing ones