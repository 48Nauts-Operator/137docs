<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Python Markdown Block Processors

This Python file implements the block processing functionality for the Python Markdown library. Block processors parse blocks of text (separated by blank lines) and convert them into structured HTML elements using Python's ElementTree API.

## Purpose

Block processors handle different types of Markdown syntax that span multiple lines or have special formatting requirements, such as:
- Code blocks
- Lists (ordered and unordered)  
- Headers
- Blockquotes
- Horizontal rules
- Paragraphs

## Key Components

### Main Builder Function

#### `build_block_parser(md: Markdown, **kwargs: Any) -> BlockParser`

Constructs and configures the default block parser with all standard processors registered in priority order (higher numbers processed first):

- **Empty blocks** (100) - Handle empty lines
- **List indentation** (90) - Process indented list content
- **Code blocks** (80) - Handle indented code
- **Hash headers** (70) - Process `# Header` syntax
- **Setext headers** (60) - Process underlined headers
- **Horizontal rules** (50) - Process `---` or `***` separators
- **Ordered lists** (40) - Process numbered lists
- **Unordered lists** (30) - Process bullet lists  
- **Blockquotes** (20) - Process `>` quoted text
- **References** (15) - Process link references
- **Paragraphs** (10) - Default processor for regular text

### Base Class

#### `BlockProcessor`

Abstract base class that all block processors inherit from.

**Key Methods:**
- `test(parent, block)` - Returns `True` if this processor should handle the block
- `run(parent, blocks)` - Processes the block and modifies the ElementTree
- `detab(text, length)` - Removes indentation from text
- `lastChild(parent)` - Helper to get the last child element

**Important Attributes:**
- `parser` - Reference to the BlockParser instance
- `tab_length` - Tab width setting from Markdown instance

## Block Processor Classes

### `ListIndentProcessor`
Handles indented content within list items. Manages nested list structures and proper indentation levels.

### `CodeBlockProcessor` 
Processes indented code blocks (4+ spaces). Creates `<pre><code>` elements and preserves whitespace.

### `BlockQuoteProcessor`
Handles blockquotes starting with `>`. Supports nested blockquotes and removes quote markers.

### `OListProcessor` / `UListProcessor`
Process ordered (numbered) and unordered (bullet) lists respectively. Handle:
- Multiple items in one block
- Nested lists
- Custom start numbers for ordered lists
- Mixed list types

### `HashHeaderProcessor` / `SetextHeaderProcessor`
Process two header styles:
- **Hash**: `# Header` syntax (1-6 levels)
- **Setext**: Underlined headers using `===` or `---`

### `HRProcessor`
Detects horizontal rules using `---`, `***`, or `___` patterns.

### `ReferenceProcessor`
Processes link reference definitions like:
```markdown
[id]: http://example.com "Optional Title"
```

### `ParagraphProcessor`
Default processor that wraps regular text in `<p>` tags. Always returns `True` from `test()` as the fallback processor.

### `EmptyBlockProcessor`
Handles empty blocks and preserves necessary whitespace, especially within code blocks.

## Usage Notes

- Processors are executed in priority order until one returns `True` from its `test()` method
- The `run()` method modifies the ElementTree in-place and manipulates the blocks list
- State management is used to handle context-dependent parsing (e.g., inside lists vs. regular text)
- Recursion protection prevents infinite loops during parsing
- Tab length is configurable and affects indentation detection

## Important Considerations

- **Order matters**: Processor priority determines which syntax takes precedence
- **State awareness**: Some processors behave differently based on parser state (list context, etc.)
- **In-place modification**: All processors modify the existing ElementTree rather than returning new elements
- **Block manipulation**: Processors can split, combine, or reorder blocks during processing

This architecture provides a flexible and extensible system for handling the various block-level syntax elements in Markdown while maintaining proper precedence and context awareness.