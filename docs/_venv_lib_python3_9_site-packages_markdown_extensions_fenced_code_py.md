<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Fenced Code Extension for Python Markdown

## Overview

This extension adds support for **Fenced Code Blocks** to Python-Markdown. Fenced code blocks allow users to write code snippets enclosed in triple backticks (```) or tildes (~~~) with optional language specification and syntax highlighting.

## Purpose

The extension enables markdown processing of code blocks like:

```python
```python
def hello_world():
    print("Hello, World!")
```
```

It provides:
- Syntax highlighting via the CodeHilite extension
- Language specification
- Custom attributes and styling
- HTML escaping for code content

## Main Classes

### `FencedCodeExtension`

The main extension class that integrates with Python-Markdown.

**Configuration Options:**
- `lang_prefix`: Prefix prepended to language classes (default: `"language-"`)

**Key Methods:**
- `extendMarkdown(md)`: Registers the preprocessor with the Markdown instance

### `FencedBlockPreprocessor`

The core processor that finds and processes fenced code blocks.

**Key Features:**
- Uses regex pattern matching to identify fenced code blocks
- Supports both backticks (```) and tildes (~~~) as fence markers
- Handles syntax highlighting integration
- Processes custom attributes and configurations

**Important Methods:**

#### `run(lines: list[str]) -> list[str]`
Main processing method that:
- Searches for fenced code blocks in the text
- Extracts language, attributes, and configuration
- Applies syntax highlighting if available
- Returns processed HTML

#### `handle_attrs(attrs) -> tuple[str, list[str], dict[str, Any]]`
Processes block attributes and returns:
- `id`: Element ID
- `classes`: List of CSS classes  
- `configs`: Configuration dictionary

## Regular Expression Pattern

The extension uses a complex regex pattern (`FENCED_BLOCK_RE`) that matches:

```python
(?P<fence>^(?:~{3,}|`{3,}))[ ]*                          # opening fence
((\{(?P<attrs>[^\n]*)\})|                                # optional {attrs} or
(\.?(?P<lang>[\w#.+-]*)[ ]*)?                            # optional language
(hl_lines=(?P<quot>"|')(?P<hl_lines>.*?)(?P=quot)[ ]*)?) # optional hl_lines
\n                                                       # newline
(?P<code>.*?)(?<=\n)                                     # code content
(?P=fence)[ ]*$                                          # closing fence
```

## Dependencies and Integration

The extension integrates with:
- **CodeHiliteExtension**: For syntax highlighting
- **AttrListExtension**: For attribute processing

## Configuration Options

### Boolean Options
The following options can be set as boolean values:
- `linenums`: Show line numbers
- `guess_lang`: Automatically guess language
- `noclasses`: Use inline styles instead of CSS classes
- `use_pygments`: Enable/disable Pygments highlighting

### Syntax Examples

```markdown
# Basic usage
```python
print("Hello World")
```

# With attributes
```{.python hl_lines="1 3" linenums=true}
def example():
    pass
    return True
```

# Legacy hl_lines syntax
```python hl_lines="1 2"
line1 = "highlighted"
line2 = "also highlighted"  
line3 = "normal"
```
```

## Notes and Suggestions

### Performance Considerations
- The extension processes text in a single pass using regex matching
- Large documents with many code blocks may benefit from chunked processing

### Compatibility
- Maintains backward compatibility with legacy `hl_lines` syntax
- Gracefully handles malformed attribute syntax by skipping invalid blocks

### Security
- Implements HTML escaping via `_escape()` method to prevent XSS attacks
- Uses `_escape_attrib_html()` for attribute values

### Usage Recommendations
1. **Enable CodeHilite extension** for syntax highlighting
2. **Use AttrList extension** for advanced attribute support
3. **Configure `lang_prefix`** to match your CSS framework requirements
4. **Test attribute syntax** carefully as malformed attributes are silently skipped

## Factory Function

```python
def makeExtension(**kwargs):
    return FencedCodeExtension(**kwargs)
```

Standard factory function for creating extension instances with custom configuration.