<!-- Auto-generated by Claude on 2025-06-02 06:15 -->

# Locale Module Documentation

## Overview

This module provides a simple locale handling system for internationalization purposes. It defines a `Locale` class that represents language and territory combinations (e.g., "en_US", "fr_CA") and includes validation and parsing functionality.

## Purpose

The module is designed to:
- Parse and validate locale identifiers
- Represent locale information as structured data
- Provide string representation of locales in standard format
- Handle locale-related errors gracefully

## Classes

### `Locale`

A `NamedTuple` that represents a locale with language and optional territory components.

#### Attributes

- **`language`** (`str`): The language code (e.g., "en", "fr")
- **`territory`** (`str`, optional): The territory/country code (e.g., "US", "CA"). Defaults to empty string.

#### Methods

##### `__str__() -> str`

Returns the string representation of the locale.

**Returns:**
- If territory is present: `"language_territory"` (e.g., "en_US")
- If no territory: `"language"` (e.g., "en")

**Example:**
```python
locale1 = Locale("en", "US")
print(str(locale1))  # Output: "en_US"

locale2 = Locale("fr")
print(str(locale2))  # Output: "fr"
```

##### `parse(cls, identifier: str, sep: str) -> Locale`

Class method that parses a locale identifier string and returns a `Locale` instance.

**Parameters:**
- `identifier` (`str`): The locale string to parse
- `sep` (`str`): The separator character used in the identifier

**Returns:**
- `Locale`: A new Locale instance

**Raises:**
- `TypeError`: If identifier is not a string
- `ValueError`: If language contains non-alphabetic characters
- `UnknownLocaleError`: If language code is not exactly 2 characters

**Example:**
```python
locale = Locale.parse("en_US", "_")
# Returns: Locale(language='en', territory='US')

locale = Locale.parse("fr-CA", "-")
# Returns: Locale(language='fr', territory='CA')
```

### `UnknownLocaleError`

A custom exception class that inherits from `Exception`. Raised when an invalid or unrecognized locale is encountered.

## Usage Examples

```python
# Creating locales directly
locale1 = Locale("en", "US")
locale2 = Locale("fr")

# Parsing locale strings
try:
    locale3 = Locale.parse("de_DE", "_")
    locale4 = Locale.parse("es-MX", "-")
except UnknownLocaleError as e:
    print(f"Invalid locale: {e}")

# String representation
print(str(locale1))  # "en_US"
print(str(locale2))  # "fr"
```

## Notes and Suggestions

### Current Limitations

- **Language Code Validation**: The current implementation only accepts 2-character language codes. This excludes valid ISO 639-2/T 3-character codes (e.g., "eng", "fra").
- **Territory Validation**: No validation is performed on territory codes.
- **Case Sensitivity**: No case normalization is applied.

### Suggestions for Improvement

1. **Enhanced Validation**:
   ```python
   # Consider supporting both ISO 639-1 (2-char) and ISO 639-2 (3-char) codes
   if len(locale.language) not in [2, 3]:
       raise UnknownLocaleError(f"unknown locale '{locale.language}'")
   ```

2. **Territory Validation**:
   ```python
   # Add validation for territory codes (ISO 3166-1 alpha-2)
   if locale.territory and len(locale.territory) != 2:
       raise ValueError(f"Invalid territory code: '{locale.territory}'")
   ```

3. **Case Normalization**:
   ```python
   # Normalize case (language lowercase, territory uppercase)
   language = locale.language.lower()
   territory = locale.territory.upper() if locale.territory else ''
   ```

4. **Additional Methods**: Consider adding methods like `is_valid()`, `get_language_name()`, or `get_territory_name()` for enhanced functionality.

### Best Practices

- Always handle `UnknownLocaleError` when parsing user input
- Consider validating locale identifiers against a known list of valid locales for production applications
- Use consistent separators throughout your application (underscore `_` is the standard convention)