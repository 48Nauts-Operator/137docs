<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Locale Module Documentation

## Overview

This module provides functionality for handling and parsing locale identifiers. It defines a structured way to represent locales with language and territory components, along with validation and parsing capabilities.

## Purpose

The module is designed to:
- Parse locale identifiers into structured components (language and territory)
- Validate locale format and constraints
- Provide a standardized string representation of locales
- Handle locale-related errors through custom exceptions

## Classes

### `UnknownLocaleError`

```python
class UnknownLocaleError(Exception):
    pass
```

**Purpose:** Custom exception raised when an invalid or unrecognized locale is encountered.

**Usage:** Thrown when locale validation fails, specifically when the language code doesn't meet the expected criteria.

### `Locale`

```python
class Locale(NamedTuple):
    language: str
    territory: str = ''
```

**Purpose:** Represents a locale with language and optional territory components.

**Attributes:**
- `language` (str): The language code (required)
- `territory` (str): The territory/country code (optional, defaults to empty string)

#### Methods

##### `__str__()`

**Purpose:** Returns the string representation of the locale.

**Returns:**
- `language_territory` format when territory is present
- `language` only when territory is empty

**Example:**
```python
locale1 = Locale("en", "US")
print(locale1)  # Output: "en_US"

locale2 = Locale("fr")
print(locale2)  # Output: "fr"
```

##### `parse(cls, identifier, sep)`

**Purpose:** Class method to parse a locale identifier string into a Locale object.

**Parameters:**
- `identifier` (str): The locale string to parse
- `sep` (str): The separator character used to split language and territory

**Returns:** `Locale` object

**Raises:**
- `TypeError`: If identifier is not a string
- `ValueError`: If language contains non-alphabetic characters
- `UnknownLocaleError`: If language code is not exactly 2 characters

**Example:**
```python
# Valid usage
locale = Locale.parse("en_US", "_")
# Result: Locale(language="en", territory="US")

locale = Locale.parse("fr-CA", "-")
# Result: Locale(language="fr", territory="CA")
```

## Usage Examples

```python
# Creating locales
locale1 = Locale("en", "US")
locale2 = Locale("fr")

# Parsing locale strings
try:
    parsed_locale = Locale.parse("de_DE", "_")
    print(f"Language: {parsed_locale.language}, Territory: {parsed_locale.territory}")
except UnknownLocaleError as e:
    print(f"Invalid locale: {e}")
```

## Validation Rules

The module enforces the following validation rules:

- **Language codes must be exactly 2 characters long**
- **Language codes must contain only ASCII letters**
- **Identifier parameter must be a string type**

## Notes and Suggestions

### Current Limitations
- The module only accepts 2-character language codes, which may not cover all ISO 639 language code variations (some use 3 characters)
- Territory validation is not implemented - any string is accepted as territory
- No validation against actual ISO locale standards

### Suggestions for Improvement
1. **Extend language code support** to handle 3-character ISO 639-2/3 codes
2. **Add territory validation** to ensure valid country/territory codes
3. **Consider using established locale libraries** like `babel` or `locale` for more comprehensive locale handling
4. **Add case normalization** to handle mixed-case input consistently
5. **Implement locale comparison methods** for sorting and equality checks

### Best Practices
- Always handle `UnknownLocaleError` when parsing user input
- Use consistent separators throughout your application
- Consider caching parsed locales for performance in high-usage scenarios