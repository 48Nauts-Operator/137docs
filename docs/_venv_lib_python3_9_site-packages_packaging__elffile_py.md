<!-- Auto-generated by Claude on 2025-06-02 06:15 -->

# ELF File Parser

## Overview

This module provides a Python implementation for parsing ELF (Executable and Linkable Format) files. It offers a `ELFFile` class that can read and extract information from ELF executables, similar to how `ZipFile` works for ZIP archives. The parser is read-only and focuses on extracting key metadata from ELF headers.

## Purpose

- Parse ELF executable files to extract header information
- Provide access to ELF file metadata such as architecture, encoding, and interpreter path
- Offer a simple, file-like interface for ELF file analysis

## Classes and Enums

### Exception Classes

#### `ELFInvalid`
```python
class ELFInvalid(ValueError):
    pass
```
Custom exception raised when ELF file parsing fails due to invalid or corrupted data.

### Enum Classes

#### `EIClass`
Defines ELF file capacity (bitness):
- `C32 = 1`: 32-bit ELF files
- `C64 = 2`: 64-bit ELF files

#### `EIData`
Defines data encoding (endianness):
- `Lsb = 1`: Little-endian (Least Significant Byte first)
- `Msb = 2`: Big-endian (Most Significant Byte first)

#### `EMachine`
Defines supported machine architectures:
- `I386 = 3`: Intel 80386
- `S390 = 22`: IBM System/390
- `Arm = 40`: ARM architecture
- `X8664 = 62`: AMD x86-64
- `AArc64 = 183`: ARM 64-bit architecture

### Main Class

#### `ELFFile`

The primary class for parsing ELF files.

```python
class ELFFile:
    def __init__(self, f: IO[bytes]) -> None:
        # Initialization code
```

##### Constructor Parameters
- `f`: A file-like object opened in binary mode containing the ELF data

##### Public Properties
- `capacity`: ELF file bitness (32-bit or 64-bit)
- `encoding`: Data encoding (little-endian or big-endian)
- `machine`: Target machine architecture
- `flags`: Processor-specific flags

##### Public Methods

###### `interpreter`
```python
@property
def interpreter(self) -> str | None:
```
Returns the interpreter path from the `PT_INTERP` section header, or `None` if not found.

**Returns:** 
- `str`: Path to the dynamic linker/interpreter
- `None`: If no interpreter section is found

## Usage Example

```python
# Open and parse an ELF file
with open('example_binary', 'rb') as f:
    elf = ELFFile(f)
    
    print(f"Architecture: {elf.machine}")
    print(f"Bitness: {elf.capacity}")
    print(f"Endianness: {elf.encoding}")
    print(f"Interpreter: {elf.interpreter}")
```

## Implementation Details

### Header Parsing

The parser supports multiple ELF formats based on bitness and endianness combinations:

- **32-bit Little-endian**: `<HHIIIIIHHH` format
- **32-bit Big-endian**: `>HHIIIIIHHH` format  
- **64-bit Little-endian**: `<HHIQQQIHHH` format
- **64-bit Big-endian**: `>HHIQQQIHHH` format

### Magic Number Validation

The parser validates the ELF magic number (`\x7fELF`) at the beginning of the file to ensure it's a valid ELF file.

## Notes and Suggestions

### Limitations
- **Read-only**: This implementation only supports reading ELF files, not writing or modifying them
- **Limited section parsing**: Currently only extracts the interpreter section; could be extended for other sections
- **Basic error handling**: Struct parsing errors are caught but may need more specific error messages

### Potential Improvements
- Add support for parsing additional ELF sections (symbols, relocations, etc.)
- Implement context manager support (`__enter__`/`__exit__`)
- Add validation for file size and section boundaries
- Extend architecture support beyond the current five types
- Add methods to extract section data beyond just the interpreter

### Error Handling
The class raises `ELFInvalid` exceptions in these cases:
- Invalid or missing ELF magic number
- Unsupported capacity/encoding combinations
- Corrupted header data that cannot be parsed

## References

- Based on: [ELF Parser Gist](https://gist.github.com/lyssdod/f51579ae8d93c8657a5564aefc2ffbca)
- [ELF Header Specification](https://refspecs.linuxfoundation.org/elf/gabi4+/ch4.eheader.html)