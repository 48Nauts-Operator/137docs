<!-- Auto-generated by Claude on 2025-06-02 06:15 -->

# Linux Platform Tags Module

This module generates manylinux platform tags for Python packages based on the current system's glibc version and architecture compatibility. It's primarily used in packaging tools to determine which manylinux wheels are compatible with the current Linux system.

## Purpose

The module determines:
- The system's glibc version
- Architecture compatibility (ARM, x86, etc.)
- Which manylinux tags the current platform can support

## Key Components

### Constants

```python
EF_ARM_ABIMASK = 0xFF000000
EF_ARM_ABI_VER5 = 0x05000000
EF_ARM_ABI_FLOAT_HARD = 0x00000400
```

ARM-specific ELF header flags used to detect hard-float ABI support.

### Classes

#### `_GLibCVersion`

```python
class _GLibCVersion(NamedTuple):
    major: int
    minor: int
```

A named tuple representing glibc version with major and minor components.

### Core Functions

#### `platform_tags(archs: Sequence[str]) -> Iterator[str]`

**Main entry point** - Generates manylinux tags compatible with the current platform.

- **Parameters**: `archs` - Sequence of compatible architectures (e.g., `['x86_64', 'i686']`)
- **Returns**: Iterator of compatible manylinux tag strings
- **Example output**: `manylinux_2_17_x86_64`, `manylinux2014_x86_64`

#### Glibc Version Detection

- `_glibc_version_string()` - Detects glibc version string
- `_glibc_version_string_confstr()` - Primary implementation using `os.confstr()`
- `_glibc_version_string_ctypes()` - Fallback using ctypes
- `_parse_glibc_version()` - Parses version strings with regex

#### Architecture Detection

- `_is_linux_armhf()` - Detects ARM hard-float ABI from ELF headers
- `_is_linux_i686()` - Detects 32-bit x86 architecture
- `_have_compatible_abi()` - Checks if architectures are supported

#### Compatibility Checking

- `_is_compatible()` - Checks manylinux compatibility using `_manylinux` module
- Handles legacy manylinux standards (manylinux1, manylinux2010, manylinux2014)

### Utility Functions

#### `_parse_elf(path: str)`

Context manager for safely parsing ELF files:

```python
with _parse_elf(executable_path) as elf_file:
    if elf_file is not None:
        # Process ELF file
```

## Legacy Manylinux Support

The module maintains backward compatibility with older manylinux standards:

```python
_LEGACY_MANYLINUX_MAP = {
    (2, 17): "manylinux2014",  # CentOS 7
    (2, 12): "manylinux2010",  # CentOS 6  
    (2, 5): "manylinux1",      # CentOS 5
}
```

## Usage Example

```python
from packaging._manylinux import platform_tags

# Get compatible tags for x86_64 architecture
tags = list(platform_tags(['x86_64']))
# Output: ['manylinux_2_35_x86_64', 'manylinux_2_34_x86_64', ...]
```

## Important Notes

- **Performance**: Uses `@functools.lru_cache` on `_get_glibc_version()` for efficiency
- **Error Handling**: Gracefully handles missing ELF files, unsupported architectures, and glibc detection failures
- **Standards Compliance**: Implements PEP 513, PEP 571, PEP 599, and PEP 600
- **Architecture Support**: Includes support for x86_64, i686, ARM, AArch64, PowerPC, s390x, LoongArch64, and RISC-V

## Dependencies

- Requires `_elffile` module for ELF parsing
- Optional `_manylinux` module for enhanced compatibility checking
- Uses standard library modules: `os`, `re`, `ctypes`, `functools`

## Limitations

- Linux-specific implementation
- Requires glibc-based systems (won't work with musl libc)
- Path type annotations limited to `str` until Python 3.9+ for compatibility