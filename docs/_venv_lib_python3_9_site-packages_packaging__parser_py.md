<!-- Auto-generated by Claude on 2025-06-02 06:15 -->

# Dependency Specifier Parser

This module provides a handwritten recursive descent parser for Python dependency specifiers and marker expressions. It parses requirement strings (like those found in `requirements.txt` or `setup.py`) into structured data that can be programmatically analyzed and manipulated.

## Purpose

The parser handles complex dependency specifications including:
- Package names with optional extras
- Version specifiers (e.g., `>=1.0.0`, `~=2.1`)
- URL-based dependencies
- Environment markers for conditional dependencies

## Core Classes

### Node Hierarchy

The parser uses a node-based AST structure:

#### `Node` (Base Class)
- **Purpose**: Abstract base class for all parser nodes
- **Key Methods**:
  - `serialize()`: Must be implemented by subclasses to convert back to string format
  - `__str__()`, `__repr__()`: Standard string representations

#### `Variable(Node)`
- **Purpose**: Represents environment variables in marker expressions
- **Example**: `python_version`, `platform_system`

#### `Value(Node)` 
- **Purpose**: Represents literal string values in marker expressions
- **Serialization**: Adds quotes around the value

#### `Op(Node)`
- **Purpose**: Represents operators in marker expressions  
- **Examples**: `>=`, `==`, `in`, `not in`

### Data Structures

#### `ParsedRequirement(NamedTuple)`
The main output structure containing:
- `name`: Package name
- `url`: Direct URL (if specified with `@`)
- `extras`: List of optional extras (e.g., `[dev,test]`)
- `specifier`: Version constraints
- `marker`: Environment marker conditions

```python
# Example parsed requirement
ParsedRequirement(
    name="requests",
    url="",
    extras=["security"],
    specifier=">=2.0.0",
    marker=[("python_version", ">=", "3.6")]
)
```

## Main Functions

### `parse_requirement(source: str) -> ParsedRequirement`

**Primary entry point** for parsing dependency specifiers.

```python
# Examples of supported formats:
parse_requirement("requests>=2.0.0")
parse_requirement("django[contrib,auth]>=3.0")  
parse_requirement("package @ https://github.com/user/repo.git")
parse_requirement("numpy>=1.0; python_version>='3.6'")
```

### `parse_marker(source: str) -> MarkerList`

**Entry point** for parsing standalone marker expressions.

```python
# Example usage:
parse_marker("python_version >= '3.6' and platform_system == 'Linux'")
```

## Parser Implementation Details

### Grammar Structure

The parser follows EBNF-inspired grammar rules documented in each `_parse_*` function:

- **Requirements**: `name [extras] [specifier|url] [; marker]`
- **Extras**: `[extra1, extra2, ...]`  
- **Specifiers**: `(>=1.0, <2.0)` or `>=1.0, <2.0`
- **Markers**: `var op value [bool_op var op value ...]`

### Key Internal Functions

#### `_parse_requirement_details()`
Handles the complex logic of parsing either:
- URL dependencies (`@ https://...`)
- Version specifiers with optional markers

#### `_parse_marker()` and `_parse_marker_atom()`
Implement recursive parsing of boolean marker expressions with proper precedence handling.

#### `_parse_extras_list()`
Parses comma-separated extra names with proper error handling for missing commas.

## Utility Functions

### `process_env_var(env_var: str) -> Variable`
- Normalizes environment variable names
- Handles aliases (e.g., `python_implementation` â†’ `platform_python_implementation`)

### `process_python_str(python_str: str) -> Value`  
- Safely evaluates quoted string literals using `ast.literal_eval()`

## Usage Notes

### Error Handling
- Uses a `Tokenizer` class (from `._tokenizer`) for robust token-based parsing
- Provides detailed syntax error messages with position information
- Validates grammar rules and provides context-specific error messages

### Dependencies
- Requires a `Tokenizer` class with `DEFAULT_RULES` from `._tokenizer`
- Uses Python's `ast` module for safe string literal evaluation

### Limitations
- Only handles well-formed dependency specifiers
- Does not perform semantic validation of package names or versions
- Marker expressions are parsed but not evaluated

## Example Usage

```python
# Parse a complex requirement
req = parse_requirement("requests[security,auth]>=2.25.0; python_version>='3.6'")
print(f"Package: {req.name}")
print(f"Extras: {req.extras}")  
print(f"Version: {req.specifier}")
print(f"Marker: {req.marker}")

# Parse just a marker
marker = parse_marker("sys_platform == 'win32' or python_version < '3.8'")
```

This parser is particularly useful for tools that need to analyze Python package dependencies programmatically, such as dependency managers, build systems, or security scanners.