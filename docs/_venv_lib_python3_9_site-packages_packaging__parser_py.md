<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Dependency Specifier Parser

This module provides a handwritten recursive descent parser for Python dependency specifiers and marker expressions. It parses requirement strings (like those found in `requirements.txt` or `setup.py`) into structured data.

## Purpose

The parser handles complex dependency specifications including:
- Package names with extras (e.g., `requests[security]`)
- Version specifiers (e.g., `>=1.0,<2.0`)
- URL-based dependencies (e.g., `package @ https://example.com/package.tar.gz`)
- Environment markers (e.g., `sys_platform == "win32"`)

## Core Classes

### Node Hierarchy

The parser uses a hierarchy of Node classes to represent different components:

```python
class Node:
    """Base class for all parsed nodes"""
    def __init__(self, value: str) -> None
    def serialize(self) -> str  # Abstract method
```

- **`Variable`**: Represents environment variables in markers (e.g., `python_version`)
- **`Value`**: Represents literal values in markers (e.g., `"3.8"`)
- **`Op`**: Represents operators in markers (e.g., `>=`, `in`, `not in`)

### ParsedRequirement

```python
class ParsedRequirement(NamedTuple):
    name: str              # Package name
    url: str               # URL for direct installs
    extras: list[str]      # Optional extras like [dev, test]
    specifier: str         # Version constraints
    marker: MarkerList | None  # Environment markers
```

## Key Functions

### Main Entry Points

#### `parse_requirement(source: str) -> ParsedRequirement`
Parses a complete dependency specifier string.

**Example:**
```python
# Parse: "requests[security]>=2.25.0; python_version >= '3.6'"
result = parse_requirement("requests[security]>=2.25.0; python_version >= '3.6'")
# Returns: ParsedRequirement(
#   name='requests',
#   url='',
#   extras=['security'],
#   specifier='>=2.25.0',
#   marker=[...]
# )
```

#### `parse_marker(source: str) -> MarkerList`
Parses environment marker expressions.

**Example:**
```python
# Parse: "sys_platform == 'win32' and python_version >= '3.6'"
marker = parse_marker("sys_platform == 'win32' and python_version >= '3.6'")
```

### Grammar Implementation

The parser implements EBNF-style grammar rules through private functions:

- **`_parse_requirement()`**: Main requirement parsing
- **`_parse_extras()`**: Handles `[extra1,extra2]` syntax
- **`_parse_specifier()`**: Parses version constraints
- **`_parse_marker()`**: Parses environment markers
- **`_parse_marker_atom()`**: Handles individual marker conditions

## Type Definitions

```python
MarkerVar = Union[Variable, Value]
MarkerItem = Tuple[MarkerVar, Op, MarkerVar]
MarkerAtom = Union[MarkerItem, Sequence["MarkerAtom"]]
MarkerList = Sequence[Union["MarkerList", MarkerAtom, str]]
```

These types represent the hierarchical structure of marker expressions.

## Important Features

### Environment Variable Processing

The parser normalizes environment variables:
- Converts dots to underscores (e.g., `platform.python.implementation` â†’ `platform_python_implementation`)
- Handles special cases for Python implementation names

### Error Handling

The parser provides detailed syntax error messages with position information, helping users identify parsing issues in dependency specifications.

### Flexible Parsing

Supports various dependency formats:
- Simple: `package>=1.0`
- With extras: `package[extra1,extra2]>=1.0`
- With URL: `package @ https://example.com/package.tar.gz`
- With markers: `package>=1.0; sys_platform=="win32"`

## Usage Notes

### Dependencies
- Requires a `_tokenizer` module with `DEFAULT_RULES` and `Tokenizer` class
- Uses Python's `ast` module for safe string literal evaluation

### Recommendations
- Use `parse_requirement()` for complete dependency strings
- Use `parse_marker()` for standalone marker expressions
- Handle `ParsedRequirement` fields appropriately based on your use case

### Limitations
- Relies on external tokenizer for lexical analysis
- Grammar is hardcoded and may need updates for new PEP specifications
- Error messages depend on tokenizer implementation

## Example Usage

```python
# Parse a complex requirement
req = parse_requirement("Django[bcrypt,argon2]>=3.0,<4.0; python_version >= '3.8'")

print(f"Package: {req.name}")           # Django
print(f"Extras: {req.extras}")          # ['bcrypt', 'argon2']
print(f"Version: {req.specifier}")      # >=3.0,<4.0
print(f"Has marker: {req.marker is not None}")  # True

# Parse just a marker
marker = parse_marker("platform_system == 'Linux' and python_version >= '3.9'")
```

This parser is essential for tools that need to understand Python dependency specifications programmatically.