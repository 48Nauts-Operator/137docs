<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Python Metadata Parser Documentation

## Overview

This Python module provides comprehensive functionality for parsing and validating Python package metadata according to the Core Metadata specifications (PEP 241, 314, 345, 566, 643, 685, and 639). It supports metadata versions 1.0 through 2.4 and handles both email-format metadata (like those found in `METADATA` files) and raw metadata dictionaries.

## Purpose

The module serves as a robust parser and validator for Python package metadata, converting raw metadata into structured, validated Python objects. It's designed to be lenient in parsing while strict in validation, making it suitable for tools that need to work with potentially malformed metadata while ensuring compliance with standards.

## Key Components

### Exception Classes

#### `ExceptionGroup`
```python
class ExceptionGroup(Exception)
```
- **Purpose**: Provides compatibility for Python versions < 3.11
- **Usage**: Groups multiple validation exceptions together
- **Attributes**:
  - `message`: Description of the error group
  - `exceptions`: List of individual exceptions

#### `InvalidMetadata`
```python
class InvalidMetadata(ValueError)
```
- **Purpose**: Raised when metadata fields contain invalid data
- **Attributes**:
  - `field`: Name of the field containing invalid data

### Data Structures

#### `RawMetadata`
```python
class RawMetadata(TypedDict, total=False)
```
- **Purpose**: Dictionary representation of raw core metadata
- **Features**:
  - All fields are optional (`total=False`)
  - Field names use lowercase with underscores (e.g., `metadata_version` instead of `Metadata-Version`)
  - Multi-value fields stored as lists or dictionaries
  - Supports all metadata versions from 1.0 to 2.4

**Key Fields**:
- `metadata_version`: Version of metadata specification
- `name`, `version`: Required package identification
- `summary`, `description`: Package description fields
- `requires_dist`: List of package dependencies
- `license_expression`: SPDX license expression (v2.4+)

### Core Functions

#### `parse_email(data: bytes | str) -> tuple[RawMetadata, dict[str, list[str]]]`

Parses metadata from email header format (commonly found in `METADATA` files).

**Parameters**:
- `data`: Raw metadata as bytes or string

**Returns**:
- Tuple containing:
  1. `RawMetadata`: Successfully parsed fields
  2. `dict[str, list[str]]`: Unparsed/invalid fields

**Features**:
- Handles encoding issues gracefully
- Supports both header fields and message body for descriptions
- Processes special fields like keywords and project URLs
- Manages duplicate fields appropriately

```python
# Example usage
with open('METADATA', 'rb') as f:
    raw_metadata, unparsed = parse_email(f.read())
```

### Main Classes

#### `Metadata`

The primary class for working with validated metadata.

**Key Methods**:

##### `from_raw(data: RawMetadata, *, validate: bool = True) -> Metadata`
```python
@classmethod
def from_raw(cls, data: RawMetadata, *, validate: bool = True) -> Metadata
```
- **Purpose**: Creates validated Metadata instance from raw data
- **Parameters**:
  - `data`: Raw metadata dictionary
  - `validate`: Whether to perform validation (default: True)
- **Raises**: `ExceptionGroup` containing all validation errors

##### `from_email(data: bytes | str, *, validate: bool = True) -> Metadata`
```python
@classmethod
def from_email(cls, data: bytes | str, *, validate: bool = True) -> Metadata
```
- **Purpose**: Parses and validates metadata from email format
- **Parameters**:
  - `data`: Raw email-format metadata
  - `validate`: Whether to perform validation (default: True)

**Metadata Fields** (selected examples):
- `metadata_version`: Validated metadata version
- `name`: Package name (validated but not normalized)
- `version`: Parsed as `version_module.Version` object
- `requires_dist`: List of `requirements.Requirement` objects
- `requires_python`: Parsed as `specifiers.SpecifierSet`
- `license_expression`: Normalized license expression

#### `_Validator`

Internal descriptor class that handles field validation and caching.

**Features**:
- Lazy validation and caching
- Type conversion (e.g., strings to Version objects)
- Field-specific validation rules
- Metadata version compatibility checking

## Usage Examples

### Basic Parsing
```python
from packaging import metadata

# Parse from email format
with open('METADATA', 'rb') as f:
    meta = metadata.Metadata.from_email(f.read())

print(f"Package: {meta.name} v{meta.version}")
print(f"Summary: {meta.summary}")
```

### Working with Dependencies
```python
# Access requirements as structured objects
if meta.requires_dist:
    for req in meta.requires_dist:
        print(f"Requires: {req.name} {req.specifier}")
```

### Error Handling
```python
try:
    meta = metadata.Metadata.from_email(malformed_data)
except metadata.ExceptionGroup as eg:
    print(f"Validation errors: {len(eg.exceptions)}")
    for exc in eg.exceptions:
        print(f"  - {exc}")
```

## Important Notes

### Validation Behavior
- **Lenient Parsing**: The parser attempts to extract as much valid data as possible
- **Strict Validation**: When `validate=True`, all fields are thoroughly validated
- **Version Compatibility**: Fields are checked against their introduction version
- **Error Aggregation**: Multiple validation errors are collected and reported together

### Encoding Handling
- Automatically handles various text encodings
- Gracefully degrades to latin1 for problematic encodings
- Separates encoding issues from parsing issues

### Field Processing
- **String Fields**: Single-value text fields
- **List Fields**: Multi-value fields stored as lists
- **Special Processing**: Keywords (comma-separated), Project URLs (label/URL pairs)
- **Type Conversion**: Versions, requirements, and specifiers converted to appropriate objects