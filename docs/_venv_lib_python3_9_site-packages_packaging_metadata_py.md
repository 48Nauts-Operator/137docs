<!-- Auto-generated by Claude on 2025-06-02 06:15 -->

# Python Package Metadata Parser Documentation

## Overview

This Python module provides comprehensive functionality for parsing and validating Python package metadata according to the Core Metadata specification. It handles metadata stored in email header format (such as in `METADATA` files) and converts it into structured, validated Python objects.

## Purpose

The module serves as a robust parser and validator for Python package metadata across multiple specification versions (1.0 through 2.4), providing:

- Parsing of metadata from email header format
- Validation of metadata fields according to specifications
- Type-safe representation of metadata with proper Python objects
- Backward compatibility across different metadata versions

## Key Classes and Functions

### Core Classes

#### `RawMetadata`

A TypedDict representing raw, unprocessed metadata fields.

```python
class RawMetadata(TypedDict, total=False):
    """A dictionary of raw core metadata."""
    metadata_version: str
    name: str
    version: str
    # ... other fields
```

**Key Features:**
- Maps directly to core metadata fields
- Uses underscores instead of dashes (e.g., `author_email` vs `Author-Email`)
- Pluralized names for multi-value fields
- Minimal processing of raw data

#### `Metadata`

The main class providing validated, structured access to metadata.

```python
class Metadata:
    """Representation of distribution metadata."""
```

**Key Features:**
- Validates all metadata fields
- Converts raw strings to appropriate Python types
- Lazy loading with caching of processed values
- Comprehensive validation with detailed error reporting

#### `InvalidMetadata`

Exception class for metadata validation errors.

```python
class InvalidMetadata(ValueError):
    """A metadata field contains invalid data."""
    field: str  # The name of the field that contains invalid data
```

### Key Functions

#### `parse_email(data: bytes | str)`

Parses metadata from email header format.

```python
def parse_email(data: bytes | str) -> tuple[RawMetadata, dict[str, list[str]]]:
    """Parse a distribution's metadata stored as email headers."""
```

**Parameters:**
- `data`: Raw metadata as bytes or string in email header format

**Returns:**
- Tuple of `(parsed_metadata, unparsed_fields)`
- `parsed_metadata`: Successfully parsed fields as `RawMetadata`
- `unparsed_fields`: Fields that couldn't be parsed or are unrecognized

### Validator System

The module uses a sophisticated `_Validator` descriptor system for field validation:

```python
class _Validator(Generic[T]):
    """Validate a metadata field."""
```

**Features:**
- Automatic field name mapping
- Version-aware validation
- Type conversion (e.g., strings to `Version` objects)
- Lazy evaluation with caching

## Usage Examples

### Basic Parsing

```python
# Parse from email header format
metadata_content = """
Metadata-Version: 2.1
Name: example-package
Version: 1.0.0
Summary: An example package
"""

# Create Metadata object with validation
metadata = Metadata.from_email(metadata_content, validate=True)
print(metadata.name)  # "example-package"
print(metadata.version)  # Version('1.0.0')
```

### Handling Raw Metadata

```python
# Work with raw metadata directly
raw_data = {
    'metadata_version': '2.1',
    'name': 'my-package',
    'version': '1.0.0'
}

metadata = Metadata.from_raw(raw_data, validate=True)
```

### Error Handling

```python
try:
    metadata = Metadata.from_email(invalid_data, validate=True)
except ExceptionGroup as exc_group:
    for exc in exc_group.exceptions:
        if isinstance(exc, InvalidMetadata):
            print(f"Invalid field '{exc.field}': {exc}")
```

## Supported Metadata Versions

The module supports metadata versions:
- **1.0** (PEP 241) - Basic metadata
- **1.1** (PEP 314) - Added classifiers, requires/provides
- **1.2** (PEP 345) - Added distribution metadata
- **2.1** (PEP 566) - Added description content type
- **2.2** (PEP 643) - Added dynamic fields
- **2.3** (PEP 685) - Tightened specifications
- **2.4** (PEP 639) - Added license expressions

## Important Notes and Suggestions

### Best Practices

1. **Always validate metadata** when parsing from untrusted sources:
   ```python
   metadata = Metadata.from_email(data, validate=True)
   ```

2. **Handle validation errors gracefully** using ExceptionGroup:
   ```python
   try:
       metadata = Metadata.from_email(data, validate=True)
   except ExceptionGroup as exc_group:
       # Handle multiple validation errors
       pass
   ```

3. **Use raw metadata for inspection** without validation:
   ```python
   raw, unparsed = parse_email(data)
   # Inspect raw data without triggering validation
   ```

### Performance Considerations

- Metadata fields are validated lazily when accessed
- Processed values are cached to avoid recomputation
- Use `from_raw()` when you already have structured data

### Compatibility Notes

- The module includes a Python 3.11+ `ExceptionGroup` backport
- Handles encoding issues gracefully with mojibake detection
- Supports both bytes and string input for flexibility

### Limitations

- Some deprecated fields (requires, provides, obsoletes) have minimal validation
- Project URLs parsing has specific comma-separation requirements
- License file paths are restricted for security (no parent directory access)

This module provides a robust foundation for any Python tooling that needs to work with package metadata, offering both flexibility for parsing varied input formats and strict validation for ensuring metadata compliance.