<!-- Auto-generated by Claude on 2025-06-02 06:15 -->

# Requirement Parser Documentation

## Overview

This module provides functionality for parsing and handling Python package requirements according to **PEP 508** specification. It takes requirement strings (like those found in `requirements.txt` files) and parses them into structured components for programmatic access and manipulation.

## Purpose

The primary purpose of this module is to:
- Parse requirement strings into their constituent parts (name, version specifiers, URLs, extras, markers)
- Validate requirement syntax and raise appropriate errors for malformed requirements
- Provide a standardized way to work with Python package requirements
- Enable comparison and hashing of requirement objects

## Classes

### `InvalidRequirement`

```python
class InvalidRequirement(ValueError):
```

**Purpose**: Custom exception class raised when a requirement string cannot be parsed due to invalid syntax.

**Usage**: Inherits from `ValueError` and indicates that users should refer to PEP 508 for proper requirement string formatting.

### `Requirement`

```python
class Requirement:
```

**Purpose**: Main class for parsing and representing Python package requirements.

#### Constructor

```python
def __init__(self, requirement_string: str) -> None:
```

**Parameters**:
- `requirement_string`: A PEP 508 compliant requirement string (e.g., `"requests>=2.0.0"`, `"Django[extra1,extra2]>=3.0; python_version>='3.8'"`)

**Raises**: `InvalidRequirement` if the requirement string is malformed

#### Attributes

- **`name`** (`str`): The package name
- **`url`** (`str | None`): Direct URL if specified (e.g., for VCS or archive URLs)
- **`extras`** (`set[str]`): Set of optional extras to install
- **`specifier`** (`SpecifierSet`): Version specifiers (e.g., `>=2.0.0, <3.0`)
- **`marker`** (`Marker | None`): Environment markers for conditional installation

#### Methods

##### `_iter_parts(name: str) -> Iterator[str]`

**Purpose**: Internal method that yields string parts of the requirement for reconstruction.

**Parameters**:
- `name`: The package name to use

**Yields**: String components of the requirement in proper order

##### Magic Methods

- **`__str__()`**: Returns the string representation of the requirement
- **`__repr__()`**: Returns a developer-friendly representation
- **`__hash__()`**: Enables use in sets and as dictionary keys (uses canonicalized name)
- **`__eq__()`**: Enables comparison between Requirement objects

## Example Usage

```python
from packaging.requirements import Requirement

# Basic requirement
req1 = Requirement("requests>=2.0.0")
print(req1.name)       # "requests"
print(req1.specifier)  # ">=2.0.0"

# Requirement with extras and markers
req2 = Requirement("Django[extra1,extra2]>=3.0; python_version>='3.8'")
print(req2.name)       # "Django"
print(req2.extras)     # {"extra1", "extra2"}
print(req2.marker)     # python_version>='3.8'

# URL-based requirement
req3 = Requirement("mypackage @ https://github.com/user/repo/archive/main.zip")
print(req3.url)        # "https://github.com/user/repo/archive/main.zip"
```

## Dependencies

This module depends on several internal modules:
- `._parser`: Core parsing functionality
- `._tokenizer`: Tokenization and syntax error handling
- `.markers`: Environment marker handling
- `.specifiers`: Version specifier handling
- `.utils`: Utility functions like name canonicalization

## Notes and Suggestions

### Current Limitations
- **TODO**: The code includes notes about potential future enhancements:
  - Testing whether something is contained within a requirement
  - Determining how to test against both name and version
  - Handling marker evaluation in containment tests

### Best Practices
- Always handle `InvalidRequirement` exceptions when parsing user-provided requirement strings
- Use the parsed components (`name`, `specifier`, etc.) rather than string manipulation for programmatic access
- Leverage the equality and hashing methods for requirement deduplication and comparison

### Error Handling
```python
try:
    req = Requirement("invalid requirement string !!!")
except InvalidRequirement as e:
    print(f"Invalid requirement: {e}")
    # Refer user to PEP 508 specification
```

## License

This file is dual licensed under the Apache License, Version 2.0, and the BSD License. See the LICENSE file in the repository root for complete details.