<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# CacheControlAdapter Documentation

## Overview

The `CacheControlAdapter` is a custom HTTP adapter that extends the functionality of the `requests` library's `HTTPAdapter` to provide intelligent HTTP response caching capabilities. This adapter implements HTTP caching semantics according to RFC 7234, including support for ETags, cache validation, and cache invalidation.

## Purpose

- **HTTP Response Caching**: Automatically cache HTTP responses to reduce network requests and improve performance
- **Cache Validation**: Support for conditional requests using ETags and other cache validation mechanisms
- **Cache Invalidation**: Automatically invalidate cached responses when appropriate HTTP methods are used
- **Flexible Configuration**: Customizable caching behavior through various configuration options

## Key Features

- ✅ Supports configurable cacheable HTTP methods (default: GET)
- ✅ Automatic cache invalidation for PUT, PATCH, DELETE requests
- ✅ ETag-based conditional requests (304 Not Modified handling)
- ✅ Permanent redirect caching (301, 308 status codes)
- ✅ Streaming response support with lazy caching
- ✅ Pluggable cache backends and serialization strategies

## Class: `CacheControlAdapter`

### Constructor Parameters

```python
def __init__(
    self,
    cache: BaseCache | None = None,
    cache_etags: bool = True,
    controller_class: type[CacheController] | None = None,
    serializer: Serializer | None = None,
    heuristic: BaseHeuristic | None = None,
    cacheable_methods: Collection[str] | None = None,
    *args: Any,
    **kw: Any,
) -> None:
```

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `cache` | `BaseCache \| None` | `None` | Cache backend instance (uses `DictCache` if None) |
| `cache_etags` | `bool` | `True` | Enable ETag-based cache validation |
| `controller_class` | `type[CacheController] \| None` | `None` | Custom cache controller class |
| `serializer` | `Serializer \| None` | `None` | Custom response serialization strategy |
| `heuristic` | `BaseHeuristic \| None` | `None` | Cache expiration heuristics |
| `cacheable_methods` | `Collection[str] \| None` | `("GET",)` | HTTP methods to cache |

### Important Methods

#### `send(request, **kwargs) -> Response`

The main method that handles HTTP requests with caching logic.

**Caching Flow:**
1. Check if request method is cacheable
2. Look for cached response
3. Add conditional headers (ETags) if appropriate
4. Send request if no valid cache entry exists
5. Process and potentially cache the response

**Parameters:**
- Standard `HTTPAdapter.send()` parameters
- Additional `cacheable_methods` parameter for per-request override

#### `build_response(request, response, from_cache=False, **kwargs) -> Response`

Constructs the final response object and handles caching logic.

**Key Behaviors:**
- **304 Not Modified**: Updates cached response with new headers
- **Permanent Redirects**: Always cached for future requests  
- **Streaming Responses**: Uses `CallbackFileWrapper` for lazy caching
- **Cache Invalidation**: Removes cache entries for invalidating methods

#### `close() -> None`

Properly closes the cache backend and parent adapter resources.

## Class Attributes

```python
invalidating_methods = {"PUT", "PATCH", "DELETE"}
```

HTTP methods that trigger cache invalidation when they return successful responses.

## Usage Examples

### Basic Usage

```python
import requests
from cachecontrol import CacheControl

# Simple caching with default in-memory cache
session = requests.Session()
cached_session = CacheControl(session)

response = cached_session.get('https://api.example.com/data')
# Subsequent requests will use cached response if still valid
```

### Advanced Configuration

```python
from cachecontrol import CacheControl
from cachecontrol.caches import FileCache
from cachecontrol.heuristics import ExpiresAfter

session = requests.Session()
cached_session = CacheControl(
    session,
    cache=FileCache('.webcache'),
    heuristic=ExpiresAfter(days=1),
    cacheable_methods=['GET', 'HEAD']
)
```

## Implementation Notes

### Cache Validation
- Supports ETag-based validation for efficient cache revalidation
- Handles `304 Not Modified` responses by updating cached entries
- Automatically adds conditional headers (`If-None-Match`, etc.)

### Streaming Support
- Uses `CallbackFileWrapper` to cache responses only after they're fully consumed
- Handles chunked transfer encoding correctly
- Maintains memory efficiency for large responses

### Thread Safety
- Uses `weakref` to prevent circular references
- Cache backend determines thread safety characteristics
- Controller handles concurrent access appropriately

## Recommendations

### Performance Optimization
- Use persistent cache backends (FileCache, RedisCache) for better performance across sessions
- Configure appropriate `cacheable_methods` based on your API usage patterns
- Consider using heuristics for APIs without proper cache headers

### Error Handling
- The adapter gracefully handles `zlib.error` exceptions during cache deserialization
- Failed cache operations don't break the request flow

### Memory Management
- Default `DictCache` is suitable for short-lived sessions
- For long-running applications, use `FileCache` or external cache backends
- The adapter properly releases connections and cleans up resources

## Dependencies

- `pip._vendor.requests`: Core HTTP functionality
- `pip._vendor.cachecontrol.controller`: Cache logic implementation  
- `pip._vendor.cachecontrol.cache`: Cache backend abstractions
- `pip._vendor.cachecontrol.filewrapper`: Streaming response wrapper