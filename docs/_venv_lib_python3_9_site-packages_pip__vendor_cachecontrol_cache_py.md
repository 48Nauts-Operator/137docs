<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Cache Object API Documentation

## Overview

This module provides the foundational API for implementing caches in Python applications. It defines abstract base classes and concrete implementations for caching systems, with the default being a thread-safe in-memory dictionary cache.

## Purpose

The module serves as:
- A standardized interface for cache implementations
- A thread-safe in-memory caching solution
- A foundation for building custom cache backends
- Support for both unified and separate body caching patterns

## Classes

### BaseCache

The abstract base class that defines the standard cache interface.

#### Methods

- **`get(key: str) -> bytes | None`**
  - Retrieves a cached value by key
  - Returns `None` if key doesn't exist
  - Must be implemented by subclasses

- **`set(key: str, value: bytes, expires: int | datetime | None = None) -> None`**
  - Stores a value in the cache with an optional expiration
  - `expires` parameter accepts integer timestamps or datetime objects
  - Must be implemented by subclasses

- **`delete(key: str) -> None`**
  - Removes a key-value pair from the cache
  - Must be implemented by subclasses

- **`close() -> None`**
  - Cleanup method for cache resources
  - Default implementation does nothing

### DictCache

A concrete implementation of `BaseCache` using an in-memory dictionary with thread safety.

#### Features

- Thread-safe operations using `threading.Lock`
- In-memory storage using Python dictionary
- Optional initialization with existing data

#### Constructor

```python
def __init__(self, init_dict: MutableMapping[str, bytes] | None = None) -> None
```

- **`init_dict`**: Optional initial dictionary data

#### Methods

- **`get(key: str) -> bytes | None`**
  - Thread-safe retrieval from internal dictionary
  - No locking required for read operations

- **`set(key: str, value: bytes, expires: int | datetime | None = None) -> None`**
  - Thread-safe storage with lock acquisition
  - Note: `expires` parameter is accepted but not implemented

- **`delete(key: str) -> None`**
  - Thread-safe removal with lock acquisition
  - Safely handles non-existent keys

### SeparateBodyBaseCache

An abstract base class for caches that store metadata and body content separately.

#### Use Case

This pattern is useful for:
- Large response bodies that need different storage strategies
- Streaming scenarios where body content is handled separately
- Memory optimization by separating metadata from large content

#### Usage Pattern

```python
# Setting data
cache.set(key, serialized_metadata)
cache.set_body(key, body_content)

# Getting data
metadata = cache.get(key)
body_stream = cache.get_body(key)
```

#### Methods

- **`set_body(key: str, body: bytes) -> None`**
  - Stores body content separately from metadata
  - Must be implemented by subclasses

- **`get_body(key: str) -> IO[bytes] | None`**
  - Returns body content as a file-like object
  - Enables streaming access to large content
  - Must be implemented by subclasses

## Notes and Suggestions

### Thread Safety
- `DictCache` implements thread safety for write operations
- Read operations (`get`) don't use locks, assuming dictionary read operations are atomic
- Consider your thread safety requirements when implementing custom caches

### Expiration Handling
- The `expires` parameter is defined in the interface but not implemented in `DictCache`
- Custom implementations should handle expiration logic appropriately
- Consider using `datetime` objects for better timezone handling

### Memory Considerations
- `DictCache` stores everything in memory - monitor memory usage for large datasets
- Consider implementing size limits or LRU eviction policies
- `SeparateBodyBaseCache` can help manage memory by storing large bodies separately

### Error Handling
- Current implementations don't raise exceptions for missing keys
- Consider adding validation and error handling in production implementations
- The `close()` method should be called to clean up resources properly

### Example Usage

```python
# Basic usage
cache = DictCache()
cache.set("key1", b"value1")
result = cache.get("key1")  # Returns b"value1"
cache.delete("key1")

# With initial data
initial_data = {"existing_key": b"existing_value"}
cache = DictCache(init_dict=initial_data)
```