<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# FileCache Module Documentation

## Overview

This module provides file-based caching implementations for HTTP responses in the CacheControl library. It offers two variants of file caching: a traditional approach that stores entire responses in memory, and a memory-efficient approach that separates response bodies into separate files.

## Purpose

The FileCache module is designed to:
- Provide persistent caching of HTTP responses to disk
- Reduce memory usage for large downloads through separate body storage
- Ensure thread-safe file operations using file locking
- Generate deterministic file paths using URL hashing

## Classes

### `_FileCacheMixin`

A shared base implementation containing common functionality for both FileCache variants.

#### Key Methods

- **`__init__(directory, forever=False, filemode=0o0600, dirmode=0o0700, lock_class=None)`**
  - Initializes the cache with directory and permission settings
  - Automatically imports `FileLock` if no lock class is provided
  - Raises `ImportError` with installation instructions if `filelock` is unavailable

- **`encode(x: str) -> str`** (static method)
  - Generates SHA224 hash of the input string
  - Used for creating deterministic cache file names

- **`_fn(name: str) -> str`**
  - Creates file path from cache key using hash-based directory structure
  - Implements a 5-level directory hierarchy to avoid filesystem limitations
  - **Note**: This method's behavior should not change as external code may depend on it

- **`_write(path: str, data: bytes) -> None`**
  - Safely writes data to disk using atomic operations
  - Creates necessary directories with proper permissions
  - Uses file locking and temporary files to prevent corruption

### `FileCache`

Traditional file caching implementation that stores complete responses in memory.

```python
cache = FileCache('/path/to/cache/directory')
```

#### Characteristics
- **Pros**: Simple implementation
- **Cons**: Not suitable for large downloads due to memory usage
- **Use case**: Small to medium-sized responses

#### Methods
- **`get(key: str) -> bytes | None`**: Retrieves cached data
- **`set(key: str, value: bytes, expires=None) -> None`**: Stores data in cache
- **`delete(key: str) -> None`**: Removes cached entry

### `SeparateBodyFileCache`

Memory-efficient file caching that stores response headers and bodies separately.

```python
cache = SeparateBodyFileCache('/path/to/cache/directory')
```

#### Characteristics
- **Pros**: Memory-efficient, suitable for large downloads
- **Cons**: Slightly more complex file management
- **Use case**: Large file downloads, memory-constrained environments

#### Additional Methods
- **`get_body(key: str) -> IO[bytes] | None`**: Returns file handle for response body
- **`set_body(key: str, body: bytes) -> None`**: Stores response body separately
- **`delete(key: str) -> None`**: Removes both header and body files

## Utility Functions

### `url_to_file_path(url: str, filecache: FileCache) -> str`

Converts a URL to its corresponding cache file path without checking file existence.

```python
file_path = url_to_file_path("https://example.com/api/data", cache)
```

## Configuration Options

| Parameter | Default | Description |
|-----------|---------|-------------|
| `directory` | Required | Base directory for cache storage |
| `forever` | `False` | If `True`, prevents automatic cache deletion |
| `filemode` | `0o0600` | File permissions for cache files |
| `dirmode` | `0o0700` | Directory permissions for cache directories |
| `lock_class` | `FileLock` | File locking implementation class |

## Dependencies

- **Required**: `filelock` package for thread-safe file operations
- **Installation**: `pip install cachecontrol[filecache]`

## Usage Examples

### Basic FileCache Usage

```python
from cachecontrol.caches.file_cache import FileCache

# Initialize cache
cache = FileCache('/tmp/my_cache')

# Store data
cache.set('my_key', b'response data')

# Retrieve data
data = cache.get('my_key')  # Returns b'response data' or None
```

### Memory-Efficient Cache

```python
from cachecontrol.caches.file_cache import SeparateBodyFileCache

# For large downloads
cache = SeparateBodyFileCache('/tmp/efficient_cache')

# The cache automatically separates headers and body
cache.set('large_file_key', b'header data')
cache.set_body('large_file_key', b'large file content')
```

## Notes and Considerations

- **Thread Safety**: File operations are protected by file locks
- **Atomic Writes**: Uses temporary files and atomic rename operations
- **Directory Structure**: Creates a hash-based directory hierarchy to avoid filesystem limitations
- **Error Handling**: Gracefully handles missing files and permission issues
- **Backward Compatibility**: The `_fn()` method implementation is stable for external dependencies

## Suggestions

1. **Choose the Right Implementation**:
   - Use `FileCache` for small responses (< 1MB)
   - Use `SeparateBodyFileCache` for large files or memory-constrained environments

2. **Directory Management**:
   - Ensure the cache directory has appropriate permissions
   - Consider implementing cache size limits and cleanup policies

3. **Performance**:
   - Place cache directory on fast storage (SSD) for better performance
   - Monitor disk space usage in production environments