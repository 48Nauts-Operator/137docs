<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# CacheController Module Documentation

## Overview

This module provides HTTP caching functionality for the `requests` library, implementing HTTP caching algorithms originally from `httplib2`. It handles caching of HTTP responses according to RFC 7234 standards, including cache-control directives, ETags, and expiration handling.

## Purpose

The module enables efficient HTTP caching by:
- Storing and retrieving HTTP responses based on cache headers
- Implementing proper cache validation using ETags and last-modified dates
- Handling cache-control directives (max-age, no-cache, etc.)
- Supporting conditional requests to minimize bandwidth usage
- Managing cache expiration and freshness calculations

## Key Components

### Classes

#### `CacheController`

The main class that manages HTTP response caching logic.

**Constructor Parameters:**
- `cache`: Cache backend instance (defaults to `DictCache`)
- `cache_etags`: Whether to cache responses with ETags (default: `True`)
- `serializer`: Serializer for cache data (defaults to `Serializer()`)
- `status_codes`: HTTP status codes to cache (default: `(200, 203, 300, 301, 308)`)

### Important Methods

#### `cached_request(request: PreparedRequest) -> HTTPResponse | Literal[False]`

Checks if a cached response exists and is still valid for the given request.

**Returns:**
- Cached `HTTPResponse` if valid cache entry exists
- `False` if no valid cache entry found

**Cache bypass conditions:**
- Request contains `no-cache` directive
- Request has `max-age=0`
- Response is stale and has no ETag

#### `cache_response(request, response_or_ref, body=None, status_codes=None)`

Stores an HTTP response in the cache based on caching rules.

**Caching conditions:**
- Response status code is cacheable
- Response doesn't contain `no-store` directive
- Response has valid cache headers (ETag, expires, max-age)
- Response doesn't have `Vary: *` header

#### `conditional_headers(request: PreparedRequest) -> dict[str, str]`

Generates conditional request headers for cache validation.

**Returns headers:**
- `If-None-Match`: Based on cached ETag
- `If-Modified-Since`: Based on cached Last-Modified date

#### `update_cached_response(request, response) -> HTTPResponse`

Updates cached response headers when receiving a 304 Not Modified response.

### Utility Functions

#### `parse_uri(uri: str) -> tuple[str, str, str, str, str]`

Parses a URI using RFC 3986 regex pattern.

**Returns:** `(scheme, authority, path, query, fragment)`

## Usage Examples

### Basic Usage

```python
from cachecontrol.controller import CacheController
from cachecontrol.cache import DictCache

# Initialize cache controller
cache = DictCache()
controller = CacheController(cache=cache)

# Check for cached response
cached_resp = controller.cached_request(prepared_request)
if cached_resp:
    return cached_resp

# Cache a new response
controller.cache_response(request, response, body=response_body)
```

### Custom Configuration

```python
# Cache only specific status codes
controller = CacheController(
    cache_etags=True,
    status_codes=(200, 301, 404)  # Custom cacheable status codes
)
```

## Cache Control Directives Supported

The module supports standard HTTP cache-control directives:

- **Request directives:** `max-age`, `max-stale`, `min-fresh`, `no-cache`, `no-store`, `only-if-cached`
- **Response directives:** `max-age`, `s-maxage`, `public`, `private`, `no-cache`, `no-store`, `must-revalidate`, `proxy-revalidate`

## Important Notes

### Limitations

- **Partial Content:** Range requests are not cached
- **Vary Header:** Responses with `Vary: *` are never cached
- **Content-Length:** Body size must match Content-Length header for caching

### Cache Freshness Logic

1. **Permanent Redirects:** Always served from cache (301, 308)
2. **ETag Validation:** Cached responses with ETags use conditional requests
3. **Expiration:** Based on `max-age`, `expires` headers, or default values
4. **Staleness:** Stale responses without ETags are purged

### Security Considerations

- Only absolute URIs are cached (security measure)
- URLs are normalized before caching to prevent cache key manipulation
- `no-store` directives are strictly honored

### Performance Notes

- Cache keys are normalized URLs for consistent lookup
- Separate body storage supported for large responses
- Weak references used to prevent memory leaks with streamed responses

## Dependencies

- `requests`: HTTP library
- `urllib3`: HTTP response objects
- `email.utils`: Date parsing utilities
- Standard library modules: `calendar`, `logging`, `re`, `time`, `weakref`