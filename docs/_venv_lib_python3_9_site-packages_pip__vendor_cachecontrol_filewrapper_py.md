<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# CallbackFileWrapper Module

## Overview

This module provides a `CallbackFileWrapper` class that acts as a proxy wrapper around HTTP response file objects. It intercepts all read operations, buffers the data to a temporary file, and executes a callback function with the complete buffered content when the underlying file is closed.

## Purpose

The primary purpose of this wrapper is to:
- **Tee data streams**: Capture all data read from an HTTP response while maintaining transparent access to the underlying file object
- **Execute callbacks**: Trigger a callback function with the complete buffered data when reading is complete
- **Memory efficiency**: Use temporary files with memory mapping to avoid loading large files entirely into memory
- **Transparent proxying**: Provide seamless access to all attributes and methods of the wrapped file object

## Key Features

- **Automatic buffering**: All read data is automatically written to a temporary file
- **Memory-mapped access**: Uses `mmap` for efficient access to buffered data without duplicating memory usage
- **Garbage collection safety**: Prevents deadlocks by breaking circular references
- **Attribute proxying**: Transparently forwards all attribute access to the underlying file object

## Classes

### CallbackFileWrapper

A wrapper class that intercepts read operations on HTTP response objects.

#### Constructor

```python
def __init__(self, fp: HTTPResponse, callback: Callable[[bytes], None] | None) -> None
```

**Parameters:**
- `fp`: The HTTP response object to wrap
- `callback`: Optional callback function that receives the complete buffered data as bytes

#### Key Methods

##### `read(amt: int | None = None) -> bytes`
- Reads data from the underlying file object
- Writes all read data to the internal buffer
- Triggers cleanup when the underlying file is closed
- Returns the data read from the underlying file

##### `_safe_read(amt: int) -> bytes`
- Similar to `read()` but calls the underlying `_safe_read()` method
- Handles special case for CRLF chunk terminators
- Used internally by urllib for HTTP chunk processing

##### `_close() -> None`
- Internal method called when the underlying file is closed
- Executes the callback with buffered data using memory mapping
- Cleans up resources and breaks circular references

## Implementation Details

### Memory Management
- Uses `NamedTemporaryFile` for buffering to leverage filesystem memory cache
- Employs `mmap` for memory-efficient access to buffered data
- Automatically cleans up temporary files to prevent resource leaks

### Attribute Proxying
```python
def __getattr__(self, name: str) -> Any:
    fp = self.__getattribute__("_CallbackFileWrapper__fp")
    return getattr(fp, name)
```
- Uses Python's name mangling with double underscores to avoid attribute conflicts
- Transparently forwards all attribute access to the wrapped file object
- Handles edge cases in garbage collection scenarios

## Usage Notes

### Performance Considerations
- **Small files**: Data typically remains in filesystem memory cache with minimal performance impact
- **Large files**: Data is efficiently stored on disk when memory pressure is high
- **Memory mapping**: Avoids duplicate memory usage when accessing buffered data

### Safety Features
- **Circular reference prevention**: Sets callback to `None` after execution to prevent deadlocks
- **Garbage collection**: Handles edge cases where attributes might not be available during cleanup
- **Resource cleanup**: Automatically closes temporary files to free disk space

## Example Usage

```python
def data_callback(data: bytes) -> None:
    print(f"Received {len(data)} bytes")
    # Process the complete response data

# Wrap an HTTP response
wrapped_response = CallbackFileWrapper(http_response, data_callback)

# Read data normally - callback will be triggered when complete
data = wrapped_response.read()
```

## Notes and Suggestions

- **Thread Safety**: This class is not explicitly thread-safe. Consider synchronization if used in multi-threaded environments
- **Error Handling**: The implementation includes TODO comments suggesting improved logging should be added
- **Memory Monitoring**: For applications processing many large files, monitor temporary file usage
- **Callback Design**: Ensure callback functions are lightweight to avoid blocking the reading process