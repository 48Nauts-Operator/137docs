<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Python Package Metadata Module Documentation

## Overview

This module implements the metadata specification for Python packages according to various Python Enhancement Proposals (PEPs). It supports multiple metadata format versions including 1.0, 1.1, 1.2, 1.3/2.1, and 2.2, providing both reading and writing capabilities for package metadata.

## Purpose

The module handles:
- Reading and writing package metadata in different formats
- Converting between legacy and modern metadata formats
- Validating metadata according to PEP specifications
- Managing package dependencies and requirements
- Supporting both key-value (legacy) and JSON-based metadata formats

## Key Constants

```python
PKG_INFO_ENCODING = 'utf-8'  # Default encoding for PKG-INFO files
PKG_INFO_PREFERRED_VERSION = '1.1'  # Preferred metadata version
```

## Exception Classes

### MetadataMissingError
Raised when required metadata fields are missing.

### MetadataConflictError
Raised when attempting to read or write conflicting metadata fields.

### MetadataUnrecognizedVersionError
Raised when an unknown metadata version is encountered.

### MetadataInvalidError
Raised when a metadata value is invalid.

## Main Classes

### LegacyMetadata

Handles legacy metadata formats (versions 1.0, 1.1, 1.2, 2.0, and 1.3/2.1).

#### Constructor
```python
LegacyMetadata(path=None, fileobj=None, mapping=None, scheme='default')
```

**Parameters:**
- `path`: Path to a metadata file
- `fileobj`: File-like object containing metadata
- `mapping`: Dictionary-like object with metadata
- `scheme`: Version scheme name (default: 'default')

#### Key Methods

##### `read(filepath)`
Reads metadata values from a file path.

##### `write(filepath, skip_unknown=False)`
Writes metadata fields to a file.

##### `get(name, default=None)`
Gets a metadata field value.

##### `set(name, value)`
Sets a metadata field after validation.

##### `check(strict=False)`
Validates metadata compliance. Returns tuple of (missing_fields, warnings).

##### `todict(skip_missing=False)`
Returns fields as a dictionary with underscore-lowercase field names.

##### `get_fullname(filesafe=False)`
Returns the distribution name with version, optionally filename-escaped.

#### Example Usage
```python
# Read from file
metadata = LegacyMetadata(path='PKG-INFO')

# Create from dictionary
data = {'Name': 'mypackage', 'Version': '1.0.0'}
metadata = LegacyMetadata(mapping=data)

# Access fields
name = metadata['Name']
version = metadata.get('Version')

# Validate
missing, warnings = metadata.check(strict=True)
```

### Metadata

Modern metadata implementation using 2.1 metadata format where possible, with fallback to LegacyMetadata for older formats.

#### Constructor
```python
Metadata(path=None, fileobj=None, mapping=None, scheme='default')
```

#### Key Properties

- `name_and_version`: Returns formatted name and version string
- `provides`: List of what the package provides
- `dependencies`: Package dependency information
- `dictionary`: Raw metadata dictionary

#### Key Methods

##### `get_requirements(reqts, extras=None, env=None)`
Gets dependencies based on extras and environment context.

**Parameters:**
- `reqts`: List of requirements
- `extras`: Optional components requested
- `env`: Environment for marker evaluation

##### `validate()`
Validates the metadata according to specifications.

##### `write(path=None, fileobj=None, legacy=False, skip_unknown=True)`
Writes metadata to file in either modern JSON or legacy format.

##### `add_requirements(requirements)`
Adds requirements to the metadata.

#### Example Usage
```python
# Read JSON metadata
metadata = Metadata(path='metadata.json')

# Create new metadata
metadata = Metadata()
metadata.name = 'mypackage'
metadata.version = '1.0.0'
metadata.summary = 'A sample package'

# Get requirements with extras
reqs = metadata.get_requirements(
    metadata.run_requires, 
    extras=['dev'], 
    env={'python_version': '3.8'}
)

# Write as legacy format
metadata.write('PKG-INFO', legacy=True)
```

## Important Functions

### `_best_version(fields)`
Detects the best metadata version based on the fields used.

### `_version2fieldlist(version)`
Returns the list of valid fields for a given metadata version.

### `_get_name_and_version(name, version, for_filename=False)`
Returns formatted distribution name with version, optionally filename-safe.

## Supported Metadata Versions

| Version | Description | Key Features |
|---------|-------------|--------------|
| 1.0 | Basic metadata | Name, Version, Summary, etc. |
| 1.1 | Enhanced metadata | Adds classifiers, download URL |
| 1.2 | PEP 345 | Requires-Dist, environment markers |
| 1.3/2.1 | Extended metadata | Additional project information |
| 2.2 | Latest format | Dynamic fields, license files |

## Usage Notes

- **Encoding**: All metadata files use UTF-8 encoding
- **Validation**: The module performs extensive validation of field values
- **Backward Compatibility**: Automatic conversion between formats when needed
- **Field Names**: Modern format uses underscore_case, legacy uses Hyphen-Case

## Best Practices

1. **Use the Metadata class** for new projects as it handles format detection automatically
2. **Always validate** metadata before writing to catch errors early
3. **Specify scheme** when working with version constraints
4. **Handle exceptions** appropriately when reading potentially malformed metadata

## Example: Complete Workflow

```python
from distlib.metadata import Metadata

# Create new metadata
metadata = Metadata()
metadata.name = 'example-package'
metadata.version = '1.0.0'
metadata.summary = 'An example Python package'
metadata.classifiers = [
    'Development Status :: 4 - Beta',
    'Programming Language :: Python