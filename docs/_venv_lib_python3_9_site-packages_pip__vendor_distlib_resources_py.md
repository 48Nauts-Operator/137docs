<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Resource Management Module Documentation

## Overview

This module provides a comprehensive resource management system for Python packages and modules. It enables finding, accessing, and caching of package resources (such as data files) from both file system and ZIP-based packages. The module handles different import mechanisms and provides a unified interface for resource access.

## Purpose

- **Resource Discovery**: Find resources within Python packages
- **Multiple Source Support**: Handle resources from file systems and ZIP files
- **Caching**: Provide efficient caching mechanisms for resource access
- **Unified Interface**: Abstract away the complexities of different import systems

## Key Classes

### ResourceCache

A caching system for package resources that extends the base `Cache` class.

```python
class ResourceCache(Cache):
    def __init__(self, base=None)
    def is_stale(self, resource, path)
    def get(self, resource)
```

**Key Features:**
- Automatically creates cache directory structure
- Handles cache invalidation (currently always returns stale)
- Extracts resources to filesystem for easy access

### Resource

Represents an individual resource file within a package.

```python
class Resource(ResourceBase):
    def as_stream()
    @cached_property file_path
    @cached_property bytes
    @cached_property size
```

**Key Properties:**
- `bytes`: Raw content of the resource
- `file_path`: Cached filesystem path to the resource
- `size`: Size of the resource in bytes
- `as_stream()`: Returns a readable stream

### ResourceContainer

Represents a directory/container that holds multiple resources.

```python
class ResourceContainer(ResourceBase):
    @cached_property resources
```

**Features:**
- Lists contained resources
- Identifies itself as a container via `is_container = True`

### ResourceFinder

Base finder class for locating resources in file system packages.

```python
class ResourceFinder(object):
    def __init__(self, module)
    def find(self, resource_name)
    def get_stream(self, resource)
    def get_bytes(self, resource) 
    def iterator(self, resource_name)
```

**Key Methods:**
- `find()`: Locate a resource by name
- `get_stream()`: Open resource as binary stream
- `get_bytes()`: Read entire resource content
- `iterator()`: Recursively iterate through resources

### ZipResourceFinder

Specialized finder for resources within ZIP/egg files.

```python
class ZipResourceFinder(ResourceFinder):
    def __init__(self, module)
    def get_cache_info(self, resource)
    def _is_directory(self, path)
```

**Specialized Features:**
- Uses `zipimport` internal structures for efficient lookups
- Binary search through ZIP directory for fast resource location
- Handles ZIP-specific path manipulation

## Important Functions

### finder(package)

Returns a resource finder for a specified package.

```python
def finder(package):
    """
    Return a resource finder for a package.
    :param package: The name of the package.
    :return: A ResourceFinder instance for the package.
    """
```

**Usage:**
```python
pkg_finder = finder('mypackage')
resource = pkg_finder.find('data/config.json')
```

### finder_for_path(path)

Creates a finder for a filesystem path.

```python
def finder_for_path(path):
    """
    Return a resource finder for a path, which should represent a container.
    """
```

### register_finder(loader, finder_maker)

Registers custom finder implementations for specific loader types.

```python
def register_finder(loader, finder_maker):
    _finder_registry[type(loader)] = finder_maker
```

## Configuration and Registry

The module maintains a registry of finder classes mapped to Python loader types:

```python
_finder_registry = {
    type(None): ResourceFinder,
    zipimport.zipimporter: ZipResourceFinder
}
```

Additional loaders from `_frozen_importlib` are automatically registered when available.

## Usage Examples

### Basic Resource Access

```python
# Get a finder for a package
resource_finder = finder('mypackage')

# Find a specific resource
config_resource = resource_finder.find('config/settings.json')

# Access resource content
if config_resource:
    content = config_resource.bytes
    # or as a stream
    with config_resource.as_stream() as f:
        data = f.read()
```

### Iterating Through Resources

```python
# Iterate through all resources in a package
for resource in resource_finder.iterator('data'):
    if not resource.is_container:
        print(f"Found file: {resource.name}")
```

## Important Notes

### Platform Considerations
- **Jython Support**: Automatically excludes `.class` files on Java platform
- **Python 2.x Compatibility**: Handles byte string paths appropriately
- **Cross-platform Paths**: Uses appropriate path separators

### Caching Behavior
- Resources are cached to the filesystem when accessed via `file_path`
- Cache invalidation currently always returns `True` (conservative approach)
- Cache location is automatically determined or can be specified

### Performance
- ZIP resources use binary search for efficient lookups
- Finder instances are cached to avoid repeated initialization
- Properties use `@cached_property` decorator for lazy evaluation

## Limitations and Considerations

1. **Cache Invalidation**: Currently always considers cache stale - may impact performance
2. **Memory Usage**: Large resources are fully loaded into memory when accessing `.bytes`
3. **Thread Safety**: No explicit thread safety mechanisms implemented
4. **Error Handling**: Limited error handling for corrupted or inaccessible resources

## Dependencies

- Standard library modules: `bisect`, `io`, `logging`, `os`, `pkgutil`, `sys`, `types`, `zipimport`
- Internal modules: `.util` (for caching utilities), base exception classes

This module provides a robust foundation for package resource management across different Python deployment scenarios.