<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Distlib Utility Module Documentation

## Overview

This module (`util.py`) is part of the Python Software Foundation's Distlib package distribution and manipulation library. It provides a comprehensive collection of utility functions and classes for handling Python package requirements, file operations, archiving, networking, and various other tasks commonly needed when working with Python distributions.

## Purpose

The module serves as a central utility hub that supports:
- **Requirement parsing** according to PEP 508 specifications
- **File and directory operations** with dry-run support
- **Archive handling** (zip, tar, etc.)
- **Network operations** with SSL/HTTPS support
- **Configuration management**
- **Progress tracking and subprocess management**

## Important Functions and Classes

### Requirement Parsing

#### `parse_requirement(req)`
Parses a requirement string and returns a Container object with requirement components.

**Parameters:**
- `req` (str): A requirement string (e.g., "package>=1.0.0")

**Returns:**
- Container object with attributes: `name`, `extras`, `constraints`, `marker`, `url`, `requirement`

```python
# Example usage
req = parse_requirement("requests>=2.0.0; python_version>='3.6'")
print(req.name)  # "requests"
print(req.constraints)  # [('>=', '2.0.0')]
```

#### `parse_marker(marker_string)`
Parses environment marker expressions used in requirements.

**Parameters:**
- `marker_string` (str): Marker expression string

**Returns:**
- Dictionary representing the parsed marker expression tree

### File Operations

#### `FileOperator` Class
Handles file and directory operations with support for dry-run mode and operation recording.

**Key Methods:**
- `copy_file(infile, outfile, check=True)`: Copy files with safety checks
- `write_text_file(path, data, encoding)`: Write text files with encoding
- `ensure_dir(path)`: Create directories recursively
- `byte_compile(path, optimize=False)`: Compile Python files to bytecode
- `set_executable_mode(files)`: Set executable permissions on files

```python
# Example usage
file_op = FileOperator(dry_run=False)
file_op.copy_file('source.py', 'dest.py')
file_op.ensure_dir('/path/to/new/directory')
```

### Archive Operations

#### `unarchive(archive_filename, dest_dir, format=None, check=True)`
Extracts various archive formats with security checks.

**Supported formats:**
- ZIP files (`.zip`, `.whl`)
- TAR files (`.tar`, `.tar.gz`, `.tgz`, `.tar.bz2`, `.tbz`)

**Parameters:**
- `archive_filename` (str): Path to archive file
- `dest_dir` (str): Destination directory
- `format` (str, optional): Archive format (auto-detected if None)
- `check` (bool): Enable path traversal security checks

### Network and Security

#### `HTTPSConnection` Class
Enhanced HTTPS connection with certificate verification and domain matching.

**Features:**
- Certificate verification
- Domain name matching
- SNI support
- Custom CA certificate support

#### Context Managers

##### `socket_timeout(seconds=15)`
Temporarily sets socket timeout for network operations.

```python
with socket_timeout(30):
    # Network operations with 30-second timeout
    response = urlopen(url)
```

##### `tempdir()`
Creates and automatically cleans up temporary directories.

```python
with tempdir() as td:
    # Use temporary directory
    temp_file = os.path.join(td, 'temp.txt')
    # Directory automatically removed after block
```

### Caching and Performance

#### `cached_property` Decorator
Implements property caching for expensive computations.

```python
class MyClass:
    @cached_property
    def expensive_computation(self):
        # This will only be computed once
        return complex_calculation()
```

#### `Cache` Class
File system cache for resources like shared libraries.

**Methods:**
- `clear()`: Remove all cached items
- `prefix_to_dir(prefix)`: Convert prefix to cache directory name

### Progress Tracking

#### `Progress` Class
Tracks and displays progress for long-running operations.

**Key Properties:**
- `percentage`: Current completion percentage
- `ETA`: Estimated time of completion
- `speed`: Current processing speed

```python
progress = Progress(0, 100)
progress.start()
for i in range(100):
    progress.update(i)
    print(f"Progress: {progress.percentage} - {progress.ETA}")
progress.stop()
```

### Event System

#### `EventMixin` Class
Simple publish/subscribe event system.

**Methods:**
- `add(event, subscriber)`: Add event subscriber
- `remove(event, subscriber)`: Remove event subscriber
- `publish(event, *args, **kwargs)`: Publish event to subscribers

### Subprocess Management

#### `SubprocessMixin` Class
Mixin for running subprocesses with progress tracking.

**Methods:**
- `run_command(cmd, **kwargs)`: Execute command with output capture
- `reader(stream, context)`: Handle subprocess output streams

## Utility Functions

### Platform and Environment

- `in_venv()`: Check if running in virtual environment
- `get_executable()`: Get Python executable path
- `get_host_platform()`: Get platform identifier string
- `get_platform()`: Get platform with cross-compilation support

### String and Path Processing

- `convert_path(pathname)`: Convert Unix-style paths to native format
- `normalize_name(name)`: Normalize package names per PEP 503
- `split_filename(filename)`: Extract name, version from filenames

### Configuration

- `Configurator` Class: Enhanced configuration processing with custom converters
- `PyPIRCFile` Class: Handle PyPI configuration files

## Important Notes and Suggestions

### Security Considerations
- Archive extraction includes path traversal protection
- HTTPS connections verify certificates by default
- File operations include safety checks to prevent overwrites

### Error Handling
- Most functions raise `DistlibException` for library-specific errors
- Network operations may raise `URLError` or `CertificateError`
- File operations include comprehensive error checking