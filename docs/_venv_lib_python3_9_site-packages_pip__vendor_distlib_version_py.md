<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Version Management Module

This module provides a flexible versioning scheme implementation that supports PEP-440, setuptools-compatible, and semantic versioning standards. It allows parsing, comparing, and matching version strings according to different versioning schemes.

## Purpose

The module enables Python applications to:
- Parse version strings in multiple formats
- Compare versions using standard comparison operators
- Match versions against constraint specifications
- Suggest normalized versions for non-standard version strings
- Support different versioning schemes (normalized, legacy, semantic)

## Core Classes

### Base Classes

#### `Version`
Abstract base class for all version implementations.

```python
class Version(object):
    def __init__(self, s):
        self._string = s = s.strip()
        self._parts = parts = self.parse(s)
```

**Key Features:**
- Implements comparison operators (`==`, `!=`, `<`, `>`, `<=`, `>=`)
- Provides `is_prerelease` property (must be implemented by subclasses)
- Ensures type compatibility for comparisons

#### `Matcher`
Abstract base class for version matching against constraints.

```python
class Matcher(object):
    version_class = None
    _operators = {
        '<': lambda v, c, p: v < c,
        '>': lambda v, c, p: v > c,
        # ... more operators
    }
```

**Key Features:**
- Parses requirement strings with constraints
- Supports multiple comparison operators
- Provides `match()` method for version validation
- Handles prefix matching for partial versions (e.g., "2.1.*")

### Concrete Implementations

#### `NormalizedVersion`
PEP-440 compliant version implementation.

```python
class NormalizedVersion(Version):
    """A rational version following PEP-440 standards."""
```

**Supported Formats:**
- `1.2.0` - Standard release
- `1.2a1` - Alpha releases
- `1.2.3b1` - Beta releases  
- `1.2.3c1` - Release candidates
- `1.2.dev123` - Development releases
- `1.2+local.1` - Local versions

#### `LegacyVersion`
Backward-compatible version handling for older setuptools formats.

```python
class LegacyVersion(Version):
    def parse(self, s):
        return _legacy_key(s)
```

#### `SemanticVersion`
Semantic versioning (semver) implementation.

```python
class SemanticVersion(Version):
    """Semantic versioning: MAJOR.MINOR.PATCH[-prerelease][+build]"""
```

**Format:** `X.Y.Z[-prerelease][+build]`
- Example: `1.2.3-alpha.1+build.123`

## Important Functions

### Version Parsing and Validation

#### `get_scheme(name)`
Returns a version scheme by name.

```python
scheme = get_scheme('normalized')  # or 'legacy', 'semantic'
```

#### `is_semver(s)`
Checks if a string is a valid semantic version.

```python
if is_semver('1.2.3-alpha'):
    # Handle semantic version
```

### Version Suggestion Functions

#### `_suggest_normalized_version(s)`
Attempts to convert non-standard version strings to PEP-440 format.

```python
# Converts various formats:
# "1.0-alpha" -> "1.0a0"  
# "v2.1" -> "2.1"
# "1.0dev" -> "1.0.dev0"
```

#### `_suggest_semantic_version(s)`
Suggests semantic version format for invalid version strings.

## Usage Examples

### Basic Version Comparison

```python
from version import NormalizedVersion

v1 = NormalizedVersion('1.2.0')
v2 = NormalizedVersion('1.2.1')

print(v1 < v2)  # True
print(v1.is_prerelease)  # False
```

### Version Matching

```python
from version import NormalizedMatcher

matcher = NormalizedMatcher('package (>=1.0, <2.0)')
version = NormalizedVersion('1.5.0')

print(matcher.match(version))  # True
```

### Using Version Schemes

```python
from version import get_scheme

scheme = get_scheme('normalized')
if scheme.is_valid_version('1.2.3a1'):
    version = scheme.matcher.version_class('1.2.3a1')
```

## Available Version Schemes

| Scheme | Key | Description |
|--------|-----|-------------|
| `normalized` | `_normalized_key` | PEP-440 compliant (default) |
| `legacy` | `_legacy_key` | Setuptools-compatible |
| `semantic` | `_semantic_key` | Semantic versioning |
| `default` | - | Alias for `normalized` |

## Notes and Suggestions

### Best Practices
- Use `normalized` scheme for new Python projects (PEP-440 compliant)
- Use `legacy` scheme only for backward compatibility
- Use `semantic` scheme for projects following semver standards

### Error Handling
- All invalid version strings raise `UnsupportedVersionError`
- Type mismatches in comparisons raise `TypeError`
- Use suggestion functions to handle malformed version strings

### Performance Considerations
- Version objects cache parsed components for efficient comparison
- Regex patterns are pre-compiled for better performance
- Hash implementation allows versions to be used as dictionary keys

### Limitations
- Prefix matching with `.*` only works with `==` and `!=` operators
- Local version components require special handling in some comparisons
- Legacy version parsing may not handle all edge cases perfectly

This module provides a robust foundation for version management in Python applications, supporting multiple versioning standards while maintaining compatibility and performance.