<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# ELF File Parser

## Overview

This module provides a Python parser for ELF (Executable and Linkable Format) files, commonly used on Unix-like systems. The parser offers a read-only interface similar to Python's `ZipFile` class, allowing you to extract information from ELF executables without modifying them.

## Purpose

The ELF parser is designed to:
- Parse ELF file headers and extract metadata
- Identify system architecture and encoding information  
- Extract interpreter path information from executables
- Provide a simple, Pythonic interface for ELF file analysis

## Classes and Enums

### Exception Classes

#### `ELFInvalid`
```python
class ELFInvalid(ValueError):
    pass
```
- **Purpose**: Custom exception raised when ELF file parsing fails
- **Usage**: Thrown for invalid magic numbers, corrupted headers, or unsupported formats

### Enumerations

#### `EIClass`
```python
class EIClass(enum.IntEnum):
    C32 = 1  # 32-bit format
    C64 = 2  # 64-bit format
```
- **Purpose**: Defines ELF file capacity (bitness)

#### `EIData` 
```python
class EIData(enum.IntEnum):
    Lsb = 1  # Little-endian
    Msb = 2  # Big-endian
```
- **Purpose**: Defines data encoding (endianness)

#### `EMachine`
```python
class EMachine(enum.IntEnum):
    I386 = 3      # Intel 80386
    S390 = 22     # IBM S/390
    Arm = 40      # ARM
    X8664 = 62    # AMD x86-64
    AArc64 = 183  # ARM 64-bit
```
- **Purpose**: Defines supported processor architectures

### Main Class

#### `ELFFile`

The primary class for parsing ELF files.

##### Constructor
```python
def __init__(self, f: IO[bytes]) -> None
```
- **Parameters**: `f` - File-like object opened in binary mode
- **Raises**: `ELFInvalid` if file is not a valid ELF file
- **Purpose**: Parses ELF header and initializes file metadata

##### Properties

- `capacity`: File bitness (32-bit or 64-bit)
- `encoding`: Data endianness (little-endian or big-endian) 
- `machine`: Target processor architecture
- `flags`: Processor-specific flags

##### Methods

###### `interpreter` Property
```python
@property
def interpreter(self) -> str | None
```
- **Returns**: Path to the dynamic linker/interpreter, or `None` if not found
- **Purpose**: Extracts the interpreter path from the `PT_INTERP` program header
- **Usage**: Useful for determining which dynamic linker an executable requires

## Usage Example

```python
with open('/bin/ls', 'rb') as f:
    elf = ELFFile(f)
    print(f"Architecture: {elf.machine}")
    print(f"Bitness: {elf.capacity}")
    print(f"Endianness: {elf.encoding}")
    print(f"Interpreter: {elf.interpreter}")
```

## Implementation Notes

### Supported Formats
The parser supports the following ELF format combinations:
- 32-bit Little-endian
- 32-bit Big-endian  
- 64-bit Little-endian
- 64-bit Big-endian

### Error Handling
- Validates ELF magic number (`\x7fELF`) 
- Handles struct unpacking errors gracefully
- Provides meaningful error messages through `ELFInvalid` exceptions

### Limitations
- **Read-only**: No support for modifying ELF files
- **Limited parsing**: Only extracts basic header information and interpreter path
- **No section parsing**: Does not parse individual ELF sections beyond program headers

## References

- Based on: https://gist.github.com/lyssdod/f51579ae8d93c8657a5564aefc2ffbca
- ELF specification: https://refspecs.linuxfoundation.org/elf/gabi4+/ch4.eheader.html

## Suggestions for Enhancement

1. **Add section parsing**: Extend to parse individual ELF sections (.text, .data, etc.)
2. **Symbol table support**: Add methods to extract symbol information
3. **Dependency analysis**: Parse dynamic section to extract library dependencies  
4. **Validation methods**: Add utilities to verify ELF file integrity
5. **Context manager**: Implement `__enter__`/`__exit__` for automatic file handling