<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Manylinux Platform Tags Generator

This Python module generates manylinux platform tags that are compatible with the current Linux platform. It's designed to help determine which manylinux wheels can be installed on a given system by analyzing the system's glibc version and architecture compatibility.

## Purpose

The module serves as part of a Python package installation system (likely pip or similar) to:
- Detect the current system's glibc version
- Determine architecture compatibility through ELF file analysis
- Generate appropriate manylinux tags for wheel selection
- Support legacy manylinux standards (manylinux1, manylinux2010, manylinux2014)

## Key Components

### Constants

```python
EF_ARM_ABIMASK = 0xFF000000
EF_ARM_ABI_VER5 = 0x05000000
EF_ARM_ABI_FLOAT_HARD = 0x00000400
```
- ARM-specific ELF flags for detecting hard-float ABI compatibility

### Core Classes

#### `_GLibCVersion`
```python
class _GLibCVersion(NamedTuple):
    major: int
    minor: int
```
A named tuple representing glibc version with major and minor components.

### Important Functions

#### `platform_tags(archs: Sequence[str]) -> Iterator[str]`
**Main public function** that generates manylinux tags compatible with the current platform.

- **Parameters**: `archs` - Sequence of compatible architectures (e.g., `["x86_64"]`)
- **Returns**: Iterator of compatible manylinux tags
- **Example output**: `"manylinux_2_17_x86_64"`, `"manylinux2014_x86_64"`

#### Architecture Detection Functions

- **`_is_linux_armhf(executable: str) -> bool`**
  - Detects ARM hard-float ABI from ELF headers
  - Follows ARM EABI specification

- **`_is_linux_i686(executable: str) -> bool`**
  - Detects 32-bit x86 architecture

- **`_have_compatible_abi(executable: str, archs: Sequence[str]) -> bool`**
  - Determines if the system has compatible ABI for given architectures
  - Supports: `x86_64`, `aarch64`, `ppc64`, `ppc64le`, `s390x`, `loongarch64`, `riscv64`

#### Glibc Version Detection

- **`_glibc_version_string() -> str | None`**
  - Primary detection using `os.confstr()` 
  - Fallback to `ctypes` approach
  - Returns version string like `"2.17"` or `None`

- **`_get_glibc_version() -> tuple[int, int]`**
  - Cached function returning glibc major/minor version tuple
  - Uses `@functools.lru_cache` for performance

### Helper Functions

#### `_parse_elf(path: str) -> Generator[ELFFile | None, None, None]`
Context manager for safely parsing ELF files with error handling.

#### `_is_compatible(arch: str, version: _GLibCVersion) -> bool`
Checks compatibility with manylinux standards, including support for the `_manylinux` module.

## Legacy Support

The module maintains backward compatibility with older manylinux standards:

```python
_LEGACY_MANYLINUX_MAP = {
    (2, 17): "manylinux2014",  # CentOS 7
    (2, 12): "manylinux2010",  # CentOS 6  
    (2, 5): "manylinux1",      # CentOS 5
}
```

## Usage Example

```python
from manylinux import platform_tags

# Generate tags for x86_64 architecture
tags = list(platform_tags(["x86_64"]))
print(tags)
# Output: ['manylinux_2_35_x86_64', 'manylinux_2_34_x86_64', ...]
```

## Notes and Considerations

- **Performance**: Uses `@functools.lru_cache` for expensive glibc version detection
- **Error Handling**: Gracefully handles missing ELF files, import errors, and parsing failures
- **Architecture Priority**: First architecture in the sequence should be closest to actual system architecture
- **Glibc Compatibility**: Assumes forward compatibility across glibc versions
- **Future-Proofing**: Uses defaultdict with estimated maximum minor versions for future glibc releases

## Dependencies

- Requires `_elffile` module for ELF parsing
- Optional `_manylinux` module for enhanced compatibility checking
- Standard library modules: `os`, `sys`, `ctypes`, `re`, `collections`, `functools`

## Warnings

The module may emit `RuntimeWarning` if glibc version parsing fails, indicating an unexpected version format.