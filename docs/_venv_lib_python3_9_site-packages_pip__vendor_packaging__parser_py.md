<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Dependency Specifier Parser

This module provides a handwritten recursive descent parser for Python dependency specifiers and marker expressions. It parses package requirements with version specifiers, extras, URLs, and environment markers according to PEP 508 and related specifications.

## Purpose

The parser converts string representations of Python package dependencies into structured data that can be programmatically processed. It handles complex dependency specifications including:

- Package names with optional extras
- Version specifiers and constraints
- URLs for direct package installation
- Environment markers for conditional dependencies

## Core Classes

### Node Hierarchy

The parser uses a hierarchy of `Node` classes to represent different components:

```python
class Node:
    def __init__(self, value: str) -> None:
        self.value = value
    
    def serialize(self) -> str:
        raise NotImplementedError
```

#### Node Types

- **`Variable`**: Represents environment variables in markers (e.g., `python_version`)
- **`Value`**: Represents literal values in markers (e.g., `"3.8"`)  
- **`Op`**: Represents operators in markers (e.g., `>=`, `in`, `not in`)

### ParsedRequirement

A `NamedTuple` that represents the complete parsed result:

```python
class ParsedRequirement(NamedTuple):
    name: str           # Package name
    url: str           # Direct URL (if specified)
    extras: list[str]  # Optional extras like [dev,test]
    specifier: str     # Version specifier like >=1.0,<2.0
    marker: MarkerList | None  # Environment marker expression
```

## Main Functions

### `parse_requirement(source: str) -> ParsedRequirement`

**Primary entry point** for parsing dependency specifiers.

```python
# Example usage
req = parse_requirement("requests[security]>=2.25.0; python_version>='3.6'")
# Returns: ParsedRequirement(
#     name='requests',
#     url='',
#     extras=['security'],
#     specifier='>=2.25.0',
#     marker=[...]
# )
```

### `parse_marker(source: str) -> MarkerList`

**Entry point** for parsing standalone marker expressions.

```python
# Example usage  
marker = parse_marker("python_version >= '3.8' and platform_system == 'Linux'")
```

## Parser Implementation

The parser follows **EBNF grammar rules** documented in each `__parse_*` function's docstring. Key parsing functions include:

### Requirement Parsing

- **`_parse_requirement()`**: Main requirement parser following the grammar:
  ```
  requirement = WS? IDENTIFIER WS? extras WS? requirement_details
  ```

- **`_parse_requirement_details()`**: Handles URL or version specifier parsing:
  ```
  requirement_details = AT URL (WS requirement_marker?)?
                      | specifier WS? (requirement_marker)?
  ```

### Component Parsers

- **`_parse_extras()`**: Parses optional extras in brackets `[extra1,extra2]`
- **`_parse_specifier()`**: Parses version constraints `>=1.0,<2.0` 
- **`_parse_version_many()`**: Handles comma-separated version specifiers

### Marker Expression Parsing

- **`_parse_marker()`**: Parses boolean expressions with `and`/`or`
- **`_parse_marker_atom()`**: Parses individual comparisons or parenthesized expressions
- **`_parse_marker_item()`**: Parses `variable operator value` triplets

## Key Features

### Grammar-Based Parsing
Each parser function includes its grammar rule in EBNF notation, making the implementation self-documenting.

### Error Handling
The parser provides detailed syntax error messages with position information through the underlying `Tokenizer`.

### Flexible Input Support
Handles various dependency specification formats:
- Simple: `requests`
- With version: `requests>=2.25.0`
- With extras: `requests[security,socks]`
- With URL: `requests @ https://github.com/psf/requests/archive/main.zip`
- With markers: `requests>=2.25.0; python_version>='3.6'`

## Usage Notes

- The parser depends on a `Tokenizer` class (from `._tokenizer`) that handles lexical analysis
- Environment variable names are normalized (e.g., `python.version` â†’ `python_version`)
- String literals in markers are processed using `ast.literal_eval()` for safety
- The parser enforces PEP 508 compliance for dependency specifications

## Suggestions

- **Error Recovery**: Consider adding error recovery mechanisms for partial parsing
- **Validation**: Add semantic validation beyond syntax checking (e.g., valid version formats)
- **Performance**: For high-volume parsing, consider caching tokenization rules
- **Extensions**: The modular design makes it easy to extend for custom dependency formats