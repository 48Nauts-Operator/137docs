<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Python Metadata Parser Documentation

## Overview

This Python module provides functionality for parsing and validating Python package metadata according to the Core Metadata specifications (PEP 241, PEP 314, PEP 345, PEP 566, PEP 643, PEP 685, PEP 639). It handles metadata stored in email header format (commonly found in `METADATA` files) and converts it into structured Python objects with proper validation and type conversion.

## Purpose

The module serves as a comprehensive metadata parser that:
- Parses Python package metadata from email header format
- Validates metadata fields according to their specifications
- Converts raw string data into appropriate Python types
- Handles multiple metadata specification versions (1.0 through 2.4)
- Provides detailed error reporting for invalid metadata

## Key Classes and Functions

### Exception Classes

#### `ExceptionGroup`
A compatibility implementation of Python 3.11's `ExceptionGroup` for older Python versions.

```python
class ExceptionGroup(Exception):
    message: str
    exceptions: list[Exception]
```

#### `InvalidMetadata`
Exception raised when metadata contains invalid data.

```python
class InvalidMetadata(ValueError):
    field: str  # The name of the field with invalid data
```

### Core Data Structures

#### `RawMetadata`
A TypedDict representing raw, unprocessed metadata fields.

```python
class RawMetadata(TypedDict, total=False):
    # Contains all possible metadata fields as key-value pairs
    # Field names are normalized (lowercase, underscores instead of dashes)
    metadata_version: str
    name: str
    version: str
    # ... many more fields
```

**Key characteristics:**
- Field names are normalized to lowercase with underscores
- Multi-value fields are stored as lists or dictionaries
- Corresponds directly to core metadata specification fields

#### `Metadata`
High-level representation of distribution metadata with validation and type conversion.

```python
class Metadata:
    """Representation of distribution metadata with validation and enriched types."""
    
    @classmethod
    def from_raw(cls, data: RawMetadata, *, validate: bool = True) -> Metadata:
        """Create instance from RawMetadata with optional validation."""
    
    @classmethod
    def from_email(cls, data: bytes | str, *, validate: bool = True) -> Metadata:
        """Parse metadata from email headers with optional validation."""
```

**Features:**
- Automatic type conversion (e.g., version strings to `Version` objects)
- Field validation according to metadata specifications  
- Version-aware field checking
- Lazy evaluation with caching

### Parsing Functions

#### `parse_email(data: bytes | str) -> tuple[RawMetadata, dict[str, list[str]]]`
Main parsing function that converts email header format to structured data.

```python
def parse_email(data: bytes | str) -> tuple[RawMetadata, dict[str, list[str]]]:
    """
    Parse distribution metadata from email headers.
    
    Returns:
        tuple: (parsed_metadata, unparsed_fields)
    """
```

**Returns:**
- First element: Successfully parsed and recognized metadata fields
- Second element: Unparsed or unrecognized fields

### Validator System

#### `_Validator[T]`
Generic descriptor class that handles field validation and type conversion.

```python
class _Validator(Generic[T]):
    """Validate and convert metadata fields."""
    
    def _process_field_name(self, value: Any) -> T:
        """Process and validate specific field types."""
```

**Key validation methods:**
- `_process_name()`: Validates package names using canonicalization
- `_process_version()`: Converts to `Version` objects with validation  
- `_process_requires_dist()`: Parses requirement specifications
- `_process_license_expression()`: Validates license expressions
- Many others for specific field types

## Usage Examples

### Basic Parsing

```python
# Parse from email format
metadata_content = """
Metadata-Version: 2.1
Name: my-package
Version: 1.0.0
Summary: A sample package
"""

# Parse raw metadata
raw_metadata, unparsed = parse_email(metadata_content)

# Create validated Metadata object  
metadata = Metadata.from_email(metadata_content, validate=True)
print(metadata.name)  # "my-package"
print(metadata.version)  # Version object
```

### Handling Validation Errors

```python
try:
    metadata = Metadata.from_email(invalid_metadata, validate=True)
except ExceptionGroup as eg:
    for exc in eg.exceptions:
        if isinstance(exc, InvalidMetadata):
            print(f"Invalid field '{exc.field}': {exc}")
```

## Important Constants

### Supported Metadata Versions
```python
_VALID_METADATA_VERSIONS = ["1.0", "1.1", "1.2", "2.1", "2.2", "2.3", "2.4"]
```

### Field Categories
- `_STRING_FIELDS`: Single-value string fields
- `_LIST_FIELDS`: Multi-value list fields  
- `_DICT_FIELDS`: Dictionary-type fields (like project URLs)

## Notes and Considerations

### Encoding Handling
- Supports both bytes and string input
- Handles various character encodings gracefully
- Falls back to Latin-1 for problematic encodings to avoid data loss

### Backward Compatibility
- Supports metadata versions from 1.0 to 2.4
- Validates fields against their introduction version
- Maintains compatibility with older metadata formats

### Error Handling
- Lenient parsing approach - attempts to extract usable data even from malformed input
- Comprehensive validation with detailed error messages
- Groups related validation errors for better debugging

### Performance
- Lazy evaluation of metadata fields
- Caching of processed values
- Minimal data transformation during initial parsing

## Suggestions for Usage

1. **Always use validation** in production code to catch metadata issues early
2. **Handle ExceptionGroup properly** when validation is enabled
3. **Check unparsed fields** from `parse_email()` for unrecognized metadata
4. **Use appropriate error handling** for `InvalidMetadata` exceptions
5. **Consider metadata