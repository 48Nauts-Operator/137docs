<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Requirement Parser Module

This module provides functionality for parsing and handling Python package requirements according to PEP 508 specification. It allows you to parse requirement strings (like those found in `requirements.txt` files) into structured objects that can be programmatically analyzed and manipulated.

## Purpose

The module's primary purpose is to:
- Parse requirement strings into their constituent parts (name, version specifiers, URLs, extras, markers)
- Provide a structured representation of Python package requirements
- Validate requirement syntax and raise appropriate errors for malformed requirements
- Enable comparison and hashing of requirement objects

## Classes

### `InvalidRequirement`

```python
class InvalidRequirement(ValueError):
```

**Purpose**: Custom exception class for handling malformed requirement strings.

- **Inherits from**: `ValueError`
- **Usage**: Raised when a requirement string cannot be parsed due to syntax errors
- **Reference**: Users should refer to PEP 508 for proper requirement string formatting

### `Requirement`

```python
class Requirement:
```

**Purpose**: Main class for parsing and representing Python package requirements.

#### Constructor

```python
def __init__(self, requirement_string: str) -> None:
```

**Parameters**:
- `requirement_string`: A string representing a package requirement (e.g., `"requests>=2.0.0"`, `"django[extra1,extra2]>=3.0"`)

**Raises**:
- `InvalidRequirement`: When the requirement string is malformed

#### Attributes

- **`name`** (`str`): The package name
- **`url`** (`str | None`): Direct URL if specified (e.g., for VCS or direct downloads)
- **`extras`** (`set[str]`): Set of optional extras requested
- **`specifier`** (`SpecifierSet`): Version specifiers (e.g., `>=2.0.0`, `~=1.4`)
- **`marker`** (`Marker | None`): Environment markers for conditional installation

#### Methods

##### `_iter_parts(name: str) -> Iterator[str]`

**Purpose**: Internal method that yields string parts of the requirement for reconstruction.

**Parameters**:
- `name`: The package name to use

**Yields**: String components of the requirement in proper order

##### Magic Methods

- **`__str__()`**: Returns the string representation of the requirement
- **`__repr__()`**: Returns a detailed string representation for debugging
- **`__hash__()`**: Enables hashing of requirement objects (uses canonicalized name)
- **`__eq__()`**: Enables comparison between requirement objects

## Usage Examples

```python
from packaging.requirements import Requirement, InvalidRequirement

# Basic requirement
req = Requirement("requests>=2.0.0")
print(req.name)        # "requests"
print(req.specifier)   # >=2.0.0

# Requirement with extras
req = Requirement("django[extra1,extra2]>=3.0")
print(req.extras)      # {"extra1", "extra2"}

# Requirement with URL
req = Requirement("package @ https://github.com/user/repo/archive/main.zip")
print(req.url)         # "https://github.com/user/repo/archive/main.zip"

# Requirement with markers
req = Requirement('requests>=2.0.0; python_version>="3.6"')
print(req.marker)      # python_version>="3.6"

# Error handling
try:
    req = Requirement("invalid requirement string!")
except InvalidRequirement as e:
    print(f"Invalid requirement: {e}")
```

## Dependencies

This module depends on several internal modules:
- `._parser`: For parsing requirement strings
- `._tokenizer`: For tokenization and syntax error handling
- `.markers`: For handling environment markers
- `.specifiers`: For version specifier handling
- `.utils`: For name canonicalization utilities

## Notes and Suggestions

### Current Limitations
- The code includes TODO comments indicating areas for potential enhancement:
  - Testing containment within requirements
  - Enhanced name and extra name normalization

### Best Practices
- Always wrap requirement parsing in try-catch blocks to handle `InvalidRequirement` exceptions
- Use the structured attributes (`name`, `specifier`, `extras`, etc.) rather than parsing strings manually
- Requirements are hashable and comparable, making them suitable for use in sets and dictionaries

### Performance Considerations
- The parsing is done once during initialization, so accessing attributes is efficient
- Hash computation uses canonicalized names for consistent behavior
- String reconstruction is done on-demand via `_iter_parts()`