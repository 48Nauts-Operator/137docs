<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Text Wrapping Module

This Python module provides text wrapping functionality for terminal applications, with support for proper handling of text that may contain Unicode characters with varying display widths (such as CJK characters). It's designed to work with console output where character display width matters more than string length.

## Purpose

The module handles intelligent text wrapping by:
- Breaking text into words while preserving whitespace
- Calculating proper display widths using cell-based measurements
- Supporting word folding for long words that exceed line width
- Handling Unicode characters that may take up different display widths

## Dependencies

```python
from ._loop import loop_last
from .cells import cell_len, chop_cells
```

- `loop_last`: Utility for iterating with last-item detection
- `cell_len`: Function to measure display width of text in terminal cells
- `chop_cells`: Function to split text at specific cell widths

## Functions

### `words(text: str) -> Iterable[tuple[int, int, str]]`

Tokenizes text into words with their positions.

**Parameters:**
- `text`: Input string to tokenize

**Returns:**
- Iterator yielding tuples of `(start_index, end_index, word)`
- Each "word" includes the actual word plus any trailing whitespace

**Example:**
```python
for start, end, word in words("hello world"):
    print(f"'{word}' at positions {start}-{end}")
# Output: 'hello ' at positions 0-6, 'world' at positions 6-11
```

### `divide_line(text: str, width: int, fold: bool = True) -> list[int]`

Determines where to break a line of text to fit within a specified width.

**Parameters:**
- `text`: The text string to analyze
- `width`: Maximum width in terminal cells
- `fold`: Whether to fold long words across multiple lines (default: True)

**Returns:**
- List of character indices where line breaks should be inserted

**Behavior:**
- **Word fits**: Places word on current line
- **Word too long + folding enabled**: Splits word across multiple lines
- **Word too long + folding disabled**: Crops the word
- **Word fits on new line**: Moves word to next line

## Algorithm Details

The `divide_line` function uses a greedy approach:

1. **Iterate through words** using the `words()` function
2. **Check if word fits** in remaining space on current line
3. **Handle overflow cases:**
   - If word is longer than total width and folding is enabled, split it
   - If word fits on a new line, break before the word
   - If folding is disabled, allow overflow

## Usage Examples

### Basic Text Wrapping
```python
text = "This is a long line that needs wrapping"
breaks = divide_line(text, width=10)
# Returns indices where line breaks should occur
```

### Handling Long Words
```python
# With folding (default)
breaks = divide_line("supercalifragilisticexpialidocious", width=10, fold=True)

# Without folding
breaks = divide_line("supercalifragilisticexpialidocious", width=10, fold=False)
```

## Notes and Considerations

- **Unicode Support**: Uses `cell_len` instead of `len()` to properly handle wide characters
- **Whitespace Handling**: Preserves whitespace patterns in the original text
- **Performance**: Optimizes by caching the `cell_len` function reference
- **Edge Cases**: Handles empty lines, single words longer than width, and mixed character widths

## Demo Code

The module includes demo code showing:
- Text wrapping with different console widths
- Handling of very long words
- Support for Unicode text (Japanese characters)

```python
console = Console(width=10)
console.print("12345 abcdefghijklmnopqrstuvwyxzABCDEFGHIJKLMNOPQRSTUVWXYZ 12345")
```

This module is particularly useful for terminal-based applications that need to display formatted text with proper line wrapping while respecting the visual width constraints of the terminal.