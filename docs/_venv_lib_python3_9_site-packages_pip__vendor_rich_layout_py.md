<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Layout Module Documentation

## Overview

This module provides a flexible layout system for dividing terminal screen space into regions. It allows you to create complex layouts with rows and columns, similar to how CSS flexbox or grid systems work, but for terminal applications.

## Purpose

The layout system enables:
- **Dynamic space division**: Split terminal space into configurable regions
- **Flexible sizing**: Use ratios, fixed sizes, or minimum sizes for layout components
- **Hierarchical layouts**: Create nested layouts with different splitters
- **Live updates**: Refresh specific layout regions without redrawing everything
- **Visual debugging**: Generate tree representations of layout structure

## Key Classes

### `Layout`

The main class that represents a layout region that can contain renderable content or be split into sub-layouts.

#### Constructor Parameters

```python
Layout(
    renderable=None,           # Content to render, or None for placeholder
    name=None,                # Optional identifier for the layout
    size=None,                # Fixed size (width for rows, height for columns)
    minimum_size=1,           # Minimum allowable size
    ratio=1,                  # Relative size ratio for flexible layouts
    visible=True              # Whether this layout should be rendered
)
```

#### Important Methods

- **`split(*layouts, splitter="column")`**: Divide layout into sub-layouts
- **`split_row(*layouts)`**: Split horizontally into columns
- **`split_column(*layouts)`**: Split vertically into rows  
- **`add_split(*layouts)`**: Add more layouts to existing split
- **`get(name)`**: Find a named layout in the hierarchy
- **`update(renderable)`**: Change the content of a layout
- **`refresh_screen(console, layout_name)`**: Refresh specific layout region

#### Properties

- **`children`**: List of visible child layouts
- **`renderable`**: The content to be rendered
- **`tree`**: Tree representation showing layout structure
- **`map`**: Mapping of layouts to their rendered regions

### Splitter Classes

#### `Splitter` (Abstract Base Class)
Base class for layout splitting strategies.

#### `RowSplitter`
Splits a region horizontally into columns (side-by-side layouts).

#### `ColumnSplitter`  
Splits a region vertically into rows (stacked layouts).

### Helper Classes

#### `LayoutRender`
```python
class LayoutRender(NamedTuple):
    region: Region      # The screen region occupied
    render: List[List[Segment]]  # The rendered content
```

#### `_Placeholder`
Internal class that renders placeholder content showing layout dimensions when no content is provided.

## Usage Examples

### Basic Layout Creation

```python
from rich.layout import Layout
from rich.console import Console

console = Console()
layout = Layout()

# Create a three-section vertical layout
layout.split_column(
    Layout(name="header", size=3),      # Fixed height of 3
    Layout(name="main", ratio=1),       # Takes remaining space
    Layout(name="footer", size=2)       # Fixed height of 2
)
```

### Nested Layouts

```python
# Split the main section horizontally
layout["main"].split_row(
    Layout(name="sidebar", size=20),    # Fixed width sidebar
    Layout(name="content", ratio=1)     # Flexible content area
)

# Add content to specific regions
layout["header"].update("Header Content")
layout["sidebar"].update("Navigation")
layout["content"].update("Main Content")
```

### Dynamic Updates

```python
# Update content without recreating layout
layout.update("New content")

# Refresh only a specific region
layout.refresh_screen(console, "content")
```

## Type Definitions

```python
RegionMap = Dict[Layout, Region]           # Maps layouts to screen regions
RenderMap = Dict[Layout, LayoutRender]     # Maps layouts to rendered output
```

## Exception Classes

- **`LayoutError`**: Base exception for layout-related errors
- **`NoSplitter`**: Raised when requesting a non-existent splitter type

## Notes and Suggestions

### Threading Safety
- The Layout class uses `RLock` for thread-safe operations
- Safe to update layouts from different threads

### Performance Considerations
- Use `refresh_screen()` for partial updates instead of full re-renders
- Consider layout complexity vs. performance for deeply nested structures

### Best Practices

1. **Use meaningful names** for layouts to make them easy to reference:
   ```python
   Layout(name="sidebar")  # Good
   Layout()                # Harder to reference later
   ```

2. **Combine fixed and flexible sizing** for responsive layouts:
   ```python
   layout.split_column(
       Layout(size=3),      # Fixed header
       Layout(ratio=1),     # Flexible content
       Layout(size=2)       # Fixed footer
   )
   ```

3. **Leverage the tree property** for debugging complex layouts:
   ```python
   console.print(layout.tree)  # Visualize layout structure
   ```

### Limitations

- Layouts are designed for fixed-size terminal applications
- Minimum size constraints may cause layouts to not fit in very small terminals
- Complex nested layouts can impact rendering performance

## Example Application

The module includes a complete example at the bottom showing how to create a typical application layout with header, footer, sidebar, and multiple content areas.