<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Rich Segment Module Documentation

## Overview

The `segment.py` module is a core component of the Rich library that handles the final stage of text rendering before output to the terminal. It provides classes and utilities for managing styled text segments with ANSI control codes.

## Purpose

This module defines the fundamental building blocks for Rich's rendering system:
- **Segments**: Individual pieces of styled text that can contain control codes
- **Text processing**: Splitting, cropping, aligning, and manipulating text segments
- **Terminal control**: Managing ANSI control codes for cursor movement, colors, and screen manipulation

## Key Classes and Enums

### `ControlType(IntEnum)`

Defines non-printable control codes that translate to ANSI terminal commands:

```python
class ControlType(IntEnum):
    BELL = 1
    CARRIAGE_RETURN = 2
    HOME = 3
    CLEAR = 4
    SHOW_CURSOR = 5
    HIDE_CURSOR = 6
    # ... and more
```

**Available Control Types:**
- Cursor movement (UP, DOWN, FORWARD, BACKWARD, MOVE_TO)
- Screen control (CLEAR, ALT_SCREEN)
- Display control (SHOW/HIDE_CURSOR)
- Line operations (ERASE_IN_LINE)

### `Segment(NamedTuple)`

The core class representing a piece of styled text with optional control codes.

```python
@rich_repr()
class Segment(NamedTuple):
    text: str
    style: Optional[Style] = None
    control: Optional[Sequence[ControlCode]] = None
```

**Key Properties:**
- `cell_length`: Returns the number of terminal cells required to display the text
- `is_control`: Boolean indicating if the segment contains control codes

## Important Methods

### Text Manipulation

#### `split_cells(cut: int) -> Tuple[Segment, Segment]`
Splits a segment at a specified cell position, handling double-width characters properly.

```python
segment = Segment("Hello World", style)
left, right = segment.split_cells(5)
# left: "Hello", right: " World"
```

#### `adjust_line_length(line: List[Segment], length: int, style: Optional[Style] = None, pad: bool = True) -> List[Segment]`
Adjusts a line of segments to a specific width by cropping or padding.

### Style Operations

#### `apply_style(segments: Iterable[Segment], style: Optional[Style] = None, post_style: Optional[Style] = None) -> Iterable[Segment]`
Applies base and post styles to segments: `style + segment.style + post_style`

#### `filter_control(segments: Iterable[Segment], is_control: bool = False) -> Iterable[Segment]`
Filters segments based on whether they contain control codes.

### Line Processing

#### `split_lines(segments: Iterable[Segment]) -> Iterable[List[Segment]]`
Splits segments containing newlines into separate lines.

#### `split_and_crop_lines(segments: Iterable[Segment], length: int, ...) -> Iterable[List[Segment]]`
Advanced line splitting with cropping and padding options.

### Alignment Methods

- `align_top()`: Adds padding lines at the bottom
- `align_bottom()`: Adds padding lines at the top  
- `align_middle()`: Centers content with padding above and below

### Utility Methods

#### `simplify(segments: Iterable[Segment]) -> Iterable[Segment]`
Combines consecutive segments with the same style to optimize output.

#### `strip_links(segments: Iterable[Segment]) -> Iterable[Segment]`
Removes hyperlink information from segments.

#### `strip_styles(segments: Iterable[Segment]) -> Iterable[Segment]`
Removes all styling, keeping only text content.

#### `remove_color(segments: Iterable[Segment]) -> Iterable[Segment]`
Removes color information while preserving other style attributes.

## Helper Classes

### `Segments`
A simple renderable wrapper for an iterable of segments:

```python
segments = [Segment("Hello"), Segment(" World", Style(bold=True))]
renderable = Segments(segments, new_lines=False)
```

### `SegmentLines`
A renderable wrapper for multiple lines of segments:

```python
lines = [
    [Segment("Line 1")],
    [Segment("Line 2", Style(color="red"))]
]
renderable = SegmentLines(lines, new_lines=True)
```

## Usage Notes

### Performance Considerations
- The `_split_cells()` method uses `@lru_cache(1024 * 16)` for performance optimization
- Use `simplify()` to reduce the number of segments before output
- Cell length calculations are cached for efficiency

### Double-Width Character Handling
The module properly handles double-width Unicode characters (like CJK characters):
- Splitting in the middle of a double-width character replaces it with two spaces
- Cell length calculations account for character display width, not string length

### Control Code Management
- Control segments have zero cell length
- Control codes are preserved during most operations
- Use `filter_control()` to separate control codes from text content

## Suggestions

1. **When implementing custom renderables**: Use `Segment` objects as the final output of your `__rich_console__` method
2. **For text processing**: Leverage the built-in methods like `adjust_line_length()` rather than implementing your own
3. **Performance optimization**: Call `simplify()` on segment iterables to reduce terminal output
4. **Debugging**: Use the module's main block example to understand how segments work in practice

## Example Usage

```python
from rich.segment import Segment
from rich.style import Style

# Create styled segments
segments = [
    Segment("Hello ", Style(color="red")),
    Segment("World", Style(bold=True)),
    Segment("!", Style(color="blue"))
]

# Simplify consecutive segments with same style
simplified = list(Segment.simplify(segments))

# Split into lines and adjust length
lines = list(Segment.split_lines(segments))
adjuste