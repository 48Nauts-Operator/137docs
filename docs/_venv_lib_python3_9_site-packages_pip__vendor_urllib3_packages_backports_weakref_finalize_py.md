<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# backports.weakref_finalize

## Overview

This module provides a backport of Python 3's `weakref.finalize` functionality for older Python versions. It implements a mechanism for registering cleanup functions that are automatically called when objects are garbage collected, without creating reference cycles that would prevent garbage collection.

## Purpose

The `weakref_finalize` class allows you to:
- Register cleanup functions to be called when objects are garbage collected
- Avoid memory leaks by not creating strong references to the objects being monitored
- Ensure cleanup functions run at program exit if the objects haven't been collected yet
- Manually invoke or detach finalizers when needed

## Main Class: `weakref_finalize`

### Constructor

```python
weakref_finalize(obj, func, *args, **kwargs)
```

Creates a finalizer that will call `func(*args, **kwargs)` when `obj` is garbage collected.

**Parameters:**
- `obj`: The object to monitor for garbage collection
- `func`: The cleanup function to call
- `*args`: Positional arguments to pass to the cleanup function
- `**kwargs`: Keyword arguments to pass to the cleanup function

### Key Methods

#### `__call__(self, _=None)`
- **Purpose**: Manually invoke the finalizer
- **Returns**: Result of `func(*args, **kwargs)` if alive, `None` if already dead
- **Side effect**: Marks the finalizer as dead after calling

#### `detach(self)`
- **Purpose**: Remove the finalizer without calling it
- **Returns**: Tuple `(obj, func, args, kwargs)` if alive, `None` if dead
- **Use case**: When you want to cancel the automatic cleanup

#### `peek(self)`
- **Purpose**: Inspect the finalizer without affecting its state
- **Returns**: Tuple `(obj, func, args, kwargs)` if alive, `None` if dead
- **Use case**: Debugging or conditional logic based on finalizer state

### Properties

#### `alive`
- **Type**: Read-only boolean
- **Purpose**: Check if the finalizer is still active

#### `atexit`
- **Type**: Read/write boolean
- **Purpose**: Control whether the finalizer runs at program exit
- **Default**: `True`

### Class Methods

#### `_select_for_exit(cls)`
- **Purpose**: Internal method to get finalizers that should run at exit
- **Returns**: List of finalizers ordered by creation time (oldest first)

#### `_exitfunc(cls)`
- **Purpose**: Internal exit handler that runs remaining finalizers at shutdown
- **Features**: 
  - Disables garbage collection during cleanup to prevent issues
  - Handles exceptions in finalizers gracefully
  - Prevents new finalizers from running during shutdown

## Usage Examples

### Basic Usage
```python
import weakref
from backports.weakref_finalize import weakref_finalize

class MyResource:
    def __init__(self, name):
        self.name = name
        
def cleanup(name):
    print(f"Cleaning up {name}")

# Create resource and finalizer
resource = MyResource("database connection")
finalizer = weakref_finalize(resource, cleanup, resource.name)

# Resource will be cleaned up when garbage collected
del resource  # cleanup() will be called
```

### Manual Cleanup
```python
# Create finalizer
finalizer = weakref_finalize(obj, cleanup_func, arg1, arg2)

# Check if still alive
if finalizer.alive:
    # Manually invoke cleanup
    result = finalizer()
    
# Or detach without calling
obj, func, args, kwargs = finalizer.detach()
```

## Important Notes

### Thread Safety
- The module handles thread races when registering the exit function
- Multiple registrations of the exit function are harmless

### Memory Management
- Finalizers use `__slots__ = ()` to avoid creating reference cycles
- The actual state is stored in a separate `_Info` class
- Weak references are used to monitor object lifecycle

### Exit Behavior
- Finalizers run in reverse order of creation at program exit
- Garbage collection is disabled during exit cleanup to prevent issues
- Exceptions in finalizers are handled via `sys.excepthook`

### Limitations
- Only works with weakref-able objects (objects that support weak references)
- Cleanup timing depends on garbage collection, which may be unpredictable
- Not suitable for critical resource cleanup that must happen immediately

## Suggestions for Use

1. **Use for non-critical cleanup**: File handles, network connections, temporary resources
2. **Always provide manual cleanup methods**: Don't rely solely on finalizers for important resources
3. **Test thoroughly**: Garbage collection timing can vary between Python implementations
4. **Consider context managers**: For deterministic cleanup, `with` statements are often better
5. **Monitor finalizer state**: Use the `alive` property and `peek()` method for debugging