<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Socket Waiting Utilities

This module provides cross-platform utilities for waiting on socket readiness events (read/write availability) with proper timeout handling and interrupt retry logic.

## Purpose

The module implements efficient socket waiting functionality that:
- Chooses the best available waiting mechanism per platform (`poll()` vs `select()`)
- Handles interrupts and timeouts gracefully
- Provides a simple API for waiting on socket read/write readiness
- Works across different Python versions and operating systems

## Key Design Decisions

The module prioritizes **stateless APIs** (`select()`/`poll()`) over stateful ones (`epoll`/`kqueue`) because:
- Only single sockets are monitored at a time
- No persistent state management is needed
- Simpler and more efficient for the use case

**Platform Selection Logic:**
- **Unix/Linux**: Prefers `poll()` to avoid `select()`'s file descriptor limitations
- **Windows**: Uses `select()` (no `poll()` available, but `select()` works well)
- **Fallback**: Uses `select()` if `poll()` is broken or unavailable

## Classes

### `NoWayToWaitForSocketError`

```python
class NoWayToWaitForSocketError(Exception):
    pass
```

**Purpose**: Exception raised when no suitable socket waiting mechanism is available (e.g., on restricted platforms like App Engine).

## Functions

### `wait_for_read(sock, timeout=None)`

**Purpose**: Waits for a socket to become readable.

**Parameters:**
- `sock`: Socket object to monitor
- `timeout`: Maximum time to wait in seconds (None for infinite)

**Returns**: `True` if socket is readable, `False` if timeout expired

```python
# Example usage
if wait_for_read(socket, timeout=5.0):
    data = socket.recv(1024)
```

### `wait_for_write(sock, timeout=None)`

**Purpose**: Waits for a socket to become writable.

**Parameters:**
- `sock`: Socket object to monitor  
- `timeout`: Maximum time to wait in seconds (None for infinite)

**Returns**: `True` if socket is writable, `False` if timeout expired

```python
# Example usage
if wait_for_write(socket, timeout=5.0):
    socket.send(data)
```

## Internal Implementation

### Core Waiting Functions

#### `select_wait_for_socket(sock, read=False, write=False, timeout=None)`
- Uses `select.select()` for socket monitoring
- Handles Windows' special case for non-blocking connects (checks exceptional conditions)

#### `poll_wait_for_socket(sock, read=False, write=False, timeout=None)`  
- Uses `select.poll()` for more efficient monitoring on Unix systems
- Converts timeout from seconds to milliseconds for `poll()`

#### `wait_for_socket(*args, **kwargs)`
- **Lazy initialization**: Chooses implementation on first call
- Tests for working `poll()` availability via `_have_working_poll()`
- Falls back gracefully through: `poll()` → `select()` → exception

### Interrupt Handling

#### `_retry_on_intr(fn, timeout)`
Handles interrupted system calls differently based on Python version:

- **Python ≥ 3.5**: Relies on automatic syscall retry
- **Python < 3.5**: Manual retry loop with timeout recalculation

## Important Notes

### Cross-Platform Compatibility
- **Windows**: Uses `select()` with special handling for exceptional socket states
- **Unix/Linux**: Prefers `poll()` for better file descriptor support
- **App Engine**: Gracefully fails with descriptive error

### Timeout Behavior
- Uses `time.monotonic()` (or fallback to `time.time()`) for accurate timeout tracking
- Properly handles timeout recalculation after interrupts
- Supports infinite timeouts (`None`)

### Error Handling
- Distinguishes between `EINTR` (retry) and other errors (propagate)
- Compatible with both `OSError` (Python 3) and `select.error` (Python 2.7)

## Usage Examples

```python
import socket
from this_module import wait_for_read, wait_for_write

# Wait for incoming data
sock = socket.socket()
if wait_for_read(sock, timeout=10.0):
    data = sock.recv(1024)
else:
    print("Timeout waiting for data")

# Wait for socket to be ready for writing  
if wait_for_write(sock, timeout=5.0):
    sock.send(b"Hello, world!")
else:
    print("Timeout waiting to send")
```

## Dependencies

- `select` module (standard library)
- `errno` module (standard library) 
- `sys` module (for version detection)
- `time` module (for timeout handling)