<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Python Compatibility Utilities (`compat.py`)

## Overview

This file provides Python 2/3 compatibility utilities to help maintain cross-version compatibility in codebases that need to support both Python 2 and Python 3. It contains helper functions and variables that abstract away version-specific differences.

## License

This file is dual-licensed under:
- Apache License, Version 2.0
- BSD License

## Python Version Detection

The module automatically detects the Python version being used:

```python
PY2 = sys.version_info[0] == 2
PY3 = sys.version_info[0] == 3
```

### Variables

- **`PY2`** (`bool`): `True` if running on Python 2.x, `False` otherwise
- **`PY3`** (`bool`): `True` if running on Python 3.x, `False` otherwise

## String Type Compatibility

```python
if PY3:
    string_types = (str,)
else:
    string_types = (basestring,)
```

### Variables

- **`string_types`** (`tuple`): A tuple containing the appropriate string base types for the current Python version
  - Python 3: `(str,)`
  - Python 2: `(basestring,)` (covers both `str` and `unicode`)

### Usage Example

```python
from compat import string_types

def process_text(text):
    if isinstance(text, string_types):
        return text.upper()
    raise TypeError("Expected string type")
```

## Metaclass Compatibility

### `with_metaclass(meta, *bases)`

Creates a base class with a specified metaclass that works across Python 2 and 3.

#### Parameters

- **`meta`** (`Type[Any]`): The metaclass to use
- **`*bases`** (`Tuple[Type[Any], ...]`): Base classes for the new class

#### Returns

- **`Any`**: A temporary base class that will apply the metaclass correctly

#### How It Works

The function uses a clever technique to handle metaclass syntax differences between Python versions:

1. Creates a temporary metaclass that inherits from the desired metaclass
2. Overrides `__new__` to replace itself with the actual metaclass
3. Returns a temporary class that serves as a base for the final class

#### Usage Example

```python
from compat import with_metaclass

class MyMeta(type):
    def __new__(cls, name, bases, dct):
        # Custom metaclass logic here
        return super(MyMeta, cls).__new__(cls, name, bases, dct)

class MyClass(with_metaclass(MyMeta, object)):
    pass
```

## Type Checking Support

The module includes proper type hints and imports for static type checking:

```python
if TYPE_CHECKING:  # pragma: no cover
    from typing import Any, Dict, Tuple, Type
```

This ensures type checkers like mypy can properly analyze the code without affecting runtime performance.

## Notes and Suggestions

### Usage Recommendations

- **Version Detection**: Use `PY2` and `PY3` constants for conditional code execution
- **String Handling**: Always use `string_types` for `isinstance()` checks when you need to handle strings generically
- **Metaclasses**: Use `with_metaclass()` instead of version-specific metaclass syntax

### Important Considerations

- This is a compatibility layer for codebases transitioning from Python 2 to Python 3
- For new projects targeting only Python 3.6+, these utilities may not be necessary
- The `with_metaclass` function uses advanced Python features and may be confusing to beginners

### Migration Path

If you're maintaining a library that still supports Python 2, this module helps ensure consistent behavior. However, consider:

1. Gradually dropping Python 2 support as it reached end-of-life in January 2020
2. Using tools like `six` library for more comprehensive compatibility needs
3. Eventually removing compatibility layers when Python 2 support is no longer needed