<!-- Auto-generated by Claude on 2025-06-02 06:15 -->

# Python Compatibility Utilities

## Overview

This file provides Python 2/3 compatibility utilities to help write code that works across different Python versions. It contains helper functions and constants that abstract away version-specific differences, making it easier to maintain cross-compatible codebases.

## Purpose

- **Cross-version compatibility**: Enables writing code that works on both Python 2 and Python 3
- **Type handling**: Provides unified string type handling across versions
- **Metaclass support**: Offers a clean way to use metaclasses in a version-agnostic manner

## License

This file is dual-licensed under:
- Apache License, Version 2.0
- BSD License

## Constants

### Version Detection
```python
PY2 = sys.version_info[0] == 2
PY3 = sys.version_info[0] == 3
```

- **`PY2`**: Boolean flag indicating if running on Python 2
- **`PY3`**: Boolean flag indicating if running on Python 3

### String Types
```python
if PY3:
    string_types = (str,)
else:
    string_types = (basestring,)
```

- **`string_types`**: Tuple containing the appropriate string base types for the current Python version
  - Python 3: Contains only `str`
  - Python 2: Contains `basestring` (which covers both `str` and `unicode`)

## Functions

### `with_metaclass(meta, *bases)`

Creates a base class with a specified metaclass in a way that's compatible with both Python 2 and Python 3.

#### Parameters
- **`meta`** (`Type[Any]`): The metaclass to use
- **`*bases`** (`Tuple[Type[Any], ...]`): Base classes for the new class

#### Returns
- **`Any`**: A temporary class that will be replaced by the actual metaclass

#### Usage Example
```python
class MyMeta(type):
    def __new__(cls, name, bases, attrs):
        # Custom metaclass logic here
        return super(MyMeta, cls).__new__(cls, name, bases, attrs)

class MyClass(with_metaclass(MyMeta, object)):
    pass
```

#### How It Works
1. Creates a temporary metaclass that inherits from the desired metaclass
2. The temporary metaclass's `__new__` method immediately delegates to the actual metaclass
3. Returns a temporary class instance that gets replaced during class creation
4. This pattern works around the different metaclass syntax between Python 2 and 3

## Usage Notes

### String Type Checking
Instead of checking `isinstance(obj, str)` or `isinstance(obj, basestring)`, use:
```python
isinstance(obj, string_types)
```

### Version-Specific Code
Use the version flags for conditional imports or implementations:
```python
if PY3:
    # Python 3 specific code
    pass
else:
    # Python 2 specific code
    pass
```

## Dependencies

- **Standard Library**: `sys` for version detection
- **Internal**: `._typing` for type hints (only used during type checking)

## Notes

- The `# flake8: noqa` comment disables linting for the entire file, likely due to the metaclass magic
- Type hints are conditionally imported to avoid runtime overhead
- The metaclass implementation uses advanced Python features and may be difficult to understand without knowledge of Python's class creation process