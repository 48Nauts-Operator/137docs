<!-- Auto-generated by Claude on 2025-06-02 06:15 -->

# canonicalize.py

## Overview

This module provides utilities for canonicalizing (normalizing) Python package names and version strings according to Python packaging standards. It implements canonicalization rules from PEP 503 for package names and provides version normalization functionality that works with the `Version` class.

## Purpose

- **Package Name Canonicalization**: Converts package names to a standardized format for consistent comparison and storage
- **Version String Canonicalization**: Normalizes version strings by standardizing their format while preserving semantic meaning

## Dependencies

- `re` - Regular expression operations
- `._typing` - Type checking utilities
- `.version` - Version parsing and validation classes

## Functions

### `canonicalize_name(name)`

Canonicalizes a Python package name according to PEP 503 standards.

**Parameters:**
- `name` (str): The package name to canonicalize

**Returns:**
- `NormalizedName`: The canonicalized package name

**Behavior:**
- Converts the name to lowercase
- Replaces any sequence of hyphens, underscores, and dots with a single hyphen
- Uses the regex pattern `[-_.]+` for replacement

**Example:**
```python
canonicalize_name("My_Package.Name") # Returns: "my-package-name"
canonicalize_name("Django___REST") # Returns: "django-rest"
```

### `canonicalize_version(_version)`

Canonicalizes a version string by parsing it and reconstructing it in a normalized format.

**Parameters:**
- `_version` (str): The version string to canonicalize

**Returns:**
- `Union[Version, str]`: A normalized version string, or the original string if it's a legacy version that cannot be parsed

**Behavior:**
- Attempts to parse the version using the `Version` class
- If parsing fails (legacy version), returns the original string unchanged
- For valid versions, reconstructs the version string with normalized formatting:
  - **Epoch**: Included only if non-zero (format: `{epoch}!`)
  - **Release**: Strips trailing `.0` segments (e.g., `1.0.0` becomes `1`)
  - **Pre-release**: Formats pre-release identifiers
  - **Post-release**: Formats as `.post{N}`
  - **Development**: Formats as `.dev{N}`
  - **Local version**: Formats with `+` prefix

**Example:**
```python
canonicalize_version("1.0.0") # Returns: "1"
canonicalize_version("2.0.0a1") # Returns: "2a1"
canonicalize_version("1.5.0.post1") # Returns: "1.5.post1"
```

## Implementation Details

### Regular Expressions

- `_canonicalize_regex = re.compile(r"[-_.]+")`
  - Matches one or more consecutive hyphens, underscores, or dots
  - Used for package name normalization

### Type Annotations

The module uses conditional type imports for better type safety:
- `NormalizedName`: A type alias for canonicalized package names
- Proper return type annotations for better IDE support and static analysis

## Notes and Suggestions

### Usage Considerations

- **Package Names**: Always use `canonicalize_name()` before comparing package names to ensure consistent matching
- **Version Strings**: The canonicalization is similar to `Version.__str__()` but with subtle differences in release segment handling
- **Legacy Versions**: Invalid versions are returned as-is, maintaining backward compatibility

### Best Practices

- Use these functions when:
  - Storing package names in databases or indexes
  - Comparing package names from different sources
  - Normalizing version strings for display or comparison
  - Implementing package management tools

### Performance Notes

- Both functions are lightweight and suitable for frequent use
- Regular expression compilation is done once at module load time
- Version parsing may raise exceptions for invalid versions, which are handled gracefully

## Standards Compliance

- **PEP 503**: Package name canonicalization follows the Python Package Index standards
- **PEP 440**: Version canonicalization aligns with Python version identification standards