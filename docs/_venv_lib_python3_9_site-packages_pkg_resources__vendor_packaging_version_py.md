<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Version Parsing Module Documentation

## Overview

This module provides comprehensive version parsing and comparison functionality for Python packages. It implements both **PEP 440** compliant version handling and legacy version support, making it suitable for managing package versions in various Python packaging scenarios.

## Purpose

- Parse version strings into structured version objects
- Compare versions using standardized comparison rules
- Support both modern PEP 440 versions and legacy version formats
- Provide detailed version component access (epoch, release, pre-release, etc.)

## Key Classes

### `Version`

The main class for handling PEP 440 compliant version strings.

```python
from version_parser import Version

v = Version("1.2.3a1.post2.dev4+local.1")
print(v.major)  # 1
print(v.minor)  # 2
print(v.is_prerelease)  # True
```

**Key Properties:**
- `epoch`: Version epoch (integer)
- `release`: Release tuple (e.g., (1, 2, 3))
- `pre`: Pre-release info (e.g., ('a', 1))
- `post`: Post-release number
- `dev`: Development release number
- `local`: Local version identifier
- `major`, `minor`, `micro`: Semantic version components
- `is_prerelease`, `is_postrelease`, `is_devrelease`: Boolean flags

### `LegacyVersion`

Handles non-PEP 440 compliant version strings using legacy parsing rules.

```python
legacy_v = LegacyVersion("1.0-final")
print(legacy_v.epoch)  # -1 (always for legacy versions)
```

**Key Features:**
- Always has epoch = -1 (sorts before PEP 440 versions)
- Most version component properties return `None`
- Preserves original version string

### `InvalidVersion`

Exception raised when a version string cannot be parsed as a valid PEP 440 version.

```python
try:
    Version("invalid..version")
except InvalidVersion as e:
    print(f"Error: {e}")
```

## Key Functions

### `parse(version)`

The main entry point for version parsing. Automatically determines whether to use `Version` or `LegacyVersion`.

```python
from version_parser import parse

# Returns Version object for PEP 440 compliant strings
v1 = parse("1.2.3")

# Returns LegacyVersion object for non-compliant strings  
v2 = parse("1.0-final")
```

**Parameters:**
- `version` (str): Version string to parse

**Returns:**
- `Version` object if PEP 440 compliant
- `LegacyVersion` object if not compliant

## Version Pattern

The module exports `VERSION_PATTERN`, a regex pattern for matching PEP 440 version strings:

```python
import re
from version_parser import VERSION_PATTERN

# Use in your own regex
full_pattern = re.compile(f"^{VERSION_PATTERN}$", re.VERBOSE | re.IGNORECASE)
```

## Version Comparison

All version objects support standard comparison operators:

```python
v1 = Version("1.0.0")
v2 = Version("1.0.1")

print(v1 < v2)   # True
print(v1 == v2)  # False
print(v1 != v2)  # True
```

**Comparison Rules:**
- Legacy versions always sort before PEP 440 versions
- Development versions sort before alpha/beta versions
- Versions without local components sort before those with local components

## Internal Helper Functions

### `_parse_letter_version(letter, number)`
Normalizes pre/post/dev version components.

### `_parse_local_version(local)`
Parses local version identifiers into comparable components.

### `_cmpkey(...)`
Generates comparison keys for proper version sorting according to PEP 440 rules.

## Usage Examples

### Basic Version Parsing
```python
from version_parser import parse, Version

# Parse any version string
v = parse("2.1.0rc1")
print(f"Version: {v}")
print(f"Is prerelease: {v.is_prerelease}")
```

### Version Comparison
```python
versions = ["1.0.0", "1.0.0a1", "1.0.0b1", "1.0.0rc1", "1.0.1"]
parsed_versions = [Version(v) for v in versions]
sorted_versions = sorted(parsed_versions)

for v in sorted_versions:
    print(v)
```

### Accessing Version Components
```python
v = Version("2.1.3a1.post2.dev4+ubuntu.1")

print(f"Major: {v.major}")           # 2
print(f"Minor: {v.minor}")           # 1  
print(f"Micro: {v.micro}")           # 3
print(f"Pre-release: {v.pre}")       # ('a', 1)
print(f"Post-release: {v.post}")     # 2
print(f"Dev release: {v.dev}")       # 4
print(f"Local: {v.local}")           # ubuntu.1
print(f"Public: {v.public}")         # 2.1.3a1.post2.dev4
print(f"Base: {v.base_version}")     # 2.1.3
```

## Notes and Suggestions

### Best Practices
- Use the `parse()` function for general version parsing to automatically handle both PEP 440 and legacy versions
- Always handle `InvalidVersion` exceptions when parsing untrusted input
- Use `public` property to get version string without local components
- Use `base_version` property to get just the release version without pre/post/dev components

### Performance Considerations
- Version objects are hashable and can be used in sets and as dictionary keys
- Comparison operations are optimized using pre-computed comparison keys
- Regular expression compilation is done once at module import time

### Compatibility Notes
- Legacy versions will always sort before PEP 440 versions due to epoch = -1
- The module handles various alternative spellings (