<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# PyParsing Module Documentation

## Overview

The `pyparsing.py` module is a comprehensive Python library for creating and executing parsing grammars. It provides an alternative approach to traditional lex/yacc parsers or regular expressions by allowing you to define grammars directly in Python using readable class names and operators.

## Purpose

PyParsing enables you to:
- Define complex grammars using intuitive Python syntax
- Parse structured text without learning new grammar definition languages
- Handle common parsing challenges like whitespace, quoted strings, and comments
- Create recursive and nested parsing patterns
- Apply parse actions to transform results during parsing

## Key Features

- **Readable Grammar Definition**: Use class names like `Word`, `Literal`, `And`, `Or`
- **Operator Overloading**: Combine expressions with `+`, `|`, `^`, `&` operators
- **Automatic Whitespace Handling**: Skip whitespace between tokens by default
- **Parse Actions**: Transform parsed tokens with custom functions
- **Named Results**: Access parsed data as nested attributes
- **Packrat Parsing**: Optional memoization for performance optimization

## Important Classes

### Core Parser Elements

#### `ParserElement`
The abstract base class for all parsing elements.

**Key Methods:**
- `parseString(text)` - Parse a complete string
- `scanString(text)` - Find all matches in a string
- `setParseAction(func)` - Add transformation functions
- `setResultsName(name)` - Name results for later access

```python
# Basic usage example
from pyparsing import Word, alphas
word = Word(alphas)
result = word.parseString("hello")  # Returns ['hello']
```

#### `ParseResults`
Container for parsed results with list and dictionary access.

```python
# Access results multiple ways
result = date_expr.parseString("1999/12/31")
print(result[0])        # List access: '1999'
print(result.year)      # Attribute access
print(result['year'])   # Dictionary access
```

### Token Classes

#### `Literal`
Match exact strings.

```python
hello = Literal("hello")
```

#### `Word`
Match sequences of characters from defined sets.

```python
integer = Word(nums)                    # Match digits
identifier = Word(alphas, alphanums)    # Start with letter, continue with alphanums
```

#### `Regex`
Match using regular expressions.

```python
phone = Regex(r'\d{3}-\d{3}-\d{4}')
```

#### `QuotedString`
Match quoted strings with escape handling.

```python
quoted = QuotedString('"', escChar='\\')
```

### Expression Combinators

#### `And` (+ operator)
Match expressions in sequence.

```python
greeting = Word(alphas) + "," + Word(alphas) + "!"
# Matches: "Hello, World!"
```

#### `Or` (^ operator)
Match the longest of several alternatives.

```python
number = Word(nums) ^ Combine(Word(nums) + '.' + Word(nums))
```

#### `MatchFirst` (| operator)
Match the first successful alternative.

```python
keyword = Literal("if") | Literal("then") | Literal("else")
```

### Repetition Classes

#### `OneOrMore`
Match one or more repetitions.

```python
word_list = OneOrMore(Word(alphas))
```

#### `ZeroOrMore`
Match zero or more repetitions.

```python
optional_words = ZeroOrMore(Word(alphas))
```

#### `Optional`
Match zero or one occurrence.

```python
signed_number = Optional(oneOf("+ -")) + Word(nums)
```

### Utility Classes

#### `Group`
Group results into a sub-list.

```python
coord = Group(Word(nums) + "," + Word(nums))
```

#### `Suppress`
Match but don't include in results.

```python
csv_line = Word(alphas) + ZeroOrMore(Suppress(",") + Word(alphas))
```

#### `Combine`
Concatenate adjacent tokens into a single string.

```python
real_number = Combine(Word(nums) + "." + Word(nums))
```

## Usage Examples

### Basic Grammar Definition

```python
from pyparsing import Word, alphas, nums, Literal

# Define grammar
greeting = Word(alphas) + "," + Word(alphas) + "!"

# Parse text
result = greeting.parseString("Hello, World!")
print(result)  # ['Hello', ',', 'World', '!']
```

### Named Results

```python
from pyparsing import Word, nums

integer = Word(nums)
date_str = (integer.setResultsName("year") + '/' + 
           integer.setResultsName("month") + '/' + 
           integer.setResultsName("day"))

result = date_str.parseString("1999/12/31")
print(result.year)   # '1999'
print(result.month)  # '12'
print(result.day)    # '31'
```

### Parse Actions

```python
from pyparsing import Word, nums

# Convert strings to integers during parsing
integer = Word(nums).setParseAction(lambda t: int(t[0]))
date_str = integer + '/' + integer + '/' + integer

result = date_str.parseString("1999/12/31")
print(result)  # [1999, '/', 12, '/', 31] - numbers are now ints
```

### Complex Expression with Recursion

```python
from pyparsing import *

# Mathematical expression parser
expr = Forward()
atom = Word(nums) | "(" + expr + ")"
term = atom + ZeroOrMore(oneOf("* /") + atom)
expr <<= term + ZeroOrMore(oneOf("+ -") + term)

result = expr.parseString("3 + 4 * (2 + 1)")
```

## Built-in Helpers

### Common Patterns

```python
from pyparsing import *

# Pre-defined character sets
alphas     # a-zA-Z
nums       # 0-9
alphanums  # a-zA-Z0