<!-- Auto-generated by Claude on 2025-06-02 06:15 -->

# pyparsing.py Documentation

## Overview

This is the main pyparsing module file, which provides a Python library for creating and executing parsing grammars. pyparsing offers an alternative approach to traditional lex/yacc or regular expression-based parsing.

**Key Features:**
- Direct construction of parsers in Python code (no separate grammar files)
- Handles whitespace, comments, and quoted strings automatically
- Provides clear, readable grammar definitions
- Supports parse actions for data transformation
- Built-in error handling and reporting

## Purpose

pyparsing enables you to define and execute simple grammars without learning new syntax. Instead of using external tools or complex regular expressions, you build parsers using Python classes and operators.

## Important Classes

### Core Parser Classes

#### `ParserElement`
**Abstract base class for all parsing elements**

Key methods:
- `parseString(instring, parseAll=False)` - Parse a complete string
- `scanString(instring)` - Find all matches in a string
- `transformString(instring)` - Transform matching text using parse actions
- `setParseAction(*fns)` - Define functions to process parsed tokens
- `setResultsName(name)` - Assign a name to parsed results

#### `ParseResults`
**Container for parsed results with multiple access methods**

Access patterns:
```python
# List-like access
result[0], result[1:]

# Dictionary-like access (for named results)
result['fieldname']

# Attribute access
result.fieldname

# Convert to standard types
result.asList()    # Convert to list
result.asDict()    # Convert to dictionary
```

### Token Classes

#### `Literal`
Match exact string literals
```python
greeting = Literal("Hello")
```

#### `Keyword`
Match keywords (with word boundaries)
```python
if_stmt = Keyword("if")
```

#### `Word`
Match words composed of specified character sets
```python
integer = Word(nums)                    # Digits only
identifier = Word(alphas, alphanums)    # Letter then letters/digits
```

#### `Regex`
Match using regular expressions
```python
float_num = Regex(r'[+-]?\d+\.\d*')
```

#### `QuotedString`
Match quoted strings with escape handling
```python
quoted = QuotedString('"', escChar='\\')
```

### Expression Classes

#### `And` (operator `+`)
Sequential matching - all expressions must match in order
```python
assignment = identifier + "=" + expression
```

#### `Or` (operator `^`)
Alternative matching - longest match wins
```python
number = integer ^ float_num
```

#### `MatchFirst` (operator `|`)
Alternative matching - first match wins
```python
keyword = Literal("if") | Literal("while") | Literal("for")
```

#### `Optional`
Make expressions optional
```python
sign = Optional(oneOf("+ -"))
```

#### `ZeroOrMore` / `OneOrMore`
Repetition patterns
```python
arg_list = OneOrMore(identifier + Optional(","))
```

### Converter Classes

#### `Group`
Group results into a sub-list
```python
point = Group(integer + "," + integer)  # Returns [x, y] as single item
```

#### `Suppress`
Parse but don't include in results
```python
lparen = Suppress("(")
rparen = Suppress(")")
```

#### `Combine`
Concatenate all matched tokens
```python
float_num = Combine(Word(nums) + "." + Word(nums))  # Returns "3.14" not ["3", ".", "14"]
```

## Helper Functions

### `oneOf(choices)`
Create alternatives from a string or list
```python
operator = oneOf("+ - * /")
```

### `delimitedList(expr, delim=",")`
Parse comma-separated (or other delimiter) lists
```python
numbers = delimitedList(integer)  # Matches "1,2,3,4"
```

### `nestedExpr(opener="(", closer=")")`
Parse nested expressions with balanced delimiters
```python
nested = nestedExpr()  # Matches "(a (b c) d)"
```

### `infixNotation(baseExpr, opList)`
Build parsers for infix expressions with operator precedence
```python
arith = infixNotation(integer,
    [('-', 1, opAssoc.RIGHT),    # Unary minus
     ('*', 2, opAssoc.LEFT),     # Multiply/divide
     ('+', 2, opAssoc.LEFT)])    # Add/subtract
```

## Built-in Expressions

The module provides many pre-defined expressions in `pyparsing_common`:

- `integer`, `signed_integer`, `hex_integer` - Various integer formats
- `real`, `sci_real`, `number` - Floating point numbers
- `identifier` - Programming language identifiers  
- `ipv4_address`, `ipv6_address`, `mac_address` - Network addresses
- `iso8601_date`, `iso8601_datetime` - Date/time formats
- `uuid` - UUID strings
- `comma_separated_list` - CSV-style lists

## Parse Actions

Parse actions are functions that process matched tokens:

```python
def convert_to_int(tokens):
    return int(tokens[0])

integer = Word(nums).setParseAction(convert_to_int)
```

Common parse actions:
- `tokenMap(func)` - Apply function to each token
- `replaceWith(value)` - Replace with constant value
- `removeQuotes` - Strip quote characters

## Constants and Character Sets

Pre-defined character sets:
- `alphas` - Letters (a-z, A-Z)
- `nums` - Digits (0-9)
- `alphanums` - Letters and digits
- `hexnums` - Hexadecimal digits
- `printables` - All printable characters

## Usage Notes

### Performance
- Use `ParserElement.enablePackrat()` for better performance with complex grammars
- Cache frequently used expressions
- Use `Combine()` to reduce token fragmentation

### Error Handling
- Parsing failures raise `ParseException` with location information
- Use `set