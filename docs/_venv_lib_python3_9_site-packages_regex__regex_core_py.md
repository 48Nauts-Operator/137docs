<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# regex._regex_core Module Documentation

## Overview

This module is the core implementation of the Secret Labs' Regular Expression Engine, an extended and enhanced version of Python's regex functionality. It provides advanced pattern matching capabilities with support for fuzzy matching, Unicode properties, nested character sets, and various regex features beyond standard Python regex.

## Purpose

The module serves as:
- An advanced regex parser and compiler
- Support for fuzzy matching with configurable error types and costs
- Extended Unicode support with full case-folding
- Enhanced character set operations (union, intersection, difference, symmetric difference)
- Recursive group calls and advanced lookaround assertions
- Backwards compatibility with different regex versions (V0/V1)

## Key Components

### Exception Classes

#### `error(Exception)`
Main exception class for regex compilation errors.

**Attributes:**
- `msg`: The unformatted error message
- `pattern`: The regular expression pattern
- `pos`: Position where compilation failed
- `lineno`: Line number of failure
- `colno`: Column number of failure

### Flag System

#### `RegexFlag(enum.IntFlag)`
Comprehensive flag system for controlling regex behavior:

**Major Flags:**
- `IGNORECASE` (I): Case-insensitive matching
- `MULTILINE` (M): ^ and $ match line boundaries
- `DOTALL` (S): . matches newlines
- `VERBOSE` (X): Ignore whitespace and comments
- `UNICODE` (U): Use Unicode locale
- `ASCII` (A): Use ASCII locale
- `FULLCASE` (F): Unicode full case-folding
- `BESTMATCH` (B): Best fuzzy match
- `ENHANCEMATCH` (E): Improve fuzzy match fit
- `REVERSE` (R): Search backwards
- `VERSION0`/`VERSION1`: Compatibility versions

### Core Classes

#### `Scanner`
Tokenizer class for lexical analysis.

```python
scanner = Scanner([
    (r'\d+', lambda scanner, token: int(token)),
    (r'\w+', lambda scanner, token: token),
])
tokens, remainder = scanner.scan("123 hello world")
```

#### `Source`
Parser for regex source strings with support for:
- Whitespace handling in verbose mode
- Comment parsing
- Position tracking
- Unicode/bytes handling

#### `Info`
Compilation context containing:
- Flags and settings
- Group information
- Named captures
- Fuzzy constraints

## Node Types (AST Classes)

### Character Matching
- **`Character`**: Single character literal
- **`Range`**: Character range (e.g., `[a-z]`)
- **`Property`**: Unicode property (e.g., `\p{Letter}`)
- **`Any`**: Any character (`.`)

### Quantifiers
- **`GreedyRepeat`**: Standard quantifiers (`*`, `+`, `?`, `{n,m}`)
- **`LazyRepeat`**: Non-greedy quantifiers (`*?`, `+?`)
- **`PossessiveRepeat`**: Possessive quantifiers (`*+`, `++`)

### Grouping
- **`Group`**: Capture groups `(...)`
- **`Atomic`**: Atomic groups `(?>...)`
- **`Branch`**: Alternation `|`
- **`Sequence`**: Concatenation

### Assertions
- **`LookAround`**: Lookahead/lookbehind `(?=...)`, `(?!...)`, `(?<=...)`, `(?<!...)`
- **`Boundary`**: Word boundaries `\b`, `\B`
- **`StartOfString`**, **`EndOfString`**: String anchors

### Advanced Features
- **`Fuzzy`**: Fuzzy matching with error tolerance
- **`CallGroup`**: Recursive group calls
- **`Conditional`**: Conditional patterns `(?(condition)yes|no)`

## Key Functions

### Pattern Parsing

#### `_parse_pattern(source, info)`
Main pattern parser that handles alternation and builds the AST.

#### `parse_sequence(source, info)`
Parses sequential elements and quantifiers.

#### `parse_set(source, info)`
Parses character sets with support for:
- Nested sets
- Set operations (union, intersection, difference)
- Unicode properties
- POSIX character classes

### Optimization

#### `optimise(info, reverse)`
Pattern optimization including:
- Common prefix/suffix extraction
- Character sequence packing
- Set reduction
- Dead code elimination

### Compilation

#### `_compile_firstset(info, fs)`
Builds efficient first-character matching for pattern optimization.

#### `compile(reverse, fuzzy)`
Compiles AST nodes to bytecode for the regex engine.

## Usage Examples

### Basic Pattern Compilation
```python
# The module is typically used internally by the regex module
import regex
pattern = regex.compile(r'(?i)hello\s+world')
```

### Fuzzy Matching
```python
import regex
# Allow up to 2 errors of any type
pattern = regex.compile(r'(?:fuzzy){e<=2}')
```

### Advanced Features
```python
import regex
# Using recursive groups and Unicode properties
pattern = regex.compile(r'(?P<balanced>\((?:[^()]|(?&balanced))*\))')
```

## Important Notes

### Performance Considerations
- The parser includes extensive optimization phases
- Character sequences are packed into strings for efficiency
- First-set analysis enables fast pattern matching
- Atomic grouping prevents excessive backtracking

### Unicode Support
- Full Unicode case-folding support
- Comprehensive Unicode property database
- Proper handling of multi-codepoint sequences
- Grapheme cluster matching

### Compatibility
- Supports both VERSION0 (legacy) and VERSION1 (enhanced) behaviors
- Maintains compatibility with Python's `re` module syntax
- Extended syntax for advanced features

### Error Handling
- Detailed error reporting with position information
- Validation of group references and property names
- Prevention of infinite recursion in group calls

## Suggestions for Usage

1. **Use appropriate flags**: Choose VERSION1 for new code to access enhanced features
2. **Leverage fuzzy matching**: For approximate string matching in search applications
3. **Optimize patterns**: Use atomic groups and possessive quantifiers to prevent backtracking
4. **Handle Unicode properly**: Use UNICODE