<!-- Auto-generated by Claude on 2025-06-02 06:15 -->

# Six Library Documentation

## Overview

The **six** library is a Python 2 and 3 compatibility utility that provides a unified interface for writing code that runs on both Python 2 and 3. It handles the major differences between the two Python versions by providing compatibility wrappers, moved modules, and utility functions.

## Purpose

- **Cross-version compatibility**: Write code once that works on both Python 2 and 3
- **Module reorganization**: Handle modules that were moved or renamed between Python versions
- **Type system differences**: Abstract away differences in string, integer, and class types
- **Function differences**: Provide consistent interfaces for functions that changed between versions

## Key Features

### Version Detection Constants

```python
PY2 = sys.version_info[0] == 2     # True if running Python 2
PY3 = sys.version_info[0] == 3     # True if running Python 3
PY34 = sys.version_info[0:2] >= (3, 4)  # True if Python 3.4+
```

### Type Abstractions

The library provides version-agnostic type references:

- `string_types`: `str` in Python 3, `basestring` in Python 2
- `integer_types`: `int` in Python 3, `(int, long)` in Python 2
- `text_type`: `str` in Python 3, `unicode` in Python 2
- `binary_type`: `bytes` in Python 3, `str` in Python 2

## Important Classes

### `MovedModule`

Handles modules that were moved or renamed between Python versions.

```python
class MovedModule(_LazyDescr):
    def __init__(self, name, old, new=None):
        # Maps old module name (Python 2) to new name (Python 3)
```

### `MovedAttribute`

Handles individual functions or classes that moved between modules.

```python
class MovedAttribute(_LazyDescr):
    def __init__(self, name, old_mod, new_mod, old_attr=None, new_attr=None):
        # Maps attributes from old locations to new locations
```

### `_SixMetaPathImporter`

A PEP 302 meta path importer that enables the `six.moves` import system.

**Key methods:**
- `find_module()`: Locates six.moves modules
- `load_module()`: Loads the appropriate module for the Python version
- `is_package()`: Determines if a module is a package

## Important Functions

### String and Binary Handling

```python
def b(s):
    """Create byte literals that work on both Python 2 and 3"""

def u(s):
    """Create text literals that work on both Python 2 and 3"""

def ensure_binary(s, encoding='utf-8', errors='strict'):
    """Coerce s to binary type (bytes in Py3, str in Py2)"""

def ensure_str(s, encoding='utf-8', errors='strict'):
    """Coerce s to native str type"""

def ensure_text(s, encoding='utf-8', errors='strict'):
    """Coerce s to text type (str in Py3, unicode in Py2)"""
```

### Exception Handling

```python
def reraise(tp, value, tb=None):
    """Reraise an exception with traceback"""

def raise_from(value, from_value):
    """Raise exception with cause (Python 3 style)"""
```

### Metaclass Utilities

```python
def with_metaclass(meta, *bases):
    """Create a base class with a metaclass"""

def add_metaclass(metaclass):
    """Class decorator for creating a class with a metaclass"""
```

### Dictionary Iteration

```python
def iterkeys(d, **kw):
    """Return an iterator over dictionary keys"""

def itervalues(d, **kw):
    """Return an iterator over dictionary values"""

def iteritems(d, **kw):
    """Return an iterator over dictionary (key, value) pairs"""
```

## The `moves` Module

The `six.moves` module provides a unified namespace for modules that were reorganized between Python 2 and 3:

### Common Moved Modules

- `six.moves.urllib` - URL handling libraries
- `six.moves.configparser` - Configuration file parser
- `six.moves.queue` - Queue data structures  
- `six.moves.tkinter` - GUI toolkit
- `six.moves.builtins` - Built-in functions
- `six.moves.http_client` - HTTP client functionality

### Usage Example

```python
from six.moves import urllib
from six.moves import configparser
from six.moves.urllib.parse import urlparse
```

## Usage Examples

### Basic Type Checking

```python
import six

if six.PY3:
    # Python 3 specific code
    pass
elif six.PY2:
    # Python 2 specific code
    pass

# Type checking
if isinstance(data, six.string_types):
    # Handle string data
    pass
```

### String Literals

```python
import six

# Byte literals
data = six.b("hello world")

# Text literals  
text = six.u("unicode string")

# Ensure proper types
binary_data = six.ensure_binary(user_input)
text_data = six.ensure_text(user_input)
```

### Metaclasses

```python
import six

@six.add_metaclass(MyMetaclass)
class MyClass(object):
    pass

# Or alternatively:
class MyClass(six.with_metaclass(MyMetaclass, BaseClass)):
    pass
```

## Notes and Recommendations

### Performance Considerations
- The lazy loading system minimizes import overhead
- Modules are only loaded when actually accessed
- Use version constants (`PY2`, `PY3`) for performance-critical version checks

### Best Practices
- Import specific items from `six.moves` rather than the entire module
- Use the type constants (`string_types`, `text_type`, etc.) for type checking
- Prefer `six.ensure_*` functions for reliable type coercion
- Use `@six.python_2_unicode_compatible` decorator for classes with `__str__`