<!-- Auto-generated by Claude on 2025-06-02 06:15 -->

# typing_extensions.py Documentation

## Overview

This file is the **typing_extensions** module, which provides backports of new typing features from newer Python versions to older versions. It serves as a bridge allowing developers to use modern typing constructs while maintaining compatibility with older Python versions.

## Purpose

- **Backwards Compatibility**: Allows use of newer typing features on older Python versions
- **Forward Compatibility**: Enables code to work across multiple Python versions 
- **Feature Staging**: Provides experimental typing features before they're added to the standard library
- **Consistency**: Ensures uniform typing behavior across Python versions

## Key Components

### Version Detection and Compatibility

The module extensively uses version checking to provide appropriate implementations:

```python
if sys.version_info >= (3, 11):
    # Use standard library version
    from typing import Any
else:
    # Provide backport implementation
    class Any(metaclass=_AnyMeta):
        # Custom implementation
```

### Major Feature Categories

#### 1. Type Variables and Generics

- **`TypeVar`**: Enhanced with PEP 696 default parameters
- **`TypeVarTuple`**: Type variable tuples for variadic generics
- **`ParamSpec`**: Parameter specifications for callable types
- **`Generic`**: Base class for user-defined generic types

#### 2. Special Typing Forms

- **`Any`**: Type that is compatible with all types
- **`Final`**: Marks variables as final (cannot be reassigned)
- **`Literal`**: Literal value types
- **`Union`**: Union types (replaced by `|` operator in newer versions)
- **`Optional`**: Shorthand for `Union[X, None]`

#### 3. Protocols and Structural Typing

- **`Protocol`**: Base class for structural subtyping
- **`runtime_checkable`**: Decorator to enable runtime protocol checking
- **Support protocols**: `SupportsInt`, `SupportsFloat`, etc.

#### 4. TypedDict Enhancements

- **`TypedDict`**: Dictionary with fixed set of keys and typed values
- **`Required`/`NotRequired`**: Mark keys as required/optional
- **`ReadOnly`**: Mark keys as read-only

#### 5. Advanced Type Constructs

- **`Annotated`**: Add metadata to type annotations
- **`TypeGuard`/`TypeIs`**: Type narrowing in user-defined functions
- **`Never`**: Bottom type (no values)
- **`Self`**: Reference to enclosing class type

### Important Classes

#### `_ProtocolMeta`

Metaclass for Protocol that handles:
- Runtime type checking for protocols
- Attribute collection and validation
- Subclass and instance checks

#### `TypeAliasType`

Creates named, parameterized type aliases (backport of Python 3.12 `type` statement):

```python
# Python 3.12+: type ListOrSet[T] = list[T] | set[T]
# Backport equivalent:
T = TypeVar("T")
ListOrSet = TypeAliasType("ListOrSet", list[T] | set[T], type_params=(T,))
```

#### `deprecated`

Decorator for marking deprecated code with warnings:

```python
@deprecated("Use new_function instead")
def old_function():
    pass
```

### Utility Functions

#### Type Introspection

- **`get_origin()`**: Get the unsubscripted version of a type
- **`get_args()`**: Get type arguments with substitutions performed
- **`get_type_hints()`**: Enhanced version with format parameter
- **`is_protocol()`**: Check if type is a Protocol
- **`is_typeddict()`**: Check if type is a TypedDict

#### Development Helpers

- **`reveal_type()`**: Print type information for debugging
- **`assert_type()`**: Assert type for type checker
- **`assert_never()`**: Mark unreachable code

## Usage Examples

### Basic Type Annotations

```python
from typing_extensions import TypeVar, Generic, Final

T = TypeVar('T')

class Stack(Generic[T]):
    def __init__(self) -> None:
        self._items: list[T] = []
    
    def push(self, item: T) -> None:
        self._items.append(item)

MAX_SIZE: Final = 100
```

### Protocols

```python
from typing_extensions import Protocol, runtime_checkable

@runtime_checkable
class Drawable(Protocol):
    def draw(self) -> None: ...

def render(obj: Drawable) -> None:
    obj.draw()
```

### TypedDict

```python
from typing_extensions import TypedDict, Required, NotRequired

class Movie(TypedDict):
    title: Required[str]
    year: int
    rating: NotRequired[float]
```

## Important Notes

### Performance Considerations

- Some backported implementations may be slower than native versions
- Runtime protocol checking has overhead
- Version detection happens at import time

### Compatibility Warnings

- Features may have different behavior across Python versions
- Some runtime features cannot be fully backported
- Always test with target Python versions

### Migration Path

When upgrading Python versions:
1. Check which features are available in standard `typing`
2. Gradually migrate from `typing_extensions` to `typing`
3. Update import statements as needed

## Suggestions

### For Library Authors

- Use `typing_extensions` to support multiple Python versions
- Provide clear documentation about minimum Python versions
- Consider conditional imports based on Python version

### For Application Developers

- Pin `typing_extensions` version for stability
- Use modern typing features even on older Python versions
- Leverage type checking tools like mypy or pyright

### Best Practices

- Import specific items rather than using `*`
- Use version guards when mixing standard library and extensions
- Keep type annotations in stub files for complex scenarios
- Test type checking behavior across supported Python versions