<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# HTTP Connection Interfaces Documentation

## Overview

This file defines the core interfaces and type definitions for HTTP and HTTPS connections in the urllib3 library. It provides protocol definitions that establish the contract for connection implementations, along with supporting configuration classes and type aliases.

## Purpose

The file serves as a specification layer that:
- Defines common interfaces for HTTP/HTTPS connection classes
- Establishes type safety through protocol definitions
- Provides configuration structures for proxy and response handling
- Ensures consistent API contracts across different connection implementations

## Type Definitions

### `_TYPE_BODY`
```python
_TYPE_BODY = typing.Union[bytes, typing.IO[typing.Any], typing.Iterable[bytes], str]
```
Defines the acceptable types for HTTP request bodies, supporting various input formats including raw bytes, file-like objects, iterables, and strings.

## Configuration Classes

### `ProxyConfig`
A named tuple that encapsulates proxy-related configuration:

```python
class ProxyConfig(typing.NamedTuple):
    ssl_context: ssl.SSLContext | None
    use_forwarding_for_https: bool
    assert_hostname: None | str | typing.Literal[False]
    assert_fingerprint: str | None
```

**Fields:**
- `ssl_context`: SSL context for proxy connections
- `use_forwarding_for_https`: Whether to use HTTP forwarding for HTTPS requests
- `assert_hostname`: Hostname verification setting
- `assert_fingerprint`: Expected certificate fingerprint

### `_ResponseOptions`
Internal configuration for response handling:

```python
class _ResponseOptions(typing.NamedTuple):
    request_method: str
    request_url: str
    preload_content: bool
    decode_content: bool
    enforce_content_length: bool
```

> **Note:** This class is marked for removal in favor of better HTTP request/response lifecycle tracking.

## Protocol Interfaces

### `BaseHTTPConnection`

The fundamental protocol for HTTP connections, defining the required interface for all HTTP connection implementations.

#### Key Attributes:
- `host`, `port`: Connection target
- `timeout`: Request timeout configuration  
- `blocksize`: Buffer size for data transfer
- `proxy`, `proxy_config`: Proxy configuration
- `is_verified`, `proxy_is_verified`: Certificate verification status

#### Core Methods:

##### `__init__()`
```python
def __init__(
    self,
    host: str,
    port: int | None = None,
    *,
    timeout: _TYPE_TIMEOUT = _DEFAULT_TIMEOUT,
    source_address: tuple[str, int] | None = None,
    blocksize: int = 8192,
    socket_options: _TYPE_SOCKET_OPTIONS | None = ...,
    proxy: Url | None = None,
    proxy_config: ProxyConfig | None = None,
) -> None: ...
```

##### `request()`
```python
def request(
    self,
    method: str,
    url: str,
    body: _TYPE_BODY | None = None,
    headers: typing.Mapping[str, str] | None = None,
    *,
    chunked: bool = False,
    preload_content: bool = True,
    decode_content: bool = True,
    enforce_content_length: bool = True,
) -> None: ...
```

> **Important:** The first 3 parameters maintain their order for backward compatibility with libraries like botocore.

#### Connection State Properties:

- `is_closed`: Whether connection is new or previously closed
- `is_connected`: Whether actively connected to any origin
- `has_connected_to_proxy`: Whether successfully connected to proxy

### `BaseHTTPSConnection`

Extends `BaseHTTPConnection` with SSL/TLS-specific functionality.

#### Additional SSL Attributes:
- **Certificate Verification**: `cert_reqs`, `assert_hostname`, `assert_fingerprint`, `ssl_context`
- **Certificate Authority**: `ca_certs`, `ca_cert_dir`, `ca_cert_data`  
- **TLS Versions**: `ssl_minimum_version`, `ssl_maximum_version`, `ssl_version`
- **Client Certificates**: `cert_file`, `key_file`, `key_password`

#### Key Differences from HTTP:
- Default `blocksize` is 16384 (vs 8192 for HTTP)
- Extensive SSL/TLS configuration options
- Additional certificate and encryption parameters

## Usage Notes

### Design Patterns
- Uses Protocol-based typing for flexible implementation
- Named tuples provide immutable configuration objects
- Type checking is conditional (`if typing.TYPE_CHECKING:`) to avoid runtime overhead

### Backward Compatibility
- Parameter ordering preserved for external library compatibility
- Keyword-only parameters used strategically to allow future extensions

### Performance Considerations  
- Different default block sizes optimized for HTTP (8KB) vs HTTPS (16KB)
- Lazy imports and conditional type checking minimize runtime impact

## Suggestions for Implementation

When implementing these protocols:

1. **Thread Safety**: Consider thread-safety requirements for connection pooling
2. **Error Handling**: Implement robust error handling for network failures
3. **Resource Management**: Ensure proper cleanup of sockets and SSL contexts
4. **Logging**: Add comprehensive logging for debugging connection issues
5. **Testing**: Mock these protocols for unit testing HTTP client code