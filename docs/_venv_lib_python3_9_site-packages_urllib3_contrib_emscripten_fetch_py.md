<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Emscripten HTTP Streaming Support

## Overview

This module provides HTTP request streaming capabilities for Python applications running in Emscripten (browser/WebAssembly) environments. It supports two main approaches for handling HTTP requests:

1. **WebAssembly JavaScript Promise Integration (JSPI)** - Modern approach using async JavaScript fetch API
2. **Web Worker + SharedArrayBuffer** - Fallback approach for streaming in web workers

## Purpose

The module enables Python HTTP libraries (like urllib3) to work efficiently in browser environments by providing:
- Streaming HTTP responses to avoid loading entire responses into memory
- Timeout support for HTTP requests
- Cross-origin isolation support
- Compatibility with both browser main thread and web worker contexts

## Important Classes

### `_ReadStream`

A streaming reader class that implements `io.RawIOBase` for reading HTTP response data.

```python
class _ReadStream(io.RawIOBase):
    def __init__(self, int_buffer, byte_buffer, timeout, worker, connection_id, request):
        # Initializes streaming reader with shared buffers
```

**Key Methods:**
- `readinto(byte_obj)` - Reads data into a buffer object
- `close()` - Closes the stream and cleans up resources
- `is_closed()` - Returns stream status

### `_JSPIReadStream`

A streaming reader for the JSPI approach using JavaScript fetch responses.

```python
class _JSPIReadStream(io.RawIOBase):
    def __init__(self, js_read_stream, timeout, request, response, js_abort_controller):
        # Initializes JSPI-based streaming reader
```

### `_StreamingFetcher`

Manages web worker-based streaming HTTP requests using SharedArrayBuffer.

```python
class _StreamingFetcher:
    def __init__(self):
        # Creates web worker and sets up data buffers
    
    def send(self, request: EmscriptenRequest) -> EmscriptenResponse:
        # Sends streaming HTTP request via web worker
```

## Key Functions

### Core Request Functions

#### `send_streaming_request(request)`

Sends an HTTP request with streaming support.

```python
def send_streaming_request(request: EmscriptenRequest) -> EmscriptenResponse | None:
    # Attempts streaming request, falls back to None if not available
```

#### `send_request(request)`

Sends a standard (non-streaming) HTTP request using XMLHttpRequest.

```python
def send_request(request: EmscriptenRequest) -> EmscriptenResponse:
    # Sends synchronous HTTP request
```

#### `send_jspi_request(request, streaming)`

Sends HTTP request using WebAssembly JavaScript Promise Integration.

```python
def send_jspi_request(request: EmscriptenRequest, streaming: bool) -> EmscriptenResponse:
    # Uses modern async fetch API with JSPI
```

### Environment Detection Functions

#### `has_jspi()`

Checks if WebAssembly JavaScript Promise Integration is available.

```python
def has_jspi() -> bool:
    # Returns True if JSPI can be used
```

#### `is_cross_origin_isolated()`

Checks if the page has cross-origin isolation enabled (required for SharedArrayBuffer).

```python
def is_cross_origin_isolated() -> bool:
    # Returns True if crossOriginIsolated is enabled
```

#### `streaming_ready()`

Checks if streaming capabilities are ready to use.

```python
def streaming_ready() -> bool | None:
    # Returns streaming readiness status
```

## Requirements and Caveats

### Cross-Origin Isolation

For web worker-based streaming, you need to serve your application with these headers:

```
Cross-Origin-Opener-Policy: same-origin
Cross-Origin-Embedder-Policy: require-corp
```

### Web Worker Limitations

- Streaming only works in web workers, not the main UI thread
- Requires `SharedArrayBuffer` support
- Uses `Atomics.wait()` which blocks the thread

### JSPI Requirements

- Browser must support WebAssembly JavaScript Promise Integration
- Must launch Pyodide using `pyodide.runPythonAsync`
- Node.js requires `--experimental-wasm-stack-switching` flag (for versions < 24)

## Usage Examples

### Basic Usage

```python
from .request import EmscriptenRequest

# Create a request
request = EmscriptenRequest(
    method="GET",
    url="https://api.example.com/data",
    headers={"Accept": "application/json"},
    timeout=30.0
)

# Send streaming request
response = send_streaming_request(request)
if response:
    # Stream is available
    data = response.body.read()
else:
    # Fall back to regular request
    response = send_request(request)
    data = response.body
```

### Wait for Streaming Ready

```python
# Ensure streaming is ready before making requests
if await wait_for_streaming_ready():
    print("Streaming is ready!")
else:
    print("Streaming not available")
```

## Error Handling

The module defines custom exceptions:

- `_RequestError` - Base exception for request errors
- `_StreamingError` - Streaming-specific errors
- `_TimeoutError` - Timeout-related errors

## Constants

```python
HEADERS_TO_IGNORE = ("user-agent",)  # Headers that trigger CORS preflight

# Worker communication status codes
SUCCESS_HEADER = -1
SUCCESS_EOF = -2
ERROR_TIMEOUT = -3
ERROR_EXCEPTION = -4
```

## Notes and Suggestions

1. **Performance**: JSPI approach is preferred when available as it's more efficient
2. **Compatibility**: Always check environment capabilities before attempting streaming
3. **Error Handling**: Implement proper fallback mechanisms for unsupported environments
4. **Memory Management**: Streaming helps reduce memory usage for large responses
5. **Testing**: Test in different browser environments as support varies

## Browser Support

- **Chrome/Edge**: Full support with proper flags
- **Firefox**: Limited JSPI support
- **Safari**: Varies by version
- **Node.js**: Requires experimental flags for JSPI