<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# EmscriptenRequest Module

## Overview

This module provides a dataclass implementation for HTTP requests specifically designed for the Emscripten environment. Emscripten is a toolchain for compiling to WebAssembly, and this class likely serves as a bridge between Python HTTP client code and web-based HTTP requests.

## Purpose

The `EmscriptenRequest` class encapsulates all necessary components of an HTTP request in a structured format, making it easier to handle HTTP operations in WebAssembly/browser environments where traditional Python HTTP libraries may not work directly.

## Classes

### `EmscriptenRequest`

A dataclass that represents an HTTP request with all necessary parameters and helper methods.

#### Attributes

- **`method`** (`str`): HTTP method (GET, POST, PUT, DELETE, etc.)
- **`url`** (`str`): Target URL for the request
- **`params`** (`dict[str, str] | None`): URL query parameters (optional)
- **`body`** (`_TYPE_BODY | None`): Request body content (optional)
- **`headers`** (`dict[str, str]`): HTTP headers (defaults to empty dict)
- **`timeout`** (`float`): Request timeout in seconds (defaults to 0)
- **`decode_content`** (`bool`): Whether to decode response content (defaults to True)

#### Methods

##### `set_header(name: str, value: str) -> None`

Sets an HTTP header with automatic capitalization of the header name.

**Parameters:**
- `name`: Header name (will be capitalized)
- `value`: Header value

**Example:**
```python
request = EmscriptenRequest(method="GET", url="https://api.example.com")
request.set_header("content-type", "application/json")
# Results in headers["Content-Type"] = "application/json"
```

##### `set_body(body: _TYPE_BODY | None) -> None`

Sets the request body content.

**Parameters:**
- `body`: Request body data (type defined by `_TYPE_BODY` from base connection module)

**Example:**
```python
request = EmscriptenRequest(method="POST", url="https://api.example.com")
request.set_body('{"key": "value"}')
```

## Dependencies

- **`dataclasses`**: For the `@dataclass` decorator and `field` function
- **`_base_connection`**: Imports `_TYPE_BODY` type definition

## Usage Example

```python
# Create a GET request
request = EmscriptenRequest(
    method="GET",
    url="https://api.example.com/data",
    params={"page": "1", "limit": "10"},
    timeout=30.0
)

# Add headers
request.set_header("authorization", "Bearer token123")
request.set_header("user-agent", "MyApp/1.0")

# Create a POST request with body
post_request = EmscriptenRequest(
    method="POST",
    url="https://api.example.com/submit"
)
post_request.set_body('{"name": "John", "age": 30}')
post_request.set_header("content-type", "application/json")
```

## Notes and Suggestions

### Design Considerations

- **Header Capitalization**: The `set_header` method automatically capitalizes header names, which follows HTTP header conventions but may not always be desired
- **Default Timeout**: The default timeout of 0 may indicate no timeout or infinite timeout - this should be clearly documented
- **Immutable Alternative**: Consider if some fields should be read-only after initialization

### Potential Improvements

1. **Header Name Normalization**: Consider using a more sophisticated header name normalization (e.g., "content-type" â†’ "Content-Type")

2. **Validation**: Add validation for required fields:
   ```python
   def __post_init__(self):
       if not self.method:
           raise ValueError("Method cannot be empty")
       if not self.url:
           raise ValueError("URL cannot be empty")
   ```

3. **Type Hints**: The `_TYPE_BODY` type should be documented or the actual types should be specified

4. **Method Validation**: Consider validating HTTP methods:
   ```python
   VALID_METHODS = {"GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS"}
   ```

### Integration Notes

- This class appears to be part of a larger HTTP client library designed for Emscripten/WebAssembly environments
- The structure suggests it's used as an intermediate representation before making actual HTTP calls in the browser environment