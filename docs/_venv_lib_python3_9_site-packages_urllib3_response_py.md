<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# HTTPResponse Module Documentation

## Overview

This module provides HTTP response handling functionality for urllib3, including content decoding, streaming, and compatibility with Python's standard library. It implements HTTP response parsing with support for various compression formats and chunked transfer encoding.

## Purpose

The module serves as a bridge between low-level HTTP responses and high-level Python applications, providing:
- Content decoding (gzip, deflate, brotli, zstd)
- Streaming response handling
- Chunked transfer encoding support
- Compatibility with `http.client.HTTPResponse` and `io` module interfaces

## Key Classes

### Content Decoders

#### `ContentDecoder`
Base class for content decoders.

```python
class ContentDecoder:
    def decompress(self, data: bytes) -> bytes:
        raise NotImplementedError()
    
    def flush(self) -> bytes:
        raise NotImplementedError()
```

#### `DeflateDecoder`
Handles deflate compression with fallback for raw deflate data.

```python
decoder = DeflateDecoder()
decompressed = decoder.decompress(compressed_data)
```

#### `GzipDecoder`
Handles gzip compression with support for multiple members.

```python
decoder = GzipDecoder()
decompressed = decoder.decompress(gzip_data)
```

#### `BrotliDecoder` (optional)
Handles Brotli compression when the `brotli` library is available.

#### `ZstdDecoder` (optional)
Handles Zstandard compression when the `zstandard` library is available.

#### `MultiDecoder`
Handles multiple encodings applied in sequence (e.g., "gzip, deflate").

### Utility Classes

#### `BytesQueueBuffer`
Memory-efficient buffer for managing decoded response data.

```python
buffer = BytesQueueBuffer()
buffer.put(data)
chunk = buffer.get(1024)  # Get up to 1024 bytes
all_data = buffer.get_all()  # Get all remaining data
```

**Key features:**
- Efficient memory usage for streaming responses
- FIFO queue behavior
- Partial read support

### Response Classes

#### `BaseHTTPResponse`
Abstract base class defining the HTTP response interface.

**Key properties:**
- `status`: HTTP status code
- `headers`: Response headers as `HTTPHeaderDict`
- `version`: HTTP version
- `reason`: HTTP reason phrase

**Key methods:**
- `json()`: Parse response body as JSON
- `get_redirect_location()`: Get redirect URL if applicable
- `stream()`: Stream response data
- `read()`: Read response data

#### `HTTPResponse`
Concrete implementation of HTTP response handling.

```python
response = HTTPResponse(
    body=response_body,
    headers=headers,
    status=200,
    preload_content=True,
    decode_content=True
)

# Read all data
data = response.read()

# Read specific amount
chunk = response.read(1024)

# Stream data
for chunk in response.stream():
    process(chunk)

# Parse as JSON
json_data = response.json()
```

## Important Functions

### `_get_decoder(mode: str) -> ContentDecoder`
Factory function that returns appropriate decoder based on content encoding.

```python
decoder = _get_decoder("gzip")
decoder = _get_decoder("gzip, deflate")  # Returns MultiDecoder
```

**Supported encodings:**
- `gzip`, `x-gzip` → `GzipDecoder`
- `br` → `BrotliDecoder` (if available)
- `zstd` → `ZstdDecoder` (if available)
- `deflate` → `DeflateDecoder`
- Multiple encodings → `MultiDecoder`

## Key Features

### Content Decoding
- Automatic detection of content encoding from headers
- Support for multiple compression formats
- Graceful fallback for unsupported formats

### Streaming Support
- Memory-efficient streaming for large responses
- Chunked transfer encoding support
- Configurable buffer sizes

### Error Handling
- Comprehensive error catching and conversion
- Timeout handling
- SSL error management
- Protocol error detection

### Compatibility
- Compatible with `http.client.HTTPResponse`
- Implements `io.IOBase` interface
- Backward compatibility with older urllib3 versions

## Usage Examples

### Basic Response Reading

```python
# Read entire response
data = response.read()

# Read with specific decoding
data = response.read(decode_content=True)

# Read partial data
chunk = response.read(1024)
```

### Streaming Large Responses

```python
# Stream with default chunk size
for chunk in response.stream():
    process_chunk(chunk)

# Stream with custom chunk size
for chunk in response.stream(amt=8192):
    process_chunk(chunk)
```

### JSON Response Handling

```python
try:
    json_data = response.json()
except (UnicodeDecodeError, json.JSONDecodeError) as e:
    handle_json_error(e)
```

### Chunked Transfer Encoding

```python
if response.chunked:
    for chunk in response.read_chunked():
        process_chunk(chunk)
```

## Notes and Suggestions

### Performance Considerations
- Use streaming for large responses to avoid memory issues
- Consider `preload_content=False` for very large responses
- Buffer sizes can be tuned based on network conditions

### Error Handling
- Always handle `DecodeError` for compressed content
- Check for `IncompleteRead` in network error scenarios
- Use context managers or try/finally for proper cleanup

### Memory Management
- The `BytesQueueBuffer` helps minimize memory overhead
- Large responses should be processed in chunks
- Consider connection pooling for multiple requests

### Compatibility Notes
- Some features require optional dependencies (brotli, zstandard)
- Deprecated methods (`getheader`, `getheaders`) will be removed
- SSL handling varies between Python versions and OpenSSL implementations

### Security Considerations
- Content-Length validation is enforced by default
- Compressed content is automatically validated
- Large responses are protected against memory exhaustion