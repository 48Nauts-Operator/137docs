<!-- Auto-generated by Claude on 2025-06-02 06:15 -->

# urllib3 HTTP Response Module Documentation

## Overview

This module provides HTTP response handling capabilities for urllib3, implementing content decoding, streaming, and compatibility with Python's standard library HTTP client. It includes support for various compression formats (gzip, deflate, brotli, zstandard) and chunked transfer encoding.

## Key Components

### Content Decoders

The module implements several content decoders for handling compressed HTTP responses:

#### `ContentDecoder` (Base Class)
Abstract base class for all content decoders.

```python
class ContentDecoder:
    def decompress(self, data: bytes) -> bytes:
        raise NotImplementedError()
    
    def flush(self) -> bytes:
        raise NotImplementedError()
```

#### `DeflateDecoder`
Handles deflate compression with fallback for raw deflate streams.

#### `GzipDecoder`
Handles gzip compression, including support for multiple gzip members and trailing data.

#### `BrotliDecoder` (Optional)
Handles Brotli compression if the `brotli` or `brotlicffi` package is available.

#### `ZstdDecoder` (Optional)
Handles Zstandard compression if the `zstandard` package is available (version 0.18+).

#### `MultiDecoder`
Handles multiple content encodings applied in sequence (e.g., "gzip, deflate").

### Buffer Management

#### `BytesQueueBuffer`
Memory-efficient buffer for managing decoded response data:

```python
buffer = BytesQueueBuffer()
buffer.put(data)  # Add data to buffer
chunk = buffer.get(1024)  # Get up to 1024 bytes
all_data = buffer.get_all()  # Get all buffered data
```

**Features:**
- Efficient memory usage for partial reads
- FIFO (first-in, first-out) data retrieval
- Automatic size tracking

### Response Classes

#### `BaseHTTPResponse`
Abstract base class providing common response functionality:

- **Content decoding** support for multiple formats
- **Redirect detection** via `get_redirect_location()`
- **JSON parsing** via `json()` method
- **Streaming** capabilities
- **Compatibility methods** for `http.client.HTTPResponse`

#### `HTTPResponse`
Concrete implementation of HTTP response handling:

```python
response = HTTPResponse(
    body=response_body,
    headers=headers,
    status=200,
    preload_content=True,
    decode_content=True
)

# Read response data
data = response.read()
json_data = response.json()

# Stream response
for chunk in response.stream():
    process_chunk(chunk)
```

## Important Methods

### Reading Response Data

#### `read(amt=None, decode_content=None, cache_content=False)`
Primary method for reading response data:
- **`amt`**: Number of bytes to read (None for all)
- **`decode_content`**: Whether to decode compressed content
- **`cache_content`**: Whether to cache the full response

#### `read1(amt=None, decode_content=None)`
Similar to `read()` but performs only one read operation on the underlying socket.

#### `stream(amt=2**16, decode_content=None)`
Generator that yields chunks of response data:

```python
for chunk in response.stream(amt=8192):
    if chunk:
        process_chunk(chunk)
```

#### `read_chunked(amt=None, decode_content=None)`
Handles chunked transfer encoding responses.

### Content Management

#### `json()`
Parses response body as JSON:

```python
try:
    data = response.json()
except json.JSONDecodeError:
    print("Invalid JSON response")
```

#### `data` (Property)
Returns the complete response body as bytes. Automatically reads and caches content if not already loaded.

### Connection Management

#### `release_conn()`
Returns the connection to the connection pool for reuse.

#### `drain_conn()`
Reads and discards remaining response data to allow connection reuse.

#### `close()`
Closes the response and underlying connection.

## Configuration Options

### Content Decoding
- **`decode_content`**: Enable/disable automatic content decoding
- **Supported formats**: gzip, deflate, brotli (optional), zstandard (optional)

### Content Loading
- **`preload_content`**: Load entire response body during initialization
- **`cache_content`**: Cache response data for repeated access

### Content Length Enforcement
- **`enforce_content_length`**: Validate response length matches Content-Length header

### Connection Behavior
- **`auto_close`**: Automatically close response when done reading

## Error Handling

The module provides comprehensive error handling and converts low-level exceptions to urllib3-specific exceptions:

- **`DecodeError`**: Content decoding failures
- **`IncompleteRead`**: Premature connection closure
- **`ProtocolError`**: HTTP protocol violations
- **`ReadTimeoutError`**: Socket read timeouts
- **`SSLError`**: SSL-related errors

## Usage Examples

### Basic Response Reading

```python
# Read entire response
response = HTTPResponse(body=data, headers=headers, status=200)
content = response.read()

# Read with size limit
chunk = response.read(amt=1024)
```

### Streaming Large Responses

```python
# Stream in chunks
for chunk in response.stream(amt=8192):
    if chunk:
        file.write(chunk)
```

### JSON Responses

```python
# Parse JSON response
try:
    data = response.json()
    print(f"Received: {data}")
except json.JSONDecodeError as e:
    print(f"Invalid JSON: {e}")
```

### Handling Compressed Content

```python
# Automatic decompression (default)
response = HTTPResponse(body=compressed_data, decode_content=True)
decompressed = response.read()

# Manual handling
response = HTTPResponse(body=compressed_data, decode_content=False)
compressed = response.read()  # Raw compressed data
```

## Notes and Recommendations

### Performance Considerations
- Use streaming for large responses to minimize memory usage
- Enable `preload_content=False` for large files
-