<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Retry Module Documentation

## Overview

This module provides a comprehensive retry mechanism for HTTP requests in urllib3. It handles various types of failures including connection errors, read timeouts, redirects, and server errors with configurable retry policies and backoff strategies.

## Purpose

The retry module allows applications to:
- Automatically retry failed HTTP requests based on configurable policies
- Handle different types of errors (connection, read, redirect, status) with separate retry counts
- Implement exponential backoff with optional jitter between retry attempts
- Respect server-provided `Retry-After` headers
- Track retry history for debugging and monitoring

## Key Classes

### `RequestHistory`

A named tuple that stores metadata about each retry attempt.

```python
RequestHistory(
    method: str | None,
    url: str | None, 
    error: Exception | None,
    status: int | None,
    redirect_location: str | None
)
```

**Fields:**
- `method`: HTTP method used
- `url`: Request URL
- `error`: Exception that occurred (if any)
- `status`: HTTP status code (if response received)
- `redirect_location`: Redirect URL (if applicable)

### `Retry`

The main retry configuration class that manages retry logic and policies.

#### Key Configuration Parameters

- **`total`** (int): Maximum total retries across all error types
- **`connect`** (int): Retries for connection-related errors
- **`read`** (int): Retries for read/timeout errors  
- **`redirect`** (int): Maximum number of redirects to follow
- **`status`** (int): Retries for specific HTTP status codes
- **`other`** (int): Retries for other types of errors
- **`backoff_factor`** (float): Exponential backoff multiplier
- **`backoff_jitter`** (float): Random jitter added to backoff time

#### Default Values

```python
DEFAULT_ALLOWED_METHODS = frozenset([
    "HEAD", "GET", "PUT", "DELETE", "OPTIONS", "TRACE"
])

RETRY_AFTER_STATUS_CODES = frozenset([413, 429, 503])

DEFAULT_REMOVE_HEADERS_ON_REDIRECT = frozenset([
    "Cookie", "Authorization", "Proxy-Authorization"  
])

DEFAULT_BACKOFF_MAX = 120  # seconds
```

## Important Methods

### `__init__()`

Initializes a new Retry configuration with the specified parameters.

```python
retries = Retry(
    total=10,
    connect=5, 
    read=5,
    backoff_factor=0.3,
    status_forcelist=[500, 502, 503, 504]
)
```

### `increment()`

Creates a new Retry object with decremented counters after a failed attempt.

```python
def increment(
    self,
    method: str | None = None,
    url: str | None = None, 
    response: BaseHTTPResponse | None = None,
    error: Exception | None = None,
    _pool: ConnectionPool | None = None,
    _stacktrace: TracebackType | None = None,
) -> Self
```

**Returns:** New Retry instance with updated counters
**Raises:** `MaxRetryError` when retries are exhausted

### `sleep()`

Handles delay between retry attempts, respecting `Retry-After` headers or using exponential backoff.

```python
def sleep(self, response: BaseHTTPResponse | None = None) -> None
```

### `get_backoff_time()`

Calculates the backoff delay using exponential backoff formula:

```
backoff_time = backoff_factor * (2 ** (consecutive_errors - 1)) + random_jitter
```

### `is_retry()`

Determines if a request should be retried based on method, status code, and configuration.

```python
def is_retry(
    self, 
    method: str, 
    status_code: int, 
    has_retry_after: bool = False
) -> bool
```

### `from_int()` (Class Method)

Creates a Retry instance from legacy integer retry counts for backward compatibility.

```python
@classmethod
def from_int(
    cls,
    retries: Retry | bool | int | None,
    redirect: bool | int | None = True, 
    default: Retry | bool | int | None = None,
) -> Retry
```

## Usage Examples

### Basic Usage

```python
# Simple retry configuration
retries = Retry(total=5)

# Per-error-type configuration  
retries = Retry(
    total=10,
    connect=5,
    read=3,
    redirect=2,
    backoff_factor=0.3
)

# Use with connection pool
http = PoolManager(retries=retries)
response = http.request("GET", "https://example.com/")
```

### Advanced Configuration

```python
# Custom retry policy for API calls
api_retries = Retry(
    total=5,
    status_forcelist=[429, 500, 502, 503, 504],
    allowed_methods=["GET", "POST", "PUT"],
    backoff_factor=1,
    backoff_jitter=0.1,
    respect_retry_after_header=True
)
```

### Disabling Retries

```python
# Disable retries completely
response = http.request("GET", "https://example.com/", retries=False)

# Disable specific retry types
retries = Retry(total=5, redirect=False)
```

## Notes and Best Practices

### ⚠️ Important Considerations

- **Idempotency**: Only idempotent HTTP methods are retried by default to avoid unintended side effects
- **Server Load**: Be cautious with aggressive retry policies to avoid overwhelming servers
- **Timeout Configuration**: Combine with appropriate connection and read timeouts
- **Status Codes**: Carefully choose which status codes should trigger retries

### 💡 Recommendations

1. **Set reasonable total limits** to prevent infinite retry loops
2. **Use exponential backoff** (`backoff_factor > 0`) for production systems  
3. **Respect Retry