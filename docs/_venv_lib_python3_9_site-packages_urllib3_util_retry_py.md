<!-- Auto-generated by Claude on 2025-06-02 06:15 -->

# Retry Module Documentation

## Overview

This module provides a comprehensive retry mechanism for HTTP requests in urllib3. It handles various types of failures including connection errors, read timeouts, redirects, and HTTP status codes with configurable retry policies and backoff strategies.

## Purpose

The retry module enables robust HTTP communication by:
- Automatically retrying failed requests based on configurable policies
- Implementing exponential backoff with optional jitter
- Respecting server-side `Retry-After` headers
- Tracking request history for debugging and analysis
- Providing fine-grained control over different types of retry scenarios

## Classes

### `RequestHistory`

A NamedTuple that stores metadata about each retry attempt.

**Fields:**
- `method: str | None` - HTTP method used
- `url: str | None` - Target URL
- `error: Exception | None` - Exception that occurred (if any)
- `status: int | None` - HTTP status code received
- `redirect_location: str | None` - Redirect target URL (if applicable)

### `Retry`

The main retry configuration class that manages retry logic and state.

#### Class Constants

```python
DEFAULT_ALLOWED_METHODS = frozenset(["HEAD", "GET", "PUT", "DELETE", "OPTIONS", "TRACE"])
RETRY_AFTER_STATUS_CODES = frozenset([413, 429, 503])
DEFAULT_REMOVE_HEADERS_ON_REDIRECT = frozenset(["Cookie", "Authorization", "Proxy-Authorization"])
DEFAULT_BACKOFF_MAX = 120
```

#### Constructor Parameters

- **`total`**: Maximum total retries (default: 10)
- **`connect`**: Connection error retries
- **`read`**: Read error retries  
- **`redirect`**: Redirect retries
- **`status`**: Status code retries
- **`other`**: Other error retries
- **`allowed_methods`**: HTTP methods to retry (default: idempotent methods)
- **`status_forcelist`**: Status codes that force retries
- **`backoff_factor`**: Exponential backoff multiplier (default: 0)
- **`backoff_max`**: Maximum backoff time (default: 120s)
- **`raise_on_redirect`**: Whether to raise on redirect exhaustion
- **`raise_on_status`**: Whether to raise on status retry exhaustion
- **`respect_retry_after_header`**: Honor server Retry-After headers
- **`remove_headers_on_redirect`**: Headers to strip on redirects
- **`backoff_jitter`**: Random jitter added to backoff

## Important Methods

### `new(**kwargs) -> Self`

Creates a new Retry instance with updated parameters while preserving existing configuration.

```python
# Create a new retry config with modified total retries
new_retry = retry.new(total=5)
```

### `from_int(retries, redirect=True, default=None) -> Retry`

Class method for backward compatibility that converts integer retry counts to Retry objects.

```python
retry_config = Retry.from_int(5)  # Simple retry count
```

### `increment(method, url, response=None, error=None, _pool=None, _stacktrace=None) -> Self`

Core method that processes a retry attempt and returns a new Retry object with decremented counters.

**Key behaviors:**
- Decrements appropriate retry counters based on error type
- Updates request history
- Raises `MaxRetryError` when retries are exhausted
- Handles different error categories (connection, read, redirect, status, other)

### `sleep(response=None) -> None`

Implements retry delay logic:
- Respects server `Retry-After` headers when present
- Falls back to exponential backoff with optional jitter
- Formula: `backoff_factor * (2 ** (consecutive_errors - 1)) + random_jitter`

### `get_backoff_time() -> float`

Calculates the current backoff delay based on consecutive errors and configuration.

### `is_retry(method, status_code, has_retry_after=False) -> bool`

Determines if a request should be retried based on:
- Method allowlist
- Status code forcelist  
- Retry-After header presence
- Available retry counts

### `is_exhausted() -> bool`

Checks if all retry attempts have been consumed.

## Usage Examples

### Basic Usage

```python
# Default retry configuration
retries = Retry(connect=5, read=2, redirect=5)
http = PoolManager(retries=retries)
response = http.request("GET", "https://example.com/")

# Per-request override
response = http.request("GET", "https://example.com/", retries=Retry(10))

# Disable retries
response = http.request("GET", "https://example.com/", retries=False)
```

### Advanced Configuration

```python
# Custom retry policy with backoff
retries = Retry(
    total=10,
    status=5,
    status_forcelist=[429, 502, 503, 504],
    backoff_factor=0.3,
    backoff_jitter=0.1,
    allowed_methods=["GET", "POST"]
)
```

## Error Handling

The module categorizes errors into specific types:

- **Connection Errors**: `ConnectTimeoutError`, `ProxyError` - Safe to retry
- **Read Errors**: `ReadTimeoutError`, `ProtocolError` - May have side effects  
- **Protocol Errors**: Various HTTP-level issues
- **Status Errors**: HTTP status codes in forcelist

When retries are exhausted, a `MaxRetryError` is raised containing the original error and retry history.

## Notes and Suggestions

### Best Practices

- **Use idempotent methods**: Default allowed methods are safe to retry multiple times
- **Set reasonable limits**: Avoid infinite retry loops with appropriate `total` limits  
- **Configure backoff**: Use exponential backoff for production systems to avoid overwhelming servers
- **Respect server signals**: Keep `respect_retry_after_header=True` for well-behaved clients

### Performance Considerations

- Each retry creates a new `Retry` object with updated state
- Request history grows with each attempt - monitor memory usage for high-retry scenarios
- Backoff