<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# SSL/TLS Utilities Module

This module provides SSL/TLS utilities for secure socket connections, specifically designed for use with urllib3. It handles SSL context creation, certificate verification, and socket wrapping with comprehensive compatibility across different SSL implementations and Python versions.

## Purpose

The module serves as a compatibility layer and utility collection for:
- Creating and configuring SSL contexts with secure defaults
- Wrapping sockets with SSL/TLS encryption
- Certificate fingerprint verification
- Handling different SSL implementations (OpenSSL, PyOpenSSL, LibreSSL)
- Managing SSL version compatibility across Python versions

## Key Constants and Variables

### SSL Configuration
- `ALPN_PROTOCOLS`: Application-Layer Protocol Negotiation protocols (defaults to `["http/1.1"]`)
- `HASHFUNC_MAP`: Maps digest lengths to hash functions for certificate fingerprint verification
- `_SSL_VERSION_TO_TLS_VERSION`: Maps SSL protocol versions to TLS versions

### Compatibility Flags
- `HAS_NEVER_CHECK_COMMON_NAME`: Whether SSL context supports disabling common name checks
- `IS_PYOPENSSL`: Flag indicating if PyOpenSSL is being used
- `SSLContext` and `SSLTransport`: SSL-related classes (None if SSL unavailable)

## Important Functions

### `assert_fingerprint(cert: bytes | None, fingerprint: str) -> None`

Verifies that a certificate matches the expected fingerprint.

```python
# Example usage
cert_bytes = get_certificate()
expected_fingerprint = "sha256:1234567890abcdef..."
assert_fingerprint(cert_bytes, expected_fingerprint)
```

**Parameters:**
- `cert`: Certificate as bytes object
- `fingerprint`: Expected fingerprint as hex string (with optional colons)

**Raises:**
- `SSLError`: If certificate is None, fingerprint format is invalid, or fingerprints don't match

### `create_urllib3_context(...) -> ssl.SSLContext`

Creates and configures an SSL context with secure defaults for urllib3.

```python
# Create context with custom settings
context = create_urllib3_context(
    ssl_minimum_version=ssl.TLSVersion.TLSv1_2,
    cert_reqs=ssl.CERT_REQUIRED,
    ciphers="HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA"
)
```

**Key Parameters:**
- `ssl_minimum_version`/`ssl_maximum_version`: TLS version bounds
- `cert_reqs`: Certificate verification requirements
- `options`: OpenSSL-specific options
- `ciphers`: Allowed cipher suites
- `verify_flags`: Certificate verification flags

**Returns:** Configured `ssl.SSLContext` object

### `ssl_wrap_socket(...) -> ssl.SSLSocket | SSLTransportType`

Wraps a socket with SSL/TLS encryption.

```python
# Wrap a socket with SSL
import socket
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
ssl_sock = ssl_wrap_socket(
    sock,
    server_hostname="example.com",
    ca_certs="/path/to/ca-bundle.crt"
)
```

**Key Parameters:**
- `sock`: Socket to wrap
- `server_hostname`: Expected hostname for SNI
- `ssl_context`: Pre-configured SSL context (optional)
- `ca_certs`/`ca_cert_dir`/`ca_cert_data`: Certificate authority sources
- `tls_in_tls`: Enable TLS-in-TLS for proxy connections

### `resolve_cert_reqs(candidate: None | int | str) -> VerifyMode`

Resolves certificate requirement specifications to SSL constants.

```python
# All equivalent ways to specify CERT_REQUIRED
cert_req1 = resolve_cert_reqs("CERT_REQUIRED")
cert_req2 = resolve_cert_reqs("REQUIRED")
cert_req3 = resolve_cert_reqs(ssl.CERT_REQUIRED)
```

### `is_ipaddress(hostname: str | bytes) -> bool`

Detects if a hostname is an IP address (IPv4 or IPv6).

```python
print(is_ipaddress("192.168.1.1"))     # True
print(is_ipaddress("2001:db8::1"))     # True
print(is_ipaddress("example.com"))     # False
```

## Compatibility Features

### Version Detection Functions

- `_is_bpo_43522_fixed()`: Checks if Python bug #43522 is fixed
- `_is_has_never_check_common_name_reliable()`: Determines if `hostname_checks_common_name` works reliably

### SSL Implementation Handling

The module gracefully handles missing SSL support:
- Imports SSL constants with fallback values
- Provides default implementations when SSL module is unavailable
- Maintains compatibility across different OpenSSL versions

## Security Considerations

### Default Security Settings

The module enforces secure defaults:
- **Minimum TLS version**: TLSv1.2
- **Disabled protocols**: SSLv2, SSLv3 (known vulnerabilities)
- **Compression disabled**: Prevents CRIME attacks
- **Ticket handling**: Controlled to reduce attack surface

### Certificate Verification

- Uses constant-time comparison for fingerprint verification (`hmac.compare_digest`)
- Supports multiple hash algorithms (MD5, SHA1, SHA256)
- Enables strict certificate chain validation on Python 3.13+

## Usage Notes

### Deprecation Warnings

- The `ssl_version` parameter is deprecated in favor of `ssl_minimum_version`
- Use `ssl.TLSVersion` enum for version specification

### Environment Variables

- `SSLKEYLOGFILE`: If set, enables SSL key logging for debugging

### Error Handling

The module raises `SSLError` for SSL-related issues and `ProxySchemeUnsupported` for unsupported proxy configurations.

### Best Practices

1. **Use minimum version only**: Set `ssl_minimum_version` and leave `ssl_maximum_version` as default
2. **Verify certificates**: Always use `ssl.