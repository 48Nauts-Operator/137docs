<!-- Auto-generated by Claude on 2025-06-02 06:15 -->

# SSLTransport Module Documentation

## Overview

The `SSLTransport` module provides a custom SSL/TLS transport layer that wraps existing sockets to establish SSL connections. Unlike Python's standard `SSLSocket` implementation, this transport allows chaining multiple TLS connections together, making it particularly useful for implementing **TLS-in-TLS** scenarios (such as HTTPS connections through SSL proxies).

## Purpose

- Enable TLS-in-TLS functionality for proxy connections
- Provide a socket-like interface for SSL-wrapped connections
- Support buffered I/O operations compatible with Python's `httpclient`
- Handle SSL handshake and data transfer using memory BIO (Basic I/O) objects

## Key Components

### Constants

```python
SSL_BLOCKSIZE = 16384
```
- **Purpose**: Defines the block size for SSL data transfer operations
- **Value**: 16,384 bytes (16 KB)

### Type Definitions

```python
_WriteBuffer = typing.Union[bytearray, memoryview]
_ReturnValue = typing.TypeVar("_ReturnValue")
```
- **`_WriteBuffer`**: Type hint for writable buffer objects
- **`_ReturnValue`**: Generic type variable for return values

## Main Class: SSLTransport

### Class Description

The `SSLTransport` class wraps an existing socket and establishes an SSL connection using memory BIO objects for internal SSL operations.

### Constructor

```python
def __init__(
    self,
    socket: socket.socket,
    ssl_context: ssl.SSLContext,
    server_hostname: str | None = None,
    suppress_ragged_eofs: bool = True,
) -> None
```

**Parameters:**
- `socket`: The underlying socket to wrap
- `ssl_context`: SSL context for the connection
- `server_hostname`: Server hostname for SNI (Server Name Indication)
- `suppress_ragged_eofs`: Whether to suppress SSL EOF errors

### Key Methods

#### SSL Context Validation

```python
@staticmethod
def _validate_ssl_context_for_tls_in_tls(ssl_context: ssl.SSLContext) -> None
```
- **Purpose**: Validates that the SSL context supports `wrap_bio()` method
- **Raises**: `ProxySchemeUnsupported` if TLS-in-TLS is not supported

#### Socket-like Operations

- **`read(len, buffer=None)`**: Read data from the SSL connection
- **`recv(buflen, flags=0)`**: Receive data (socket-compatible method)
- **`send(data, flags=0)`**: Send data over the SSL connection
- **`sendall(data, flags=0)`**: Send all data, handling partial sends

#### SSL-specific Methods

```python
def getpeercert(self, binary_form: bool = False) -> _TYPE_PEER_CERT_RET
def version(self) -> str | None
def cipher(self) -> tuple[str, str, int] | None
def selected_alpn_protocol(self) -> str | None
```

#### File-like Interface

```python
def makefile(self, mode: str, buffering: int | None = None, ...) -> typing.BinaryIO | typing.TextIO
```
- **Purpose**: Creates a file-like object for buffered I/O operations
- **Note**: Required for compatibility with Python's HTTP client libraries

### Core Internal Method

#### `_ssl_io_loop()`

```python
def _ssl_io_loop(self, func, arg1=None, arg2=None) -> _ReturnValue
```

**Purpose**: 
- Handles the core SSL I/O loop between memory BIOs and the underlying socket
- Manages SSL handshake, data transfer, and error handling
- Processes `SSL_ERROR_WANT_READ` and `SSL_ERROR_WANT_WRITE` conditions

**Flow**:
1. Execute the SSL operation (handshake, read, write)
2. Handle SSL errors that require more data
3. Transfer data between memory BIOs and the socket
4. Repeat until operation completes

## Usage Example

```python
import socket
import ssl

# Create underlying socket connection
sock = socket.create_connection(("example.com", 443))

# Create SSL context
context = ssl.create_default_context()

# Create SSL transport
ssl_transport = SSLTransport(
    socket=sock,
    ssl_context=context,
    server_hostname="example.com"
)

# Use like a regular socket
data = ssl_transport.recv(1024)
ssl_transport.send(b"GET / HTTP/1.1\r\nHost: example.com\r\n\r\n")
```

## Important Notes

### Requirements
- The SSL context **must** support the `wrap_bio()` method
- Non-native SSL contexts may not be compatible

### Error Handling
- Suppresses ragged EOF errors by default
- Properly handles SSL want-read/want-write conditions
- Validates method parameters (e.g., flags must be 0)

### Compatibility
- Implements context manager protocol (`__enter__`/`__exit__`)
- Provides socket-compatible interface
- Supports file-like operations for HTTP client compatibility

### Performance Considerations
- Uses memory BIOs for efficient SSL operations
- Handles partial sends/receives automatically
- Block size of 16KB for optimal throughput

## Dependencies

- `ssl`: Python's SSL/TLS module
- `socket`: Standard socket operations
- `io`: For buffered I/O operations
- Custom exception: `ProxySchemeUnsupported`

This implementation is particularly valuable for applications requiring secure proxy connections or other TLS-in-TLS scenarios where standard SSL sockets are insufficient.