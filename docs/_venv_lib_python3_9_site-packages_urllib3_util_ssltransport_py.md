<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# SSLTransport Module Documentation

## Overview

The `SSLTransport` class provides a wrapper around existing sockets to establish SSL/TLS connections with support for **TLS-in-TLS** functionality. Unlike Python's standard `SSLSocket` implementation, this class allows chaining multiple TLS connections together, making it particularly useful for proxy scenarios and nested SSL connections.

## Purpose

- **TLS-in-TLS Support**: Enable multiple layers of TLS encryption
- **Socket API Compatibility**: Provides most standard socket operations
- **Proxy Implementation**: Designed for use in proxy schemes requiring nested SSL
- **Memory BIO Management**: Uses SSL Memory BIO for efficient SSL data handling

## Key Components

### Constants

```python
SSL_BLOCKSIZE = 16384
```
- **Purpose**: Default block size for SSL data transfer operations

### Type Definitions

```python
_WriteBuffer = typing.Union[bytearray, memoryview]
_ReturnValue = typing.TypeVar("_ReturnValue")
```

## Class: SSLTransport

### Constructor

```python
def __init__(
    self,
    socket: socket.socket,
    ssl_context: ssl.SSLContext,
    server_hostname: str | None = None,
    suppress_ragged_eofs: bool = True,
) -> None
```

**Parameters:**
- `socket`: Existing socket to wrap with SSL
- `ssl_context`: SSL context for the connection
- `server_hostname`: Server hostname for SNI (Server Name Indication)
- `suppress_ragged_eofs`: Whether to suppress ragged EOF errors

**Key Features:**
- Creates incoming/outgoing Memory BIOs for SSL data handling
- Performs initial SSL handshake automatically
- Validates SSL context compatibility

### Core Methods

#### Data Transfer Methods

```python
def read(self, len: int = 1024, buffer: typing.Any | None = None) -> int | bytes
def recv(self, buflen: int = 1024, flags: int = 0) -> int | bytes
def recv_into(self, buffer: _WriteBuffer, nbytes: int | None = None, flags: int = 0) -> None | int | bytes
def send(self, data: bytes, flags: int = 0) -> int
def sendall(self, data: bytes, flags: int = 0) -> None
```

- **Purpose**: Provide standard socket-like data transfer operations
- **Note**: All methods reject non-zero flags for simplicity

#### SSL-Specific Methods

```python
def getpeercert(self, binary_form: bool = False) -> _TYPE_PEER_CERT_RET
def version(self) -> str | None
def cipher(self) -> tuple[str, str, int] | None
def selected_alpn_protocol(self) -> str | None
def compression(self) -> str | None
```

- **Purpose**: Expose SSL connection information and properties

#### File Operations

```python
def makefile(
    self,
    mode: str,
    buffering: int | None = None,
    *,
    encoding: str | None = None,
    errors: str | None = None,
    newline: str | None = None,
) -> typing.BinaryIO | typing.TextIO | socket.SocketIO
```

- **Purpose**: Create file-like objects for buffered I/O operations
- **Use Case**: Required for HTTP client compatibility

### Internal Methods

#### SSL I/O Loop

```python
def _ssl_io_loop(
    self,
    func: typing.Callable[..., _ReturnValue],
    arg1: None | bytes | int = None,
    arg2: bytearray | None = None,
) -> _ReturnValue
```

- **Purpose**: Core method handling SSL I/O operations between Memory BIOs and socket
- **Functionality**: 
  - Manages SSL state machine
  - Handles `SSL_ERROR_WANT_READ` and `SSL_ERROR_WANT_WRITE` conditions
  - Transfers data between incoming/outgoing BIOs and underlying socket

#### Validation

```python
@staticmethod
def _validate_ssl_context_for_tls_in_tls(ssl_context: ssl.SSLContext) -> None
```

- **Purpose**: Ensures SSL context supports `wrap_bio()` method required for TLS-in-TLS
- **Raises**: `ProxySchemeUnsupported` if context is incompatible

## Usage Examples

### Basic SSL Transport

```python
import socket
import ssl

# Create underlying socket
sock = socket.create_connection(('example.com', 443))

# Create SSL context
context = ssl.create_default_context()

# Create SSL transport
with SSLTransport(sock, context, server_hostname='example.com') as ssl_transport:
    ssl_transport.sendall(b'GET / HTTP/1.1\r\nHost: example.com\r\n\r\n')
    response = ssl_transport.recv(4096)
```

### TLS-in-TLS Scenario

```python
# First TLS layer (proxy connection)
proxy_transport = SSLTransport(proxy_socket, proxy_context, 'proxy.example.com')

# Second TLS layer (target connection over proxy)
target_transport = SSLTransport(proxy_transport, target_context, 'target.example.com')
```

## Important Notes

### Requirements

- **SSL Context**: Must support `wrap_bio()` method (native Python SSL contexts)
- **Memory Management**: Uses Memory BIOs for efficient SSL data handling
- **Thread Safety**: Not explicitly thread-safe; external synchronization required

### Limitations

- **Flags Parameter**: Most socket methods don't support flags (raises `ValueError` if non-zero)
- **Platform Dependency**: TLS-in-TLS functionality depends on native SSL implementation

### Error Handling

- **Ragged EOFs**: Optionally suppressed (configurable via `suppress_ragged_eofs`)
- **SSL Errors**: Properly propagates SSL-specific exceptions
- **Validation**: Validates SSL context compatibility before use

## Dependencies

- `ssl` module (native SSL support required)
- `socket` module
- `io` module for file-like operations
- Custom exception: `ProxySchemeUnsupported`

This implementation is particularly valuable for applications requiring