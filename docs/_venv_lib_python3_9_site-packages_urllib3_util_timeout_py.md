<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Timeout Module Documentation

## Overview

This module provides timeout configuration functionality for urllib3. It defines a `Timeout` class that manages connection and read timeouts for HTTP requests, allowing fine-grained control over network operation timeouts.

## Purpose

The timeout module enables:
- Setting individual timeouts for connection and read operations
- Managing total timeout that combines connect and read timeouts
- Providing default timeout handling
- Tracking timeout states during network operations

## Classes and Enums

### `_TYPE_DEFAULT`

```python
class _TYPE_DEFAULT(Enum):
    token = -1
```

Internal enum used as a sentinel value to represent default timeout behavior. The value `-1` is used because `socket.settimeout()` raises a `ValueError` for negative values, providing safety against accidental misuse.

### `Timeout`

The main class for timeout configuration and management.

#### Constructor Parameters

- **`total`** (`float | int | None`): Combined timeout for connect and read operations
- **`connect`** (`float | int | None`): Maximum time to wait for connection establishment  
- **`read`** (`float | int | None`): Maximum time to wait between consecutive read operations

#### Key Methods

##### `__init__(total=None, connect=_DEFAULT_TIMEOUT, read=_DEFAULT_TIMEOUT)`

Initializes a new Timeout instance with validation of all timeout values.

##### `from_float(timeout)` (classmethod)

```python
@classmethod
def from_float(cls, timeout: _TYPE_TIMEOUT) -> Timeout:
```

Creates a Timeout object from a legacy single timeout value, applying it to both connect and read timeouts.

##### `clone()`

```python
def clone(self) -> Timeout:
```

Creates a copy of the timeout object. Essential for per-request timeout management since timeout properties are stored per-pool but each request needs a fresh instance.

##### `start_connect()`

```python
def start_connect(self) -> float:
```

Starts the timeout timer for connection attempts. Returns the start time and raises `TimeoutStateError` if called on an already-started timer.

##### `get_connect_duration()`

```python
def get_connect_duration(self) -> float:
```

Returns elapsed time since `start_connect()` was called. Raises `TimeoutStateError` if timer hasn't been started.

#### Properties

##### `connect_timeout`

Returns the effective connection timeout value, considering total timeout constraints.

##### `read_timeout`  

Returns the effective read timeout value, accounting for time already consumed by connection establishment.

#### Static Methods

##### `resolve_default_timeout(timeout)`

```python
@staticmethod
def resolve_default_timeout(timeout: _TYPE_TIMEOUT) -> float | None:
```

Resolves default timeout values by returning the system default timeout when `_DEFAULT_TIMEOUT` is provided.

##### `_validate_timeout(value, name)` (classmethod)

```python
@classmethod
def _validate_timeout(cls, value: _TYPE_TIMEOUT, name: str) -> _TYPE_TIMEOUT:
```

Validates timeout values ensuring they are:
- Numeric (int/float), None, or the default sentinel
- Greater than 0 if numeric
- Not boolean values

## Usage Examples

### Basic Usage

```python
import urllib3

# Create timeout with specific connect and read timeouts
timeout = urllib3.util.Timeout(connect=2.0, read=7.0)

# Use with PoolManager
http = urllib3.PoolManager(timeout=timeout)
resp = http.request("GET", "https://example.com/")
```

### Per-Request Timeouts

```python
# Override pool timeout for specific request
response = http.request("GET", "https://example.com/", 
                       timeout=Timeout(10))
```

### Disabling Timeouts

```python
# Disable all timeouts
no_timeout = Timeout(connect=None, read=None)
response = http.request("GET", "https://example.com/", 
                       timeout=no_timeout)
```

## Important Notes

### Timeout Behavior
- **Total timeout** takes precedence when both total and individual timeouts are specified
- **Read timeout** is dynamically calculated based on time remaining after connection
- **Default timeouts** fall back to system socket defaults

### Limitations
- DNS resolution time is not included in timeout calculations (Python DNS resolver limitation)
- Timeouts measure time between socket operations, not total response time
- Server streaming responses may not trigger timeouts as expected

### Error Handling
- Raises `TimeoutStateError` for improper timer state management
- Raises `ValueError` for invalid timeout values (negative numbers, booleans, invalid types)

## Dependencies

- `time.monotonic()` for accurate timeout measurement
- `socket.getdefaulttimeout()` for system default timeout resolution
- Custom `TimeoutStateError` exception from urllib3.exceptions

## Thread Safety

⚠️ **Warning**: Timeout objects are not thread-safe due to mutable state (`_start_connect`). Use `clone()` method to create separate instances for concurrent operations.