<!-- Auto-generated by Claude on 2025-06-02 06:15 -->

# Socket Waiting Utilities

## Overview

This module provides utilities for waiting on socket I/O operations in a cross-platform manner. It abstracts the differences between various socket waiting mechanisms (`select()`, `poll()`) across different operating systems, particularly handling the differences between Unix-like systems and Windows.

## Purpose

The module is designed to efficiently wait for single socket operations rather than managing multiple sockets simultaneously. It automatically selects the most appropriate waiting mechanism based on the platform and available functionality.

## Key Design Decisions

### Platform-Specific Implementation Selection

The module uses different strategies based on the operating system:

- **Unix-like systems**: Prefers `poll()` over `select()` to avoid file descriptor limitations
- **Windows**: Uses `select()` since `poll()` is not available and `select()` works efficiently
- **Fallback**: Falls back to `select()` if `poll()` is broken or unavailable

### Dynamic Implementation Selection

The implementation is chosen at runtime during the first function call rather than at import time, allowing for proper handling of runtime environment changes or monkey-patching.

## Public API

### Functions

#### `wait_for_read(sock, timeout=None)`

Waits for a socket to become readable.

```python
import socket
from socket_wait import wait_for_read

sock = socket.socket()
# Wait up to 5 seconds for data to be available for reading
if wait_for_read(sock, timeout=5.0):
    data = sock.recv(1024)
else:
    print("Timeout: no data available")
```

**Parameters:**
- `sock`: The socket to monitor
- `timeout`: Maximum time to wait in seconds (None for blocking)

**Returns:** `True` if socket is readable, `False` if timeout expired

#### `wait_for_write(sock, timeout=None)`

Waits for a socket to become writable.

```python
import socket
from socket_wait import wait_for_write

sock = socket.socket()
# Wait up to 3 seconds for socket to be ready for writing
if wait_for_write(sock, timeout=3.0):
    sock.send(b"Hello, World!")
else:
    print("Timeout: socket not ready for writing")
```

**Parameters:**
- `sock`: The socket to monitor  
- `timeout`: Maximum time to wait in seconds (None for blocking)

**Returns:** `True` if socket is writable, `False` if timeout expired

## Internal Implementation

### Core Functions

#### `wait_for_socket(sock, read=False, write=False, timeout=None)`

The main dispatch function that dynamically selects and delegates to the appropriate implementation.

#### `select_wait_for_socket(sock, read=False, write=False, timeout=None)`

Implementation using `select.select()`. Handles Windows-specific behavior where successful non-blocking connections are marked as "exceptional" rather than writable.

#### `poll_wait_for_socket(sock, read=False, write=False, timeout=None)`

Implementation using `select.poll()`. Converts timeout from seconds to milliseconds as required by the poll interface.

#### `_have_working_poll()`

Utility function that tests whether `select.poll()` is available and functional, handling cases where it might be broken due to system configuration or library monkey-patching.

## Important Notes

### Cross-Platform Compatibility

- **Windows**: Uses `select()` exclusively since `poll()` is not available
- **Unix/Linux**: Prefers `poll()` to avoid file descriptor number limitations in `select()`
- **Fallback handling**: Gracefully degrades to `select()` if `poll()` fails

### Error Handling

- Validates that at least one of `read` or `write` is specified
- Handles `AttributeError` and `OSError` when testing poll availability
- Robust fallback mechanism for broken implementations

### Performance Considerations

- Optimized for single-socket operations rather than multi-socket scenarios
- Avoids stateful APIs (epoll/kqueue) since they're overkill for single-socket use cases
- Lazy initialization prevents unnecessary overhead

## Usage Recommendations

1. **Prefer the public API**: Use `wait_for_read()` and `wait_for_write()` rather than internal functions
2. **Timeout handling**: Always specify appropriate timeouts to avoid indefinite blocking
3. **Error handling**: Check return values to distinguish between successful operations and timeouts
4. **Non-blocking operations**: This module is particularly useful when implementing non-blocking socket operations

## Dependencies

- Python 3.7+ (uses `from __future__ import annotations`)
- Standard library modules: `select`, `socket`, `functools`