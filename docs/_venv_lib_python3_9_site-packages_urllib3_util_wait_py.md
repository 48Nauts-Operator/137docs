<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Socket Wait Utilities

## Overview

This module provides utilities for waiting on socket I/O operations in a cross-platform manner. It intelligently selects the most appropriate system call (`poll()` or `select()`) based on the platform and availability, optimizing for single-socket operations.

## Purpose

The module addresses the need to efficiently wait for socket readiness (read/write operations) without maintaining persistent state. It provides a unified interface that automatically chooses between:

- **`poll()`** - Preferred on Unix-like systems for better performance with high-numbered file descriptors
- **`select()`** - Used on Windows (where `poll()` is unavailable) and as a fallback option

## Public API

The module exports two main functions:

```python
__all__ = ["wait_for_read", "wait_for_write"]
```

### `wait_for_read(sock, timeout=None)`

Waits for a socket to become available for reading.

**Parameters:**
- `sock` (socket.socket): The socket to monitor
- `timeout` (float | None): Maximum time to wait in seconds, or None for blocking

**Returns:**
- `bool`: True if socket is readable, False if timeout expired

**Example:**
```python
import socket
from module import wait_for_read

sock = socket.socket()
if wait_for_read(sock, timeout=5.0):
    data = sock.recv(1024)
```

### `wait_for_write(sock, timeout=None)`

Waits for a socket to become available for writing.

**Parameters:**
- `sock` (socket.socket): The socket to monitor  
- `timeout` (float | None): Maximum time to wait in seconds, or None for blocking

**Returns:**
- `bool`: True if socket is writable, False if timeout expired

**Example:**
```python
import socket
from module import wait_for_write

sock = socket.socket()
if wait_for_write(sock, timeout=5.0):
    sock.send(b"Hello, World!")
```

## Internal Implementation

### Core Functions

#### `wait_for_socket(sock, read=False, write=False, timeout=None)`

The main dispatcher function that automatically selects the optimal implementation on first use. It employs a self-replacing pattern to avoid repeated platform detection.

#### `poll_wait_for_socket(sock, read=False, write=False, timeout=None)`

Implementation using `select.poll()` for Unix-like systems:
- Uses bitmask flags (`POLLIN`, `POLLOUT`)
- Converts timeout from seconds to milliseconds
- More efficient for high-numbered file descriptors

#### `select_wait_for_socket(sock, read=False, write=False, timeout=None)`

Implementation using `select.select()` for Windows and fallback:
- Handles Windows-specific behavior for non-blocking connects
- Monitors exceptional conditions alongside write conditions
- Compatible with all platforms that support `select()`

#### `_have_working_poll()`

Platform detection utility that:
- Tests if `select.poll()` is available and functional
- Handles broken implementations from libraries like eventlet/greenlet
- Returns False for systems where poll() fails immediately

## Technical Notes

### Platform-Specific Behavior

- **Windows**: Uses `select()` exclusively since `poll()` is not available
- **Unix/Linux**: Prefers `poll()` but falls back to `select()` if needed
- **Non-blocking connects**: Handles Windows vs. Unix differences in signaling connection completion

### Performance Considerations

- Optimized for single-socket operations rather than monitoring multiple sockets
- Avoids stateful APIs (epoll/kqueue) that require setup overhead
- Lazy initialization prevents wrong decisions from post-import monkeypatching

### Error Handling

- Validates that at least one of `read` or `write` is specified
- Gracefully handles missing or broken `poll()` implementations
- Robust against library monkeypatching of system calls

## Suggestions for Use

1. **Timeout Management**: Always specify reasonable timeouts to avoid indefinite blocking
2. **Error Handling**: Check return values and handle False results appropriately
3. **Socket State**: Ensure sockets are in non-blocking mode when using these utilities
4. **Connection Handling**: Be aware of platform differences in non-blocking connect behavior

## Dependencies

- Python 3.7+ (uses `from __future__ import annotations`)
- Standard library modules: `select`, `socket`, `functools`