<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Watchdog Observer Module Documentation

## Overview

This module provides the core infrastructure for file system monitoring in the Watchdog library. It implements a producer-consumer pattern where **emitters** watch file system paths and generate events, while **observers** dispatch these events to registered event handlers.

## Purpose

The module serves as the foundation for cross-platform file system monitoring by:
- Managing watched paths and their associated event handlers
- Queuing file system events to avoid duplicate processing
- Dispatching events to appropriate handlers in a thread-safe manner
- Providing base classes for platform-specific implementations

## Key Classes

### EventQueue

```python
class EventQueue(SkipRepeatsQueue):
```

A thread-safe event queue that automatically skips consecutive duplicate events.

**Features:**
- Prevents multiple identical events from being queued consecutively
- Reduces unnecessary event handler calls when events are generated faster than they can be consumed
- Thread-safe for concurrent producer-consumer scenarios

### ObservedWatch

```python
class ObservedWatch:
    def __init__(self, path, *, recursive: bool, event_filter=None):
```

Represents a scheduled watch configuration for a specific path.

**Properties:**
- `path`: The file system path being monitored
- `is_recursive`: Whether subdirectories are included in monitoring  
- `event_filter`: Optional collection of specific event types to watch
- `key`: Unique identifier tuple for comparison and hashing

**Key Methods:**
- `__eq__`, `__ne__`, `__hash__`: Enable use as dictionary keys and in sets
- `__repr__`: Provides detailed string representation for debugging

### EventEmitter

```python
class EventEmitter(BaseThread):
    def __init__(self, event_queue, watch, *, timeout=DEFAULT_EMITTER_TIMEOUT, event_filter=None):
```

Base class for producer threads that generate file system events.

**Key Methods:**
- `queue_event(event)`: Adds a single event to the queue (with filtering)
- `queue_events(timeout)`: **Override this method** in subclasses to implement platform-specific event detection
- `run()`: Main thread loop that continuously calls `queue_events()`

**Usage Pattern:**
```python
class CustomEmitter(EventEmitter):
    def queue_events(self, timeout):
        # Platform-specific implementation
        # Detect file system changes and call self.queue_event(event)
        pass
```

### EventDispatcher

```python
class EventDispatcher(BaseThread):
    def __init__(self, *, timeout=DEFAULT_OBSERVER_TIMEOUT):
```

Base consumer thread that dispatches events from the queue to handlers.

**Key Methods:**
- `dispatch_events(event_queue)`: **Override this method** to implement custom event dispatching
- `stop()`: Gracefully stops the dispatcher by inserting a stop signal
- `run()`: Main thread loop for continuous event processing

### BaseObserver

```python
class BaseObserver(EventDispatcher):
    def __init__(self, emitter_class, *, timeout=DEFAULT_OBSERVER_TIMEOUT):
```

The main observer class that coordinates watching, event generation, and dispatching.

**Key Methods:**

#### Scheduling Watches
```python
def schedule(self, event_handler, path, *, recursive=False, event_filter=None) -> ObservedWatch:
```
- Registers a path for monitoring with an event handler
- Creates and starts emitters as needed
- Returns an `ObservedWatch` object for later reference

#### Managing Handlers
```python
def add_handler_for_watch(self, event_handler, watch):
def remove_handler_for_watch(self, event_handler, watch):
```

#### Unscheduling
```python
def unschedule(self, watch):        # Remove specific watch
def unschedule_all(self):           # Remove all watches
```

## Usage Example

```python
from watchdog.events import FileSystemEventHandler
from watchdog.observers import Observer  # Platform-specific observer

class MyHandler(FileSystemEventHandler):
    def on_modified(self, event):
        print(f"File {event.src_path} was modified")

# Create observer and handler
observer = Observer()
handler = MyHandler()

# Schedule monitoring
watch = observer.schedule(handler, "/path/to/watch", recursive=True)

# Start monitoring
observer.start()

# Later: stop monitoring
observer.unschedule(watch)
observer.stop()
observer.join()
```

## Configuration Constants

```python
DEFAULT_EMITTER_TIMEOUT = 1.0   # Seconds between emitter polling attempts
DEFAULT_OBSERVER_TIMEOUT = 1.0  # Seconds for event queue blocking timeout
```

## Thread Safety Notes

- **Thread-safe operations**: All public methods use internal locking (`threading.RLock`)
- **Handler modification**: Event handlers can safely modify the observer (add/remove handlers) during event processing
- **Graceful shutdown**: The `stop()` method uses a special stop event to ensure clean thread termination

## Implementation Notes

### For Library Developers

When creating platform-specific observers:

1. **Inherit from `BaseObserver`**: Pass your custom `EventEmitter` subclass
2. **Implement `EventEmitter.queue_events()`**: Add platform-specific file system monitoring logic  
3. **Handle timeouts appropriately**: Use the timeout parameter for non-blocking operations

### Event Filtering

Event filtering can be applied at two levels:
- **Observer level**: Filter events before they reach handlers
- **Emitter level**: Filter events at the source for better performance

### Memory Management

- Emitters are automatically started when the observer is running
- Stopped emitters are joined with error suppression to prevent race conditions
- All resources are cleaned up in `unschedule_all()` and `on_thread_stop()`

## Dependencies

- `watchdog.utils.BaseThread`: Base threading functionality
- `watchdog.utils.bricks.SkipRepeatsQueue`: Duplicate event filtering
- `watchdog.events`: File system event types (TYPE_CHECKING only)