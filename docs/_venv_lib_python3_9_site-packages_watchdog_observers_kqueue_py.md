<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# Kqueue File System Observer Documentation

## Overview

This module provides a `kqueue(2)`-based file system event monitoring implementation for the Watchdog library. It's designed to work on macOS and BSD systems that support the kqueue system call.

## Purpose

The kqueue observer monitors file system changes by:
- Opening file descriptors for all monitored files and directories
- Using kqueue to detect low-level file system events
- Taking directory snapshots to determine the nature of changes
- Generating appropriate file system events for the application

## ⚠️ Important Warnings

### Performance Considerations
- **Heavy Resource Usage**: kqueue monitoring requires opening file descriptors for every monitored file/directory
- **Directory Scanning**: Each directory modification triggers a full directory scan
- **File Descriptor Limits**: You may need to increase your system's file descriptor limit:
  ```bash
  ulimit -n 1024
  ```

### Platform-Specific Notes
- Uses `O_EVTONLY` flag on macOS to prevent blocking volume unmounting
- On other BSD systems, uses `O_RDONLY | O_NONBLOCK`

## Key Classes

### `KqueueEmitter`

The main event emitter class that handles kqueue-based file system monitoring.

```python
class KqueueEmitter(EventEmitter):
    def __init__(
        self,
        event_queue: EventQueue,
        watch: ObservedWatch,
        *,
        timeout: float = DEFAULT_EMITTER_TIMEOUT,
        event_filter: list[type[FileSystemEvent]] | None = None,
        stat: Callable[[str], os.stat_result] = os.stat,
    )
```

**Key Features:**
- Maintains directory snapshots to detect creation/rename events
- Handles file descriptor management automatically
- Generates appropriate events based on kqueue notifications

**Important Methods:**
- `queue_events(timeout)`: Main event processing loop
- `_register_kevent(path, is_directory)`: Registers a path for monitoring
- `_unregister_kevent(path)`: Stops monitoring a path

### `KeventDescriptorSet`

Thread-safe collection for managing kqueue descriptors.

```python
class KeventDescriptorSet:
    def add(self, path: bytes | str, *, is_directory: bool) -> None
    def remove(self, path: bytes | str) -> None
    def get(self, path: bytes | str) -> KeventDescriptor
    def clear(self) -> None
```

**Features:**
- Thread-safe operations with internal locking
- Maintains mappings between paths, file descriptors, and kevents
- Automatic cleanup of file descriptors

### `KeventDescriptor`

Data structure that encapsulates a single kqueue monitoring descriptor.

```python
class KeventDescriptor:
    def __init__(self, path: bytes | str, *, is_directory: bool) -> None
    
    @property
    def fd(self) -> int  # File descriptor
    @property  
    def path(self) -> bytes | str  # Monitored path
    @property
    def kevent(self) -> select.kevent  # Kqueue event object
    @property
    def is_directory(self) -> bool  # Directory flag
```

### `KqueueObserver`

High-level observer class for scheduling and managing kqueue-based monitoring.

```python
class KqueueObserver(BaseObserver):
    def __init__(self, *, timeout: float = DEFAULT_OBSERVER_TIMEOUT) -> None
```

## Utility Functions

### Event Detection Functions

```python
def is_deleted(kev: select.kevent) -> bool
def is_modified(kev: select.kevent) -> bool  
def is_attrib_modified(kev: select.kevent) -> bool
def is_renamed(kev: select.kevent) -> bool
```

These functions analyze kqueue event flags to determine the type of file system change.

## Usage Example

```python
from watchdog.observers.kqueue import KqueueObserver
from watchdog.events import FileSystemEventHandler

class MyHandler(FileSystemEventHandler):
    def on_modified(self, event):
        print(f"Modified: {event.src_path}")

observer = KqueueObserver()
observer.schedule(MyHandler(), path="/path/to/watch", recursive=True)
observer.start()

try:
    while True:
        time.sleep(1)
except KeyboardInterrupt:
    observer.stop()
observer.join()
```

## Configuration Constants

```python
MAX_EVENTS = 4096  # Maximum events processed per cycle
O_EVTONLY = 0x8000  # macOS-specific flag for event-only monitoring

# Kqueue configuration flags
WATCHDOG_KQ_FILTER = select.KQ_FILTER_VNODE
WATCHDOG_KQ_EV_FLAGS = select.KQ_EV_ADD | select.KQ_EV_ENABLE | select.KQ_EV_CLEAR
WATCHDOG_KQ_FFLAGS = (
    select.KQ_NOTE_DELETE | select.KQ_NOTE_WRITE | select.KQ_NOTE_EXTEND |
    select.KQ_NOTE_ATTRIB | select.KQ_NOTE_LINK | select.KQ_NOTE_RENAME |
    select.KQ_NOTE_REVOKE
)
```

## Limitations

1. **Limited Event Information**: kqueue doesn't provide:
   - Destination paths for renamed files
   - Direct creation events (detected via directory snapshots)

2. **Resource Intensive**: Requires file descriptors for all monitored items

3. **Platform Specific**: Only works on macOS and BSD systems with kqueue support

## Best Practices

- Monitor only necessary directories to reduce resource usage
- Increase file descriptor limits for large directory trees
- Consider using less resource-intensive observers on other platforms
- Handle `OSError` exceptions for files that may be temporarily unavailable