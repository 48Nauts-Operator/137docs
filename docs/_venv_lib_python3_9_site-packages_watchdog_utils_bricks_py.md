<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# watchdog.utils.bricks

## Overview

This module provides utility collection classes (referred to as "bricks") for the Watchdog file monitoring library. The primary purpose is to offer specialized data structures that support thread-safe operations with unique behaviors for managing queued items.

## Purpose

The module contains specialized queue implementations that extend Python's standard `queue.Queue` to provide custom behavior for handling duplicate or repeated items. This is particularly useful in file monitoring scenarios where you may want to avoid processing duplicate events.

## Classes

### SkipRepeatsQueue

A thread-safe queue implementation that automatically drops items that are identical to the last item that was added to the queue.

#### Key Features

- **Thread-safe**: Inherits thread safety from `queue.Queue`
- **Duplicate prevention**: Skips adding items that are identical to the previously added item
- **Hashable items required**: Items must be immutable and implement proper hash/equality methods

#### Important Methods

- **`put(item, block=True, timeout=None)`**: Adds an item to the queue only if it's different from the last added item
- **`_put(item)`**: Internal method that handles the actual item placement and tracks the last item
- **`_get()`**: Internal method that retrieves items and manages the last item tracking

#### Requirements for Queued Items

Items added to `SkipRepeatsQueue` must be:

- **Immutable**: Cannot be changed after creation
- **Hashable**: Must implement `__hash__()`, `__eq__()`, and `__ne__()` methods
- **Read-only properties only**: Should only expose read-only attributes

#### Example Item Implementation

```python
class Item:
    def __init__(self, a, b):
        self._a = a
        self._b = b

    @property
    def a(self):
        return self._a

    @property
    def b(self):
        return self._b

    def _key(self):
        return (self._a, self._b)

    def __eq__(self, item):
        return self._key() == item._key()

    def __ne__(self, item):
        return self._key() != item._key()

    def __hash__(self):
        return hash(self._key())
```

## Implementation Notes

### Thread Safety
- The implementation leverages the existing locking mechanisms from `queue.Queue`
- Only the primitive methods (`_init`, `_put`, `_get`) are redefined to maintain thread safety

### Eventlet Compatibility
- The `put()` method signature is preserved for compatibility with `eventlet`
- When using `eventlet`, the `timeout` argument may be ignored
- Method signatures cannot be modified due to this compatibility requirement

## Usage Recommendations

### When to Use SkipRepeatsQueue

- **File monitoring**: When processing file system events where consecutive duplicate events should be ignored
- **Event deduplication**: Any scenario where you want to avoid processing identical consecutive items
- **Performance optimization**: Reducing processing overhead by eliminating redundant operations

### Best Practices

- Ensure all queued items properly implement the required hash and equality methods
- Keep item implementations simple and focused on immutability
- Test hash and equality implementations thoroughly to avoid unexpected behavior

## Notes and Considerations

- Items must be carefully designed to be truly immutable to prevent unexpected behavior
- The queue only prevents consecutive duplicates, not all duplicates throughout the queue's lifetime
- Performance depends on the efficiency of the item's hash and equality implementations