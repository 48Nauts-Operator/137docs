<!-- Auto-generated by Claude on 2025-06-02 06:15 -->

# echo.py - Function Call Tracing Module

## Overview

The `echo.py` module provides a Python decorator for tracing function calls by printing out function names and their arguments before execution. This is useful for debugging and understanding program flow.

**Author:** Thomas Guest <tag@wordaligned.org>  
**License:** Public Domain  
**Source:** http://wordaligned.org/articles/echo

## Purpose

This module allows developers to:
- **Trace function calls** by decorating functions with `@echo.echo`
- **Debug program execution** by seeing what arguments are passed to functions
- **Monitor function usage** during development and testing

## Main Components

### `echo(fn, write=sys.stdout.write)` - Main Decorator Function

The primary decorator that wraps functions to trace their calls.

**Parameters:**
- `fn` (Callable): The function to be decorated
- `write` (Callable): Output function (defaults to `sys.stdout.write`)

**Returns:** A decorated version of the input function

**Key Features:**
- Preserves original function metadata using `functools.wraps`
- Handles all argument types: positional, keyword, defaults, and varargs
- Customizable output destination

### `format_arg_value(arg_val)` - Argument Formatting Helper

Formats function arguments for display.

**Parameters:**
- `arg_val` (tuple): A tuple containing argument name and value

**Returns:** Formatted string representation of the argument

## Usage Examples

### Basic Function Decoration

```python
import echo

@echo.echo
def greet(name, greeting="Hello"):
    return f"{greeting}, {name}!"

# When called:
greet("Alice")
# Output: greet(name='Alice', greeting='Hello')

greet("Bob", "Hi")
# Output: greet(name='Bob', greeting='Hi')
```

### Custom Output Destination

```python
import echo

def custom_writer(text):
    # Write to a file or custom logger
    with open('trace.log', 'a') as f:
        f.write(text)

@echo.echo
def my_function(x, y=10):
    return x + y

# Or apply manually with custom writer:
traced_func = echo.echo(my_function, write=custom_writer)
```

## Technical Implementation Details

### Argument Processing

The decorator intelligently handles different argument types:

1. **Positional arguments**: Direct parameter mapping
2. **Default arguments**: Uses function's `__defaults__` attribute
3. **Keyword arguments**: Processes `**kwargs`
4. **Variable arguments**: Handles `*args` beyond defined parameters

### Code Introspection

The module uses Python's introspection capabilities:
- `fn.__code__.co_argcount`: Number of function arguments
- `fn.__code__.co_varnames`: Parameter names
- `fn.__defaults__`: Default parameter values

## Notes and Considerations

### Performance Impact
- **Development Use**: Intended primarily for debugging and development
- **Production Warning**: May impact performance due to string formatting and I/O operations

### Limitations
- **Complex Objects**: Large or complex arguments may produce verbose output
- **Sensitive Data**: Be cautious when tracing functions that handle sensitive information

### Best Practices
- Remove or disable tracing decorators in production code
- Consider using conditional tracing based on debug flags
- Use custom writers for logging to files or external systems

## Type Hints

The module includes modern Python type hints:
- Uses `from __future__ import annotations` for forward compatibility
- Conditional imports with `TYPE_CHECKING` for runtime performance
- Proper typing for all function parameters and return values

## Compatibility

- **Python Version**: Compatible with Python 3.7+
- **Dependencies**: Uses only standard library modules (`functools`, `sys`, `typing`)