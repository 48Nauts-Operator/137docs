<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# echo.py - Function Call Tracing with Python Decorators

## Overview

The `echo.py` module provides a simple and effective way to trace function calls in Python using decorators. It allows developers to monitor function invocations by printing the function name and argument values before execution.

**Author:** Thomas Guest  
**License:** Public Domain  
**Reference:** http://wordaligned.org/articles/echo

## Purpose

This module is designed for debugging and monitoring purposes, allowing developers to:
- Trace function calls during development
- Monitor argument values passed to functions
- Debug complex function call chains
- Add temporary logging without modifying function logic

## Key Functions

### `echo(fn, write=sys.stdout.write)`

The main decorator function that wraps target functions to provide call tracing.

**Parameters:**
- `fn` (Callable): The function to be decorated
- `write` (Callable): Output function for trace messages (defaults to `sys.stdout.write`)

**Returns:** A decorated version of the input function

**Functionality:**
- Preserves original function metadata using `functools.wraps`
- Captures and formats all types of arguments (positional, keyword, defaults)
- Outputs formatted call information before executing the original function

### `format_arg_value(arg_val)`

A utility function that formats argument name-value pairs for display.

**Parameters:**
- `arg_val` (tuple): A tuple containing argument name and value

**Returns:** Formatted string representation of the argument

## Usage Examples

### Basic Decorator Usage

```python
import echo

@echo.echo
def calculate_sum(a, b, multiplier=1):
    return (a + b) * multiplier

# Function calls will be traced
result = calculate_sum(5, 3)
# Output: calculate_sum(a=5, b=3, multiplier=1)

result = calculate_sum(10, 20, multiplier=2)
# Output: calculate_sum(a=10, b=20, multiplier=2)
```

### Custom Output Target

```python
import echo

# Redirect output to a file
with open('trace.log', 'w') as f:
    @echo.echo(write=f.write)
    def my_function(x, y):
        return x * y
    
    my_function(3, 4)
```

## Implementation Details

### Argument Handling

The decorator intelligently handles different types of function arguments:

- **Positional arguments**: Mapped to parameter names
- **Default arguments**: Included when not overridden
- **Extra positional arguments**: Displayed without names
- **Keyword arguments**: Shown with their keys

### Code Inspection

The module uses Python's introspection capabilities:
- `fn.__code__` - Accesses function bytecode information
- `co_argcount` - Gets the number of positional arguments
- `co_varnames` - Retrieves parameter names
- `__defaults__` - Accesses default parameter values

## Notes and Considerations

### Advantages
- **Non-intrusive**: No modification of original function logic
- **Flexible output**: Customizable output destination
- **Complete argument capture**: Handles all argument types
- **Metadata preservation**: Maintains original function attributes

### Limitations
- **Performance overhead**: Adds processing time to each function call
- **Output verbosity**: May generate significant output for frequently called functions
- **No return value tracing**: Only traces input arguments, not return values

### Best Practices

1. **Development use**: Primarily intended for development and debugging
2. **Selective application**: Apply to specific functions rather than entire modules
3. **Temporary decoration**: Remove decorators in production code
4. **Custom output**: Consider redirecting output to files for complex applications

## Suggestions for Enhancement

- Add return value tracing
- Include execution time measurement
- Implement filtering options for argument types
- Add support for class method tracing
- Include call stack depth visualization