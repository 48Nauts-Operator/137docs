<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# EventDebouncer Documentation

## Overview

The `EventDebouncer` class is a background thread utility designed to handle file system events with debouncing functionality. It prevents rapid-fire event handling by waiting for a specified interval after the last event before processing all accumulated events as a batch.

## Purpose

This module is particularly useful for file system monitoring scenarios where:
- Multiple file system events occur in rapid succession
- You want to avoid processing each event individually
- Batch processing of events is more efficient than individual processing
- You need to reduce system load from frequent file system changes

## Class: EventDebouncer

### Inheritance
- Extends `BaseThread` from `watchdog.utils`
- Runs as a background daemon thread

### Constructor

```python
def __init__(
    self,
    debounce_interval_seconds: int,
    events_callback: Callable[[list[FileSystemEvent]], None],
) -> None
```

**Parameters:**
- `debounce_interval_seconds`: Time to wait (in seconds) after the last event before processing
- `events_callback`: Function that will be called with the list of accumulated events

### Key Methods

#### `handle_event(event: FileSystemEvent) -> None`
- **Purpose**: Receives and queues incoming file system events
- **Behavior**: 
  - Adds the event to the internal event list
  - Notifies the background thread that a new event has arrived
  - Thread-safe using condition variable synchronization

#### `stop() -> None`
- **Purpose**: Gracefully shuts down the debouncer thread
- **Behavior**: 
  - Calls parent class stop method
  - Notifies the background thread to wake up and check shutdown status

#### `run() -> None`
- **Purpose**: Main thread execution loop (called automatically when thread starts)
- **Behavior**:
  - Waits for events to arrive
  - Implements debouncing logic with configurable timeout
  - Processes accumulated events in batches
  - Continues until thread shutdown is requested

## How Debouncing Works

1. **Event Reception**: Events are received via `handle_event()` and added to a queue
2. **Timer Reset**: Each new event resets the debounce timer
3. **Batch Processing**: When the debounce interval passes without new events, all queued events are processed together
4. **Order Preservation**: Events are processed in the order they were received

## Usage Example

```python
from watchdog.events import FileSystemEvent

def process_events(events: list[FileSystemEvent]) -> None:
    print(f"Processing {len(events)} events:")
    for event in events:
        print(f"  - {event}")

# Create debouncer with 2-second interval
debouncer = EventDebouncer(
    debounce_interval_seconds=2,
    events_callback=process_events
)

# Start the background thread
debouncer.start()

# Handle events (typically called by file system watcher)
debouncer.handle_event(some_file_event)

# Stop when done
debouncer.stop()
debouncer.join()
```

## Thread Safety

- Uses `threading.Condition` for synchronization
- All shared state access is protected by condition variable locks
- Safe for concurrent access from multiple threads

## Notes and Considerations

- **Zero Debounce Interval**: If `debounce_interval_seconds` is 0, events are processed immediately without delay
- **Memory Usage**: Events accumulate in memory until processed; consider this for high-frequency scenarios
- **Graceful Shutdown**: Always call `stop()` and `join()` to ensure clean thread termination
- **Error Handling**: The callback function should handle its own exceptions to prevent thread termination

## Dependencies

- `watchdog.utils.BaseThread`: Base threading functionality
- `watchdog.events.FileSystemEvent`: Event type definitions
- Standard library: `logging`, `threading`, `typing`