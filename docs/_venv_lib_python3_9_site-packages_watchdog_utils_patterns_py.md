<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# watchdog.utils.patterns

## Overview

This module provides common wildcard searching and filtering functionality for file paths. It's part of the Watchdog library and enables pattern-based filtering of file paths with support for both case-sensitive and case-insensitive matching across different operating systems.

## Purpose

The module addresses the challenge of cross-platform path matching by leveraging Python's `pathlib` pure path objects:
- Uses `PurePosixPath` for case-sensitive matching (Unix-like systems)
- Uses `PureWindowsPath` for case-insensitive matching (Windows-like behavior)

This approach ensures consistent behavior regardless of the host operating system.

## Key Features

- **Cross-platform compatibility**: Works consistently across different operating systems
- **Wildcard pattern matching**: Supports standard glob-style patterns
- **Case sensitivity control**: Configurable case-sensitive or case-insensitive matching
- **Include/exclude patterns**: Filter paths using both inclusion and exclusion rules
- **Conflict detection**: Validates that patterns don't conflict between inclusion and exclusion sets

## Functions

### `filter_paths()`

Filters a list of paths based on inclusion and exclusion patterns.

```python
def filter_paths(
    paths: list[str],
    *,
    included_patterns: list[str] | None = None,
    excluded_patterns: list[str] | None = None,
    case_sensitive: bool = True,
) -> Iterator[str]:
```

**Parameters:**
- `paths`: List of path names to filter
- `included_patterns`: Wildcard patterns for files to include (default: `["*"]` - matches all)
- `excluded_patterns`: Wildcard patterns for files to exclude (default: `[]` - excludes none)
- `case_sensitive`: Whether matching should be case-sensitive (default: `True`)

**Returns:** Iterator yielding paths that match inclusion patterns and don't match exclusion patterns

**Example Usage:**
```python
paths = ["file1.txt", "file2.py", "test.log", "README.md"]
filtered = list(filter_paths(
    paths,
    included_patterns=["*.txt", "*.py"],
    excluded_patterns=["test.*"],
    case_sensitive=True
))
# Result: ["file1.txt", "file2.py"]
```

### `match_any_paths()`

Checks if any paths in a list match the given patterns.

```python
def match_any_paths(
    paths: list[str],
    *,
    included_patterns: list[str] | None = None,
    excluded_patterns: list[str] | None = None,
    case_sensitive: bool = True,
) -> bool:
```

**Parameters:** Same as `filter_paths()`

**Returns:** `True` if at least one path matches the criteria, `False` otherwise

### `_match_path()` (Internal)

Internal helper function that performs the actual pattern matching logic for a single path.

```python
def _match_path(
    raw_path: str,
    included_patterns: set[str],
    excluded_patterns: set[str],
    *,
    case_sensitive: bool,
) -> bool:
```

## Implementation Notes

### Pattern Matching Strategy

- **Case-sensitive**: Converts path to `PurePosixPath` and matches patterns as-is
- **Case-insensitive**: Converts path to `PureWindowsPath` and normalizes all patterns to lowercase

### Error Handling

The module includes validation to prevent conflicting patterns:
```python
# This will raise a ValueError
filter_paths(
    ["file.txt"],
    included_patterns=["*.txt"],
    excluded_patterns=["*.txt"]  # Conflict!
)
```

## Dependencies

- `pathlib`: For pure path object manipulation
- `typing`: For type hints and compatibility

## Usage Recommendations

1. **Default Behavior**: When no patterns are specified, `included_patterns` defaults to `["*"]` (match all files)

2. **Pattern Syntax**: Use standard glob patterns:
   - `*` matches any number of characters
   - `?` matches a single character
   - `[seq]` matches any character in sequence
   - `**` matches directories recursively

3. **Performance**: For large path lists, consider the iterator nature of `filter_paths()` - it yields results lazily

4. **Cross-platform Considerations**: Set `case_sensitive=False` when working with Windows-style paths or when case-insensitive matching is desired

## Example

```python
from watchdog.utils.patterns import filter_paths, match_any_paths

# Filter Python files, excluding test files
python_files = [
    "main.py", "utils.py", "test_main.py", 
    "config.json", "Test_Utils.py"
]

filtered = list(filter_paths(
    python_files,
    included_patterns=["*.py"],
    excluded_patterns=["test_*", "Test_*"],
    case_sensitive=True
))
# Result: ["main.py", "utils.py"]

# Check if any Python files exist
has_python = match_any_paths(
    python_files,
    included_patterns=["*.py"]
)
# Result: True
```