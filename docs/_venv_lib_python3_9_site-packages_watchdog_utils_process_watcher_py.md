<!-- Auto-generated by Claude on 2025-06-08 06:13 -->

# ProcessWatcher Module

## Overview

This module provides a `ProcessWatcher` class that monitors a subprocess and executes a callback function when the process terminates. It's designed to run in a separate thread and continuously poll a subprocess to detect when it has finished executing.

## Purpose

The `ProcessWatcher` is useful for applications that need to:
- Monitor long-running subprocesses
- Execute cleanup or notification logic when a subprocess terminates
- Handle process termination in a non-blocking manner

## Dependencies

- `watchdog.utils.BaseThread` - Base threading class
- `subprocess` - For process management (type checking only)
- `logging` - For error logging

## Classes

### ProcessWatcher

A thread-based class that monitors subprocess termination and executes callbacks.

#### Constructor

```python
def __init__(self, popen_obj: subprocess.Popen, process_termination_callback: Callable[[], None] | None) -> None
```

**Parameters:**
- `popen_obj`: A `subprocess.Popen` object representing the process to monitor
- `process_termination_callback`: Optional callback function to execute when the process terminates

#### Methods

##### run()

```python
def run(self) -> None
```

The main execution method that:
- Continuously polls the subprocess using `poll()` method
- Checks every 0.1 seconds if the process is still running
- Respects thread stopping events for graceful shutdown
- Executes the termination callback when the process ends
- Handles exceptions in callback execution with proper logging

## Implementation Details

### Polling Mechanism

The watcher uses a polling approach with the following characteristics:
- **Poll Interval**: 0.1 seconds (100ms)
- **Non-blocking**: Uses `stopped_event.wait(timeout=0.1)` for interruptible waiting
- **Process Detection**: Uses `popen_obj.poll()` which returns `None` for running processes

### Error Handling

- Callback exceptions are caught and logged using the module logger
- The watcher continues to function even if the callback fails
- Uses `logger.exception()` to capture full stack traces

## Usage Example

```python
import subprocess
from process_watcher import ProcessWatcher

def on_process_end():
    print("Process has terminated!")

# Start a subprocess
process = subprocess.Popen(['long_running_command'])

# Create and start the watcher
watcher = ProcessWatcher(process, on_process_end)
watcher.start()

# Later, stop the watcher if needed
watcher.stop()
```

## Notes and Suggestions

### Performance Considerations
- The 0.1-second polling interval provides a good balance between responsiveness and CPU usage
- For applications requiring immediate notification, consider reducing the timeout value
- For less time-sensitive applications, increasing the timeout can reduce CPU overhead

### Thread Safety
- Inherits thread safety from `BaseThread`
- The callback should be thread-safe if it interacts with shared resources
- Consider using thread-safe logging or synchronization in callbacks

### Potential Improvements
- **Configurable Poll Interval**: Make the 0.1-second timeout configurable
- **Return Code Handling**: Consider passing the process return code to the callback
- **Multiple Callbacks**: Support for multiple termination callbacks
- **Process Information**: Provide process runtime or exit status to callbacks

### Best Practices
- Always provide error handling in your termination callbacks
- Remember to call `stop()` on the watcher when shutting down your application
- Consider the lifetime of the `ProcessWatcher` in relation to your main application