<!--
This documentation was auto-generated by Claude on 2025-05-31T16-04-41.
Source file: ./src/backend/app/notifications.py
-->

# Notification Framework Documentation

## Overview

The `app.notifications` module provides a modular, asynchronous notification framework designed for the 137docs application. This framework supports multiple notification channels (in-app, email, Slack, SMS, etc.) with a pluggable architecture that allows for runtime registration of new channels.

## Key Features

- **Asynchronous**: Built with SQLAlchemy async for non-blocking database operations
- **Modular Architecture**: Channel-based system allows easy extension
- **Persistent Storage**: All notifications are recorded in the database
- **Multi-Channel Support**: Dispatch notifications to multiple channels simultaneously
- **Graceful Failure Handling**: Channel failures are logged but don't stop other channels
- **Business Logic Integration**: Built-in support for document due date monitoring

## Architecture

### Core Components

1. **NotificationChannel**: Abstract base class for all notification channels
2. **NotificationService**: Main orchestrator for notification persistence and dispatch
3. **InAppChannel**: Default channel that stores notifications in the database
4. **Helper Functions**: Utilities for serialization and data transformation

## API Reference

### NotificationChannel (Abstract Base Class)

```python
class NotificationChannel(ABC):
```

Abstract base class that all notification channels must implement.

#### Methods

##### `send(notification: Notification, db: AsyncSession) -> None`

**Abstract method** that delivers a notification via the specific channel.

**Parameters:**
- `notification` (Notification): The notification object to send
- `db` (AsyncSession): Database session for additional queries if needed

**Returns:** None

### InAppChannel

```python
class InAppChannel(NotificationChannel):
```

Default notification channel that only persists notifications to the database without external delivery.

#### Methods

##### `send(notification: Notification, db: AsyncSession) -> None`

Implements the abstract send method. Since notifications are already persisted by the service, this method performs no additional operations.

### NotificationService

```python
class NotificationService:
```

Main service class that orchestrates notification creation, persistence, and dispatch to registered channels.

#### Constructor

```python
def __init__(self, channels: Optional[Sequence[NotificationChannel]] = None)
```

**Parameters:**
- `channels` (Optional[Sequence[NotificationChannel]]): List of notification channels to register

**Note:** An `InAppChannel` is always added as the first channel to ensure database persistence.

#### CRUD Methods

##### `create_notification(db, title, message, notification_type, document_id=None) -> dict`

Creates and persists a new notification, then dispatches it to all registered channels.

**Parameters:**
- `db` (AsyncSession): Database session
- `title` (str): Notification title
- `message` (str): Notification message content
- `notification_type` (str): Type/category of notification
- `document_id` (Optional[int]): Associated document ID if applicable

**Returns:** Dictionary representation of the created notification

**Example:**
```python
service = NotificationService()
notification = await service.create_notification(
    db=db_session,
    title="Document Overdue",
    message="Invoice #123 is 5 days overdue",
    notification_type="overdue",
    document_id=123
)
```

##### `get_all_notifications(db, limit=100, offset=0, include_read=False) -> List[dict]`

Retrieves notifications with pagination and filtering options.

**Parameters:**
- `db` (AsyncSession): Database session
- `limit` (int, default=100): Maximum number of notifications to return
- `offset` (int, default=0): Number of notifications to skip
- `include_read` (bool, default=False): Whether to include already-read notifications

**Returns:** List of notification dictionaries

##### `mark_as_read(db, notification_id) -> Optional[dict]`

Marks a specific notification as read.

**Parameters:**
- `db` (AsyncSession): Database session
- `notification_id` (int): ID of the notification to mark as read

**Returns:** Updated notification dictionary or None if not found

##### `mark_all_as_read(db) -> int`

Marks all unread notifications as read.

**Parameters:**
- `db` (AsyncSession): Database session

**Returns:** Number of notifications marked as read

#### Business Logic Methods

##### `check_overdue_documents(db) -> List[Notification]`

Scans for overdue documents and creates notifications for them.

**Parameters:**
- `db` (AsyncSession): Database session

**Returns:** List of created notification objects

**Behavior:**
- Only creates notifications for documents with status != "paid"
- Skips documents that already have unread overdue notifications
- Calculates days overdue and includes in notification message

##### `check_upcoming_due_dates(db, days_ahead=7) -> List[Notification]`

Creates reminder notifications for documents due within a specified timeframe.

**Parameters:**
- `db` (AsyncSession): Database session
- `days_ahead` (int, default=7): Number of days ahead to check for due dates

**Returns:** List of created notification objects

**Behavior:**
- Only creates notifications for unpaid documents
- Skips documents that already have unread reminder notifications
- Includes countdown days in notification message

##### `create_due_date_notification(db, document) -> Optional[dict]`

Creates a due date notification for a specific document.

**Parameters:**
- `db` (AsyncSession): Database session
- `document` (Document): Document object to create notification for

**Returns:** Notification dictionary or None if document has no due date

## Usage Examples

### Basic Usage

```python
from app.notifications import NotificationService

# Initialize service with default in-app channel
service = NotificationService()

# Create a notification
notification = await service.create_notification(
    db=db_session,
    title="Welcome",
    message="Welcome to 137docs!",
    notification_type="info"
)

# Get unread notifications
notifications = await service.get_all_notifications(db_session)

# Mark notification as read
await service.mark_as_read(db_session, notification_id=1)
```

### Custom Channel Implementation

```python
class EmailChannel(NotificationChannel):
    async def send(self, notification: Notification, db: AsyncSession) -> None:
        # Get user email from database
        user_query = select(