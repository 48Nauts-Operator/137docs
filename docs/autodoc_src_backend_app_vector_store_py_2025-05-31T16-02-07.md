<!--
This documentation was auto-generated by Claude on 2025-05-31T16-02-07.
Source file: ./src/backend/app/vector_store.py
-->

# Qdrant Helper Module

A lightweight Qdrant vector database client designed specifically for ColPali integration with minimal dependencies and lazy initialization.

## Overview

This module provides a simple interface to Qdrant for storing and retrieving multi-vector embeddings from document pages. It maintains a single, lazily-initialized client instance and focuses on essential operations needed for ColPali document processing.

## Configuration

The module uses environment variables for configuration:

| Variable | Default Value | Description |
|----------|---------------|-------------|
| `QDRANT_COLLECTION` | `colpali_pages` | Name of the Qdrant collection |
| `VECTOR_DB_HOST` | `qdrant` | Qdrant server hostname |
| `VECTOR_DB_PORT` | `6333` | Qdrant server port |

## Functions

### `ensure_collection(vector_size: int = 128)`

Ensures the Qdrant collection exists with the specified configuration.

**Parameters:**
- `vector_size` (int, optional): Dimension of the vectors to be stored. Defaults to 128.

**Behavior:**
- Checks if the collection exists
- If not found, creates a new collection with cosine distance metric
- Uses `recreate_collection()` to ensure clean state if collection needs to be created

**Example:**
```python
ensure_collection(vector_size=256)
```

### `upsert_page(doc_id: int, page_idx: int, multi_vectors: Sequence[Sequence[float]]) -> List[str]`

Inserts multiple vectors for a document page into the collection.

**Parameters:**
- `doc_id` (int): Unique identifier for the document
- `page_idx` (int): Page number within the document (0-indexed)
- `multi_vectors` (Sequence[Sequence[float]]): Collection of vector embeddings for the page

**Returns:**
- `List[str]`: List of generated UUID strings for each inserted vector point

**Behavior:**
- Automatically ensures collection exists with appropriate vector size
- Generates unique UUID for each vector point
- Stores vectors with metadata containing document ID and page index
- Performs batch upsert operation

**Example:**
```python
vectors = [[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]]
point_ids = upsert_page(doc_id=123, page_idx=0, multi_vectors=vectors)
print(f"Inserted {len(point_ids)} vectors")
```

### `search(query_vector: Sequence[float], top_k: int = 20)`

Performs similarity search against the vector collection.

**Parameters:**
- `query_vector` (Sequence[float]): Query vector for similarity search
- `top_k` (int, optional): Maximum number of results to return. Defaults to 20.

**Returns:**
- List of `ScoredPoint` objects from Qdrant containing matched vectors with scores and metadata

**Behavior:**
- Ensures collection exists with appropriate vector size
- Performs cosine similarity search
- Returns results sorted by similarity score

**Example:**
```python
query = [0.1, 0.2, 0.3, 0.4]
results = search(query_vector=query, top_k=10)
for result in results:
    print(f"Score: {result.score}, Doc ID: {result.payload['doc_id']}")
```

## Implementation Details

### Lazy Initialization

The module uses a global `_client` variable that is initialized only when first accessed through `_get_client()`. This design minimizes resource usage when the vector database functionality is not needed.

### Error Handling

- Collection existence is checked using exception handling rather than explicit API calls
- Uses broad exception catching for collection existence checks to handle various Qdrant error conditions

### Data Format

- Vectors are converted to plain Python lists to ensure compatibility with Qdrant's JSON serialization
- Point IDs use compact UUID hex strings for efficient storage
- Payload includes `doc_id` and `page` fields for result filtering and identification

## Dependencies

- `qdrant-client`: Official Qdrant Python client
- Standard library modules: `os`, `uuid`, `typing`

## Thread Safety

This module maintains a global client instance and should be used with caution in multi-threaded environments. The Qdrant client itself is thread-safe, but the lazy initialization pattern may create race conditions during first access.