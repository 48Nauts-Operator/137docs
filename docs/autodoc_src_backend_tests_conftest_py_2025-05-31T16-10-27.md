<!--
This documentation was auto-generated by Claude on 2025-05-31T16-10-27.
Source file: ./src/backend/tests/conftest.py
-->

# Pytest Configuration and Fixtures Documentation

## Overview

This module provides pytest configuration and fixtures for testing the 137Docs backend application. It sets up test database connections, HTTP clients, and mock data to facilitate comprehensive testing of the application's functionality.

## Configuration

### Test Database

The test suite uses an in-memory SQLite database for isolated testing:

```python
TEST_DATABASE_URL = "sqlite+aiosqlite:///:memory:"
```

This ensures tests run quickly and don't interfere with production data.

## Fixtures

### Core Testing Infrastructure

#### `event_loop`
- **Scope**: Session
- **Purpose**: Creates and manages the default event loop for async test execution
- **Usage**: Automatically used by pytest-asyncio for running async tests

```python
@pytest.fixture(scope="session")
def event_loop():
    """Create an instance of the default event loop for the test session."""
```

#### `test_engine`
- **Scope**: Session
- **Purpose**: Creates and configures the test database engine
- **Features**:
  - Uses in-memory SQLite database
  - Automatically creates all database tables
  - Handles cleanup on teardown

```python
@pytest.fixture(scope="session")
async def test_engine():
    """Create test database engine."""
```

#### `test_session`
- **Scope**: Function
- **Purpose**: Provides isolated database sessions for each test
- **Features**:
  - Automatic rollback after each test
  - Prevents test data contamination

```python
@pytest.fixture
async def test_session(test_engine):
    """Create test database session."""
```

#### `test_client`
- **Scope**: Function
- **Purpose**: Creates HTTP client for API testing
- **Features**:
  - Overrides database dependency with test session
  - Provides isolated test environment
  - Automatic cleanup of dependency overrides

```python
@pytest.fixture
async def test_client(test_session):
    """Create test HTTP client with database override."""
```

### Mock Data and Configuration

#### `mock_llm_config`
- **Scope**: Function
- **Purpose**: Provides mock LLM configuration for testing AI features
- **Configuration**:
  - Provider: Local (Ollama)
  - Multiple model types for different tasks
  - Confidence thresholds and retry settings

```python
@pytest.fixture
def mock_llm_config():
    """Mock LLM configuration for testing."""
```

**Configuration Parameters**:
| Parameter | Value | Description |
|-----------|--------|-------------|
| `provider` | `'local'` | LLM provider type |
| `api_url` | `'http://localhost:11434'` | Ollama API endpoint |
| `model_tagger` | `'phi3'` | Model for document tagging |
| `model_enricher` | `'llama3'` | Model for content enrichment |
| `model_analytics` | `'llama3'` | Model for analytics |
| `model_responder` | `'gpt-4'` | Model for responses |
| `min_confidence_tagging` | `0.7` | Minimum confidence for tagging |
| `min_confidence_entity` | `0.8` | Minimum confidence for entities |

#### `sample_document_text`
- **Scope**: Function
- **Purpose**: Provides realistic document content for testing
- **Content**: Sample invoice with typical business document structure

```python
@pytest.fixture
def sample_document_text():
    """Sample document text for testing."""
```

**Sample Content Includes**:
- Invoice header and numbering
- Business addresses
- Financial data (amounts, taxes, totals)
- Payment terms
- Dates and due dates

#### `temp_file`
- **Scope**: Function
- **Purpose**: Creates temporary files for file upload testing
- **Features**:
  - Automatic cleanup after test completion
  - Configurable content and file extension

```python
@pytest.fixture
def temp_file():
    """Create a temporary file for testing."""
```

## Usage Examples

### Testing API Endpoints

```python
async def test_upload_document(test_client):
    """Test document upload endpoint."""
    response = await test_client.post("/api/documents/upload", 
                                    files={"file": ("test.txt", "content")})
    assert response.status_code == 200
```

### Testing Database Operations

```python
async def test_create_document(test_session, sample_document_text):
    """Test document creation in database."""
    document = Document(content=sample_document_text)
    test_session.add(document)
    await test_session.commit()
    assert document.id is not None
```

### Testing with Mock Configuration

```python
def test_llm_processing(mock_llm_config, sample_document_text):
    """Test LLM processing with mock configuration."""
    processor = LLMProcessor(config=mock_llm_config)
    result = processor.process(sample_document_text)
    assert result is not None
```

## Dependencies

- **pytest**: Testing framework
- **pytest-asyncio**: Async test support
- **SQLAlchemy**: Database ORM with async support
- **httpx**: Async HTTP client for API testing
- **tempfile**: Temporary file creation
- **os**: File system operations

## Best Practices

1. **Isolation**: Each test gets fresh database session and HTTP client
2. **Cleanup**: Automatic cleanup of resources and temporary files
3. **Realistic Data**: Sample data reflects real-world document structures
4. **Configuration**: Mock configurations prevent external API calls during testing
5. **Performance**: In-memory database ensures fast test execution

## Notes

- Tests run in isolation with automatic rollback
- Temporary files are automatically cleaned up
- Mock LLM configuration prevents external API dependencies
- Session-scoped fixtures optimize performance for test suites