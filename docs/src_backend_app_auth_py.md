<!-- Auto-generated by Claude on 2025-06-01 10:12 -->

# Authentication Module Documentation

## Overview

This module provides comprehensive authentication functionality for a Document Management System. It implements multiple authentication mechanisms including JWT tokens and API keys, with support for both database-backed and in-memory user storage.

## Purpose

- **JWT Token Authentication**: Secure user sessions with time-limited access tokens
- **API Key Authentication**: Alternative authentication method for programmatic access
- **Password Management**: Secure password hashing and verification using bcrypt
- **User Management**: Handle user data with role-based access control
- **Database Integration**: Support for both PostgreSQL and fallback in-memory storage

## Key Components

### Authentication Schemes

The module supports two primary authentication methods:

- **OAuth2 Password Bearer**: JWT token-based authentication
- **API Key Header**: X-API-Key header-based authentication

### Configuration

```python
SECRET_KEY = getattr(settings, "SECRET_KEY", "")
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 30
```

⚠️ **Note**: If no `SECRET_KEY` is provided in settings, a random 32-character key is generated automatically.

## Data Models

### Core Models

#### `Token`
```python
class Token(BaseModel):
    access_token: str
    token_type: str
```
Represents an authentication token response.

#### `User`
```python
class User(BaseModel):
    id: Optional[int] = None
    username: str
    email: Optional[str] = None
    full_name: Optional[str] = None
    role: str = "viewer"
    disabled: Optional[bool] = None
```
Standard user representation with role-based access.

#### `UserInDB`
```python
class UserInDB(User):
    hashed_password: str
```
Extended user model including hashed password for database storage.

## Key Functions

### Password Management

#### `verify_password(plain_password, hashed_password)`
- **Purpose**: Verify a plain text password against its hash
- **Returns**: Boolean indicating password validity
- **Security**: Uses bcrypt for secure password verification

#### `get_password_hash(password)`
- **Purpose**: Generate a secure hash from a plain text password
- **Returns**: Hashed password string
- **Security**: Uses bcrypt with configurable rounds

### User Management

#### `get_user_db(db: AsyncSession, username: str)`
- **Purpose**: Retrieve user from database or fallback storage
- **Parameters**: 
  - `db`: Async database session
  - `username`: User identifier
- **Returns**: `UserInDB` instance or `None`
- **Fallback**: Uses in-memory storage if database lookup fails

#### `authenticate_user(db: AsyncSession, username: str, password: str)`
- **Purpose**: Authenticate user credentials
- **Returns**: `UserInDB` if valid, `None` if invalid
- **Process**: 
  1. Retrieve user from database
  2. Verify password hash
  3. Return user or None

### Token Management

#### `create_access_token(data: dict, expires_delta: Optional[timedelta])`
- **Purpose**: Generate JWT access token
- **Parameters**:
  - `data`: Payload to encode in token
  - `expires_delta`: Optional custom expiration time
- **Default Expiration**: 15 minutes if not specified
- **Returns**: Encoded JWT string

### Authentication Dependencies

#### `get_current_user()`
- **Purpose**: Extract and validate current user from request
- **Supports**: Both JWT tokens and API keys
- **Returns**: Authenticated `User` object
- **Raises**: `HTTPException` with 401 status for invalid credentials

#### `get_current_user_optional()`
- **Purpose**: Non-blocking user extraction for optional authentication
- **Returns**: `User` object or `None`
- **Use Case**: Routes that support both authenticated and anonymous access

#### `get_current_active_user()`
- **Purpose**: Ensure user is both authenticated and active
- **Raises**: `HTTPException` with 400 status for disabled users

## Fallback Data

### In-Memory User Storage

```python
fake_users_db = {
    "admin": {
        "username": "admin",
        "full_name": "Administrator", 
        "email": "admin@example.com",
        "role": "admin",
        "disabled": False,
    },
    "viewer": {
        "username": "viewer",
        "full_name": "View Only",
        "email": "viewer@example.com", 
        "role": "viewer",
        "disabled": False,
    },
}
```

⚠️ **Important**: This fallback storage is primarily for testing. Production deployments should rely on the database.

### API Keys

```python
api_keys = {
    "test-api-key": "admin"
}
```

⚠️ **Security Note**: In production, API keys should be stored securely in a database with proper encryption.

## Usage Examples

### JWT Authentication
```python
@app.get("/protected")
async def protected_route(current_user: User = Depends(get_current_active_user)):
    return {"message": f"Hello {current_user.username}"}
```

### API Key Authentication
```python
@app.get("/api/data")
async def api_data(api_key: str = Depends(verify_api_key)):
    return {"data": "sensitive information"}
```

### Optional Authentication
```python
@app.get("/public-or-private")
async def flexible_route(user: User = Depends(get_current_user_optional)):
    if user:
        return {"message": f"Welcome back, {user.username}"}
    return {"message": "Welcome, anonymous user"}
```

## Security Considerations

### ✅ Strengths
- **bcrypt**: Industry-standard password hashing
- **JWT**: Stateless token authentication
- **Role-based Access**: Configurable user permissions
- **Token Expiration**: Automatic session timeout

### ⚠️ Areas for Improvement
- **Secret Key**: Should be provided via secure configuration
- **API Keys**: Need database storage with encryption
- **Logging**: Sensitive operations should be audited
- **Rate Limiting**: Consider implementing authentication attempt limits

## Dependencies

- **FastAPI**: Web framework an