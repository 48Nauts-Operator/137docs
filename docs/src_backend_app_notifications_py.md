<!-- Auto-generated by Claude on 2025-06-01 10:12 -->

# app.notifications

## Overview

The `app.notifications` module provides a modular asynchronous notification framework for the 137docs application. This framework is designed to handle various types of notifications through different channels while maintaining a clean, extensible architecture.

## Key Features

- **Modular Channel System**: Supports multiple notification channels (in-app, email, Slack, SMS, etc.)
- **Asynchronous Architecture**: Built with pure SQLAlchemy async code for non-blocking operations
- **Database Persistence**: All notifications are recorded in the database regardless of delivery channel
- **Extensible Design**: New channels can be added without modifying core logic
- **Document Management Integration**: Specialized functions for document due date notifications

## Core Components

### Abstract Base Classes

#### `NotificationChannel`

Abstract base class that defines the interface for all notification channels.

```python
class NotificationChannel(ABC):
    @abstractmethod
    async def send(self, notification: Notification, db: AsyncSession) -> None:
        """Deliver notification via this channel"""
```

**Key Points:**
- All custom channels must inherit from this class
- Requires implementation of the `send()` method
- Receives database session for additional queries if needed

### Channel Implementations

#### `InAppChannel`

The default notification channel that only stores notifications in the database without external delivery.

```python
class InAppChannel(NotificationChannel):
    async def send(self, notification: Notification, db: AsyncSession) -> None:
        # Already persisted; nothing else to do.
        return
```

**Features:**
- No external delivery mechanism
- Ensures notifications are always stored in database
- Acts as fallback channel

### Core Service

#### `NotificationService`

The main service class that orchestrates notification creation, persistence, and delivery.

```python
class NotificationService:
    def __init__(self, channels: Optional[Sequence[NotificationChannel]] = None):
        # Configuration logic
```

**Key Methods:**

##### CRUD Operations

- **`create_notification()`**: Creates and persists notifications, then dispatches to all channels
- **`get_all_notifications()`**: Retrieves notifications with filtering and pagination
- **`mark_as_read()`**: Marks individual notifications as read
- **`mark_all_as_read()`**: Marks all unread notifications as read

##### Document Management

- **`check_overdue_documents()`**: Identifies and creates notifications for overdue documents
- **`check_upcoming_due_dates()`**: Creates reminders for documents due within a specified timeframe
- **`create_due_date_notification()`**: Creates notifications for specific document due dates

## Usage Examples

### Basic Service Setup

```python
# Default setup with in-app channel only
service = NotificationService()

# Custom setup with multiple channels
service = NotificationService([
    InAppChannel(),
    EmailChannel(),  # Custom implementation
    SlackChannel()   # Custom implementation
])
```

### Creating Notifications

```python
notification = await service.create_notification(
    db=db_session,
    title="Document Updated",
    message="Your document has been successfully updated.",
    notification_type="info",
    document_id=123
)
```

### Retrieving Notifications

```python
# Get unread notifications
notifications = await service.get_all_notifications(
    db=db_session,
    limit=50,
    include_read=False
)

# Get all notifications with pagination
all_notifications = await service.get_all_notifications(
    db=db_session,
    limit=25,
    offset=50,
    include_read=True
)
```

## Design Patterns

### Channel Registration
- Channels are registered at service initialization
- `InAppChannel` is automatically included and positioned first
- Multiple channels can be active simultaneously

### Error Handling
- Channel delivery failures are logged but don't prevent notification persistence
- Database operations are wrapped in proper async session management
- Graceful degradation when external channels fail

### Data Serialization
- `_notification_to_dict()` helper converts SQLAlchemy models to JSON-serializable dictionaries
- Handles null values and datetime formatting appropriately

## Extension Points

### Adding Custom Channels

To add a new notification channel:

1. Inherit from `NotificationChannel`
2. Implement the `send()` method
3. Register the channel when creating `NotificationService`

```python
class EmailChannel(NotificationChannel):
    async def send(self, notification: Notification, db: AsyncSession) -> None:
        # Email delivery logic here
        user_email = await self.get_user_email(notification.user_id, db)
        await self.send_email(user_email, notification.title, notification.message)
```

## Important Notes

### Performance Considerations
- All database operations use async/await patterns
- Notification retrieval includes pagination support
- Duplicate notification prevention for document-related alerts

### Database Dependencies
- Requires `Notification` and `Document` models
- Uses SQLAlchemy async sessions throughout
- Maintains referential integrity with document relationships

### Logging
- Comprehensive logging setup with INFO level default
- Channel failures are logged as warnings
- Structured log format for better debugging

## Future Enhancements

The framework is designed to support:
- Real-time notifications via Server-Sent Events (SSE)
- Push notifications for mobile applications
- Advanced notification templating
- User preference management for notification channels
- Bulk notification operations