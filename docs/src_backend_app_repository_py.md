<!-- Auto-generated by Claude on 2025-06-01 10:12 -->

# Document Repository Documentation

## Overview

This file implements repository pattern classes for database operations in a document management system. It provides data access layers for documents, users, LLM configurations, tenants (entities), and processing rules using SQLAlchemy with async support.

## Purpose

The repository pattern separates business logic from data access logic, providing a clean interface for database operations while handling:
- Document CRUD operations with tag management
- User management and authentication
- LLM configuration management
- Multi-tenant support
- Processing rule management for document automation

## Classes and Functions

### DocumentRepository

Main repository for document-related database operations.

#### Key Methods

##### `create(db: AsyncSession, document: Document) -> Document`
Creates a new document in the database.

```python
document = Document(title="Test", content="Content")
created_doc = await repo.create(db, document)
```

##### `get_by_id(db: AsyncSession, document_id: int, as_dict: bool = False)`
Retrieves a document by ID with optional dictionary conversion.

```python
# Get as Document object
doc = await repo.get_by_id(db, 1)

# Get as dictionary for JSON responses
doc_dict = await repo.get_by_id(db, 1, as_dict=True)
```

##### `get_all(db: AsyncSession, status=None, document_type=None, search=None)`
Retrieves all documents with optional filtering and search capabilities.

**Filtering options:**
- `status`: Filter by document status
- `document_type`: Filter by document type
- `search`: Search in title, content, or sender fields

##### Tag Management Methods

- **`add_tag(db, document_id, tag_name)`**: Adds a tag to a document
- **`remove_tag(db, document_id, tag_name)`**: Removes a tag from a document
- **`get_tags(db, document_id)`**: Returns list of tag names for a document

##### `_to_dict(doc: Document, include_tags: bool = True) -> Dict[str, Any]`
Static helper method that converts Document objects to JSON-serializable dictionaries.

**Features:**
- Handles vector embeddings conversion to float lists
- Converts datetime objects to ISO format
- Strips SQLAlchemy internal state
- Flattens tag relationships to simple name lists
- Handles numpy types if present

### UserRepository

Manages user data access operations.

#### Key Methods

- **`get_all(db)`**: Returns all users as dictionaries
- **`get_by_id(db, user_id)`**: Gets user by ID as dictionary
- **`get_by_username(db, username)`**: Returns actual UserDB model for authentication
- **`create(db, **data)`**: Creates new user
- **`update(db, user_id, **data)`**: Updates user data
- **`delete(db, user_id)`**: Deletes user

### LLMConfigRepository

Handles LLM (Large Language Model) configuration management.

#### Key Methods

##### `get_config(db: AsyncSession) -> Optional[dict]`
Retrieves the current LLM configuration (singleton pattern).

##### `test_connection(db, provider, api_url=None, api_key=None) -> dict`
Tests connection to LLM provider and returns available models.

```python
result = await repo.test_connection(db, "openai", api_key="sk-...")
# Returns: {"status": "success", "available_models": [...]}
```

### TenantRepository

Manages multi-tenant functionality through Entity profiles.

#### Key Features

- **Multi-tenant support**: Users can belong to multiple entities
- **Default tenant**: Each user can have one default tenant
- **Soft delete**: Tenants are marked inactive rather than deleted
- **Access control**: Users can only access their associated tenants

#### Key Methods

- **`get_user_tenants(db, user_id)`**: Gets all tenants for a user
- **`get_default_tenant(db, user_id)`**: Gets user's default tenant
- **`create_tenant(db, user_id, **data)`**: Creates new tenant for user
- **`set_default_tenant(db, user_id, tenant_id)`**: Sets default tenant

### ProcessingRuleRepository

Manages automated document processing rules.

#### Key Methods

- **`get_enabled_rules(db)`**: Gets all enabled rules ordered by priority
- **`increment_matches(db, rule_id)`**: Tracks rule usage statistics
- **`create/update/delete`**: Standard CRUD operations

**Rule Structure:**
- `conditions`: JSON array of matching conditions
- `actions`: JSON array of actions to perform
- `priority`: Processing order (lower = higher priority)

## Important Notes and Suggestions

### Performance Considerations

1. **Eager Loading**: The repository uses `selectinload(Document.tags)` to avoid N+1 queries when loading document tags.

2. **Vector Handling**: The `_to_dict` method properly converts vector embeddings to plain Python lists for JSON serialization.

3. **Async Safety**: The document deletion method uses direct SQL to avoid lazy-loading issues that cause `MissingGreenlet` errors in async contexts.

### Error Handling

- Most methods return `None` or `False` for not-found cases rather than raising exceptions
- The LLM connection test method includes comprehensive error handling
- Database operations use proper transaction management with flush/refresh patterns

### Security Considerations

- User repository separates authentication (returns model) from data access (returns dict)
- Tenant repository enforces user access controls
- SQL injection protection through SQLAlchemy parameterized queries

### Code Quality Suggestions

1. **Add Type Hints**: Some methods could benefit from more specific return type hints
2. **Error Logging**: Consider adding more detailed logging for debugging
3. **Validation**: Add input validation for critical operations
4. **Documentation**: Some complex methods could use more detailed docstrings

### Usage Example

```python
# Initialize repositories
doc_repo = DocumentRepository()
user_repo = UserRepository()

# Create and manage documents
async with get_db_session() as db:
    # Create document
    doc = Document(title="Invoice", content="...")
    created = await doc_repo.create(db, doc)
    
    # Add tags
    await doc_repo.add_tag(db, created.id, "financial")