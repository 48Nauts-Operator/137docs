<!-- Auto-generated by Claude on 2025-06-01 10:12 -->

# Flight Check Service Documentation

## Overview

The **Flight Check Service** is a comprehensive platform diagnostics system that implements all diagnostic tests specified in the platform's flight-check documentation. It provides three levels of system health monitoring: quick health checks, comprehensive checks, and deep diagnostics.

## Purpose

This service monitors and validates the health of all critical platform components including:
- Database connectivity and schema integrity
- Authentication systems
- AI/LLM services
- File system and document processing
- Multi-tenant architecture
- Analytics and reporting
- Performance metrics
- Security configurations

## Main Class

### `FlightCheckService`

The primary class that orchestrates all diagnostic operations.

```python
class FlightCheckService:
    def __init__(self, db_session: AsyncSession):
        self.db_session = db_session
        self.start_time = time.time()
```

**Parameters:**
- `db_session`: Async SQLAlchemy database session for performing database operations

## Core Methods

### 1. Quick Health Check (`quick_health_check()`)

**Duration:** ~30 seconds  
**Purpose:** Essential systems validation for rapid status assessment

```python
async def quick_health_check(self) -> Dict[str, Any]:
```

**Checks performed:**
- Database connectivity
- Frontend accessibility
- Authentication system
- Basic API health

**Returns:** Dictionary with status, timestamp, duration, test results, and detailed check information.

### 2. Comprehensive Check (`comprehensive_check()`)

**Duration:** ~5 minutes  
**Purpose:** All major systems validation

```python
async def comprehensive_check(self) -> Dict[str, Any]:
```

**Categories checked:**
- Critical Systems
- AI & LLM Services
- File System & Processing
- Multi-Tenant System
- Analytics & Reporting

### 3. Deep Diagnostic (`deep_diagnostic()`)

**Duration:** ~15 minutes  
**Purpose:** Complete system analysis including performance and security

```python
async def deep_diagnostic(self) -> Dict[str, Any]:
```

**Additional categories:**
- Performance monitoring
- Security configurations
- External integrations

## Diagnostic Categories

### Critical Systems

- **Database**: Connection, schema validation, table existence
- **Authentication**: User management, admin user validation, session handling  
- **Document Processing**: Pipeline status, recent activity, failed documents

### AI & LLM Services

- **LLM Configuration**: Provider setup, model configuration, connectivity
- **Vector Database**: Qdrant connectivity, vector storage validation
- **Tenant Extraction**: AI-powered tenant identification system

### File System & Processing

- **Folder Configuration**: Path validation, accessibility checks
- **Processing Rules**: Rules engine status, active rules count

### Multi-Tenant System

- **Tenant Management**: Entity management, default tenant setup
- **Entity System**: Company/individual entities, user associations

### Analytics & Reporting

- **Analytics Service**: Document statistics, invoice processing, chart availability

### Performance (Deep Diagnostic Only)

- **System Resources**: CPU, memory, disk usage monitoring
- **Database Performance**: Query execution time analysis

### Security (Deep Diagnostic Only)

- **Authentication Security**: Admin user validation, JWT configuration
- **Password Security**: Hashing validation, security best practices

### Integrations (Deep Diagnostic Only)

- **Calendar Integration**: ICS export, calendar sync capabilities
- **Notifications**: Email and in-app notification systems

## Return Format

All check methods return a standardized dictionary structure:

```python
{
    "status": "healthy|degraded|unhealthy",
    "timestamp": "2024-01-01T12:00:00",
    "duration_seconds": 45.2,
    "tests_passed": 12,
    "tests_failed": 1,
    "tests_total": 13,
    "checks": {
        "category_name": {
            "status": "healthy|degraded|unhealthy",
            "message": "Description of check result",
            "details": {
                # Specific metrics and information
            }
        }
    }
}
```

## Status Levels

- **healthy**: All systems operational
- **degraded**: Minor issues detected, system partially functional
- **unhealthy**: Critical issues detected, immediate attention required
- **disabled**: Feature intentionally disabled

## Usage Example

```python
from app.services.flight_check_service import FlightCheckService

# Initialize service
flight_check = FlightCheckService(db_session)

# Quick health check
quick_result = await flight_check.quick_health_check()

# Comprehensive check
comprehensive_result = await flight_check.comprehensive_check()

# Deep diagnostic
deep_result = await flight_check.deep_diagnostic()
```

## Dependencies

### Required Imports
- `asyncio`, `os`, `psutil`, `time` - System utilities
- `datetime`, `pathlib`, `typing` - Standard library utilities
- `sqlalchemy` - Database operations
- Custom models and repositories from the application

### Database Requirements
- Requires async SQLAlchemy session
- Expects specific database schema with required tables
- Uses raw SQL queries for performance checks

## Notes and Suggestions

### Performance Considerations
- **Quick checks** are designed for frequent monitoring
- **Comprehensive checks** suitable for scheduled health monitoring
- **Deep diagnostics** should be run during maintenance windows

### Monitoring Integration
- Results can be integrated with monitoring systems (Prometheus, Grafana)
- Status endpoints can be exposed via REST API
- Consider implementing alerting based on health check results

### Error Handling
- All checks include comprehensive exception handling
- Failed checks don't prevent other checks from running
- Detailed error information provided in response details

### Extensibility
- Easy to add new check categories
- Modular design allows for custom diagnostic modules
- Check thresholds can be made configurable

### Security Notes
- Avoid exposing sensitive configuration details in check results
- Consider authentication requirements for diagnostic endpoints
- Log diagnostic activities for audit purposes